###沒有驗證hostname
HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
###可以透過加上@繞過
if (url.startsWith("https://pentesterlab.com")){
###可以購買secureApentesterlab.com域名繞過，因爲正則裡面的.沒有被轉義
Pattern pattern = Pattern.compile("^https:\\/\\/secure.pentesterlab.com\\/");
###可以透過在url中包含這些字段來繞過，https://example.com/secure.pentesterlab.com，應該要把正則匹配在host字段，不是在整個url
Pattern pattern = Pattern.compile("secure\\.pentesterlab\\.com");





###java範例，常用br把東西讀出來，然後用while迴圈把東西一行一行讀出來，直到沒有東西爲止
	try {
https_url = new URL(url);
HttpsURLConnection con = (HttpsURLConnection)https_url.openConnection();

BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));
String input;

while ((input = br.readLine()) != null){
	System.out.println(input);
}
br.close();

###java更安全的xml解析方法，第一個可能導致XML注入
-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            DocumentBuilderFactory factory = ParserUtils.getSaferDocumentBuilderFactory();

###使用SHA-256加密，而不是用HMAC-SHA-256加密
    MessageDigest digest = MessageDigest.getInstance("SHA-256");


###使用不夠安全的random及使用static，可能導致前後的OTP洩漏
	import java.util.Random;
 
public class Otp {
  private static final Random R = new Random();
 
  public static String generateCode() {
    StringBuilder builder = new StringBuilder();
      for (int i = 0; i < 4 ; i++) {
        builder.append(R.nextInt(10));
      }
    return builder.toString();
  }
}

###使用都是0的IV，可能導致加密的內容洩漏
	    SecretKey key = new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES"); 
    byte[] IV = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 

###從數據流中讀取數據，使用者可透過輸入file://來取得本機上的檔案
       stream = new DataInputStream(url.openStream());
