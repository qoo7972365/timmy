<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.10) on Sun Mar 21 16:59:44 GMT 2021 -->
<title>JDBCPreparedStatement (HSQLDB 2.6.0 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2021-03-21">
<link rel="stylesheet" type="text/css" href="../../../javadoc.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="JDBCPreparedStatement (HSQLDB 2.6.0 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":10,"i87":10,"i88":10,"i89":10,"i90":10,"i91":10,"i92":10,"i93":10,"i94":10,"i95":10,"i96":10,"i97":10,"i98":10,"i99":10,"i100":10,"i101":10,"i102":10,"i103":42,"i104":10,"i105":10,"i106":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/JDBCPreparedStatement.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.hsqldb.jdbc</a></div>
<h2 title="Class JDBCPreparedStatement" class="title">Class JDBCPreparedStatement</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.hsqldb.jdbc.JDBCPreparedStatement</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code>java.lang.AutoCloseable</code>, <code>java.sql.PreparedStatement</code>, <code>java.sql.Statement</code>, <code>java.sql.Wrapper</code></dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="JDBCCallableStatement.html" title="class in org.hsqldb.jdbc">JDBCCallableStatement</a></code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">JDBCPreparedStatement</span>
extends java.lang.Object
implements java.sql.PreparedStatement</pre>
<div class="block"><!-- start generic documentation -->

 An object that represents a precompiled SQL statement.
 <P>A SQL statement is precompiled and stored in a
 <code>PreparedStatement</code> object. This object can then be used to
 efficiently execute this statement multiple times.

 <P><B>Note:</B> The setter methods (<code>setShort</code>, <code>setString</code>,
 and so on) for setting IN parameter values
 must specify types that are compatible with the defined SQL type of
 the input parameter. For instance, if the IN parameter has SQL type
 <code>INTEGER</code>, then the method <code>setInt</code> should be used.

 <p>If arbitrary parameter type conversions are required, the method
 <code>setObject</code> should be used with a target SQL type.
 <P>
 In the following example of setting a parameter, <code>con</code> represents
 an active connection:
 <PRE>
   PreparedStatement pstmt = con.prepareStatement("UPDATE EMPLOYEES
                                     SET SALARY = ? WHERE ID = ?");
   pstmt.setBigDecimal(1, 153833.00)
   pstmt.setInt(2, 110592)
 </PRE>

 <!-- end generic documentation -->

 <!-- start Release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 From version 2.0, the implementation meets the JDBC specification
 requirement that any existing ResultSet is closed when execute() or
 executeQuery() methods are called. The connection property close_result=true
 is required for this behaviour.
 <p>
 JDBCPreparedStatement objects are backed by
 a true compiled parametric representation. Hence, there are now significant
 performance gains to be had by using a JDBCPreparedStatement object in
 preference to a JDBCStatement object when a short-running SQL statement is
 to be executed more than once. <p>

 When it can be otherwise avoided, it should be considered poor practice to
 fully prepare (construct), parameterize, execute, fetch and close a
 JDBCParameterMetaData object for each execution cycle. Indeed,
 because the prepare and execute phases
 both represent a round-trip to the engine, this practice is likely to be
 noticeably <em>less</em> performant for short-running statements (and
 possibly even orders of magnitude less performant over network connections
 for short-running statements) than the equivalent process using JDBCStatement
 objects, albeit far more convenient, less error prone and certainly much
 less resource-intensive, especially when large binary and character values
 are involved, due to the optimized parameterization facility. <p>

 Instead, when developing an application that is not totally oriented toward
 the execution of ad hoc SQL, it is recommended to expend some effort toward
 identifying the SQL statements that are good candidates for regular reuse and
 adapting the structure of the application accordingly. Often, this is done
 by recording the text of candidate SQL statements in an application resource
 object (which has the nice side-benefit of isolating and hiding differences
 in SQL dialects across different drivers) and caching for possible reuse the
 PreparedStatement objects derived from the recorded text. <p>

 Starting with 2.0, when built under a JDBC 4 environment, statement caching
 can be transparently enabled or disabled on a statement-by-statement basis by
 invoking setPoolable(true | false), respectively, upon Statement objects of
 interest. <p>

 <b>Multi thread use:</b> <p>

 A PreparedStatement object is stateful and should not normally be shared
 by multiple threads. If it has to be shared, the calls to set the
 parameters, calls to add batch statements, the execute call and any
 post-execute calls should be made within a block synchronized on the
 PreparedStatement Object.<p>

 (fredt@users)<br>
 (campbell-burnet@users)<p>

 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.9.0</dd>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Campbell Burnet (campbell-burnet@users dot sourceforge.net), Fred Toussi (fredt@users dot sourceforge.net)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="JDBCConnection.html#prepareStatement(java.lang.String)"><code>JDBCConnection.prepareStatement(java.lang.String)</code></a>, 
<a href="JDBCResultSet.html" title="class in org.hsqldb.jdbc"><code>JDBCResultSet</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.java.sql.Statement">
<!--   -->
</a>
<h3>Fields inherited from interface&nbsp;java.sql.Statement</h3>
<code>CLOSE_ALL_RESULTS, CLOSE_CURRENT_RESULT, EXECUTE_FAILED, KEEP_CURRENT_RESULT, NO_GENERATED_KEYS, RETURN_GENERATED_KEYS, SUCCESS_NO_INFO</code></li>
</ul>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addBatch()">addBatch</a></span>()</code></th>
<td class="colLast">
<div class="block">Adds a set of parameters to this <code>PreparedStatement</code>
 object's batch of commands.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addBatch(java.lang.String)">addBatch</a></span>&#8203;(java.lang.String&nbsp;sql)</code></th>
<td class="colLast">
<div class="block">This method should always throw if called for a PreparedStatement or
 CallableStatement.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cancel()">cancel</a></span>()</code></th>
<td class="colLast">
<div class="block">Cancels this <code>Statement</code> object if both the DBMS and
 driver support aborting an SQL statement.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearBatch()">clearBatch</a></span>()</code></th>
<td class="colLast">
<div class="block">Empties this <code>Statement</code> object's current list of
 SQL commands.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearParameters()">clearParameters</a></span>()</code></th>
<td class="colLast">
<div class="block">Clears the current parameter values immediately.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearWarnings()">clearWarnings</a></span>()</code></th>
<td class="colLast">
<div class="block">Clears all the warnings reported on this <code>Statement</code>
 object.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#close()">close</a></span>()</code></th>
<td class="colLast">
<div class="block">Does the specialized work required to free this object's resources and
 that of it's parent class.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#closeOnCompletion()">closeOnCompletion</a></span>()</code></th>
<td class="colLast">
<div class="block">Specifies that this <code>Statement</code> will be closed when all its
 dependent result sets are closed.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#execute()">execute</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes the SQL statement in this <code>PreparedStatement</code> object,
 which may be any kind of SQL statement.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#execute(java.lang.String)">execute</a></span>&#8203;(java.lang.String&nbsp;sql)</code></th>
<td class="colLast">
<div class="block">This method should always throw if called for a PreparedStatement or
 CallableStatement.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#execute(java.lang.String,int)">execute</a></span>&#8203;(java.lang.String&nbsp;sql,
       int&nbsp;autoGeneratedKeys)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#execute(java.lang.String,int%5B%5D)">execute</a></span>&#8203;(java.lang.String&nbsp;sql,
       int[]&nbsp;columnIndexes)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#execute(java.lang.String,java.lang.String%5B%5D)">execute</a></span>&#8203;(java.lang.String&nbsp;sql,
       java.lang.String[]&nbsp;columnNames)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeBatch()">executeBatch</a></span>()</code></th>
<td class="colLast">
<div class="block">Submits a batch of commands to the database for execution and
 if all commands execute successfully, returns an array of update counts.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>long[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeLargeBatch()">executeLargeBatch</a></span>()</code></th>
<td class="colLast">
<div class="block">Submits a batch of commands to the database for execution and
 if all commands execute successfully, returns an array of update counts.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeLargeUpdate()">executeLargeUpdate</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes the SQL statement in this <code>PreparedStatement</code> object,
 which must be an SQL Data Manipulation Language (DML) statement,
 such as <code>INSERT</code>, <code>UPDATE</code> or
 <code>DELETE</code>; or an SQL statement that returns nothing,
 such as a DDL statement.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>java.sql.ResultSet</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeQuery()">executeQuery</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes the SQL query in this <code>PreparedStatement</code> object
 and returns the <code>ResultSet</code> object generated by the query.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>java.sql.ResultSet</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeQuery(java.lang.String)">executeQuery</a></span>&#8203;(java.lang.String&nbsp;sql)</code></th>
<td class="colLast">
<div class="block">This method should always throw if called for a PreparedStatement or
 CallableStatement.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeUpdate()">executeUpdate</a></span>()</code></th>
<td class="colLast">
<div class="block">Executes the SQL statement in this <code>PreparedStatement</code> object,
 (JDBC4 clarification:)
 which must be an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or
 <code>DELETE</code>; or an SQL statement that returns nothing,
 such as a DDL statement.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeUpdate(java.lang.String)">executeUpdate</a></span>&#8203;(java.lang.String&nbsp;sql)</code></th>
<td class="colLast">
<div class="block">This method should always throw if called for a PreparedStatement or
 CallableStatement.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeUpdate(java.lang.String,int)">executeUpdate</a></span>&#8203;(java.lang.String&nbsp;sql,
             int&nbsp;autoGeneratedKeys)</code></th>
<td class="colLast">
<div class="block">Statement methods that must be overridden in this class and throw
 an exception.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeUpdate(java.lang.String,int%5B%5D)">executeUpdate</a></span>&#8203;(java.lang.String&nbsp;sql,
             int[]&nbsp;columnIndexes)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeUpdate(java.lang.String,java.lang.String%5B%5D)">executeUpdate</a></span>&#8203;(java.lang.String&nbsp;sql,
             java.lang.String[]&nbsp;columnNames)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>java.sql.Connection</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getConnection()">getConnection</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the <code>Connection</code> object
 that produced this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFetchDirection()">getFetchDirection</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the direction for fetching rows from
 database tables that is the default for result sets
 generated from this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFetchSize()">getFetchSize</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the number of result set rows that is the default
 fetch size for <code>ResultSet</code> objects
 generated from this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>java.sql.ResultSet</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getGeneratedKeys()">getGeneratedKeys</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves any auto-generated keys created as a result of executing this
 <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLargeMaxRows()">getLargeMaxRows</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the maximum number of rows that a
 <code>ResultSet</code> object produced by this
 <code>Statement</code> object can contain.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLargeUpdateCount()">getLargeUpdateCount</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the current result as an update count; if the result
 is a <code>ResultSet</code> object or there are no more results, -1
  is returned.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMaxFieldSize()">getMaxFieldSize</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the maximum number of bytes that can be
 returned for character and binary column values in a <code>ResultSet</code>
 object produced by this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMaxRows()">getMaxRows</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the maximum number of rows that a
 <code>ResultSet</code> object produced by this
 <code>Statement</code> object can contain.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>java.sql.ResultSetMetaData</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMetaData()">getMetaData</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves a <code>ResultSetMetaData</code> object that contains
 information about the columns of the <code>ResultSet</code> object
 that will be returned when this <code>PreparedStatement</code> object
 is executed.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMoreResults()">getMoreResults</a></span>()</code></th>
<td class="colLast">
<div class="block">Moves to this <code>Statement</code> object's next result, returns
 <code>true</code> if it is a <code>ResultSet</code> object, and
 implicitly closes any current <code>ResultSet</code>
 object(s) obtained with the method <code>getResultSet</code>.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMoreResults(int)">getMoreResults</a></span>&#8203;(int&nbsp;current)</code></th>
<td class="colLast">
<div class="block">Moves to this <code>Statement</code> object's next result, deals with
 any current <code>ResultSet</code> object(s) according  to the instructions
 specified by the given flag, and returns
 <code>true</code> if the next result is a <code>ResultSet</code> object.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>java.sql.ParameterMetaData</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getParameterMetaData()">getParameterMetaData</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the number, types and properties of this
 <code>PreparedStatement</code> object's parameters.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getQueryTimeout()">getQueryTimeout</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the number of seconds the driver will
 wait for a <code>Statement</code> object to execute.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>java.sql.ResultSet</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getResultSet()">getResultSet</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the current result as a <code>ResultSet</code> object.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getResultSetConcurrency()">getResultSetConcurrency</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the result set concurrency for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getResultSetHoldability()">getResultSetHoldability</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the result set holdability for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getResultSetType()">getResultSetType</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the result set type for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUpdateCount()">getUpdateCount</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the current result as an update count;
  if the result is a <code>ResultSet</code> object or there are no more results, -1
  is returned.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>java.sql.SQLWarning</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getWarnings()">getWarnings</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves the first warning reported by calls on this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isClosed()">isClosed</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves whether this <code>Statement</code> object has been closed.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isCloseOnCompletion()">isCloseOnCompletion</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns a value indicating whether this <code>Statement</code> will be
 closed when all its dependent result sets are closed.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isPoolable()">isPoolable</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns a  value indicating whether the <code>Statement</code>
 is poolable or not.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isWrapperFor(java.lang.Class)">isWrapperFor</a></span>&#8203;(java.lang.Class&lt;?&gt;&nbsp;iface)</code></th>
<td class="colLast">
<div class="block">Returns true if this either implements the interface argument or is directly or indirectly a wrapper
 for an object that does.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setArray(int,java.sql.Array)">setArray</a></span>&#8203;(int&nbsp;parameterIndex,
        java.sql.Array&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.Array</code> object.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setAsciiStream(int,java.io.InputStream)">setAsciiStream</a></span>&#8203;(int&nbsp;parameterIndex,
              java.io.InputStream&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given input stream.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setAsciiStream(int,java.io.InputStream,int)">setAsciiStream</a></span>&#8203;(int&nbsp;parameterIndex,
              java.io.InputStream&nbsp;x,
              int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setAsciiStream(int,java.io.InputStream,long)">setAsciiStream</a></span>&#8203;(int&nbsp;parameterIndex,
              java.io.InputStream&nbsp;x,
              long&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBigDecimal(int,java.math.BigDecimal)">setBigDecimal</a></span>&#8203;(int&nbsp;parameterIndex,
             java.math.BigDecimal&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.math.BigDecimal</code> value.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBinaryStream(int,java.io.InputStream)">setBinaryStream</a></span>&#8203;(int&nbsp;parameterIndex,
               java.io.InputStream&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given input stream.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBinaryStream(int,java.io.InputStream,int)">setBinaryStream</a></span>&#8203;(int&nbsp;parameterIndex,
               java.io.InputStream&nbsp;x,
               int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBinaryStream(int,java.io.InputStream,long)">setBinaryStream</a></span>&#8203;(int&nbsp;parameterIndex,
               java.io.InputStream&nbsp;x,
               long&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBlob(int,java.io.InputStream)">setBlob</a></span>&#8203;(int&nbsp;parameterIndex,
       java.io.InputStream&nbsp;inputStream)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to a <code>InputStream</code> object.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBlob(int,java.io.InputStream,long)">setBlob</a></span>&#8203;(int&nbsp;parameterIndex,
       java.io.InputStream&nbsp;inputStream,
       long&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to a <code>InputStream</code> object.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBlob(int,java.sql.Blob)">setBlob</a></span>&#8203;(int&nbsp;parameterIndex,
       java.sql.Blob&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.Blob</code> object.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBoolean(int,boolean)">setBoolean</a></span>&#8203;(int&nbsp;parameterIndex,
          boolean&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given Java <code>boolean</code> value.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setByte(int,byte)">setByte</a></span>&#8203;(int&nbsp;parameterIndex,
       byte&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given Java <code>byte</code> value.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setBytes(int,byte%5B%5D)">setBytes</a></span>&#8203;(int&nbsp;parameterIndex,
        byte[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given Java array of bytes.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setCharacterStream(int,java.io.Reader)">setCharacterStream</a></span>&#8203;(int&nbsp;parameterIndex,
                  java.io.Reader&nbsp;reader)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>Reader</code>
 object.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setCharacterStream(int,java.io.Reader,int)">setCharacterStream</a></span>&#8203;(int&nbsp;parameterIndex,
                  java.io.Reader&nbsp;reader,
                  int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setCharacterStream(int,java.io.Reader,long)">setCharacterStream</a></span>&#8203;(int&nbsp;parameterIndex,
                  java.io.Reader&nbsp;reader,
                  long&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setClob(int,java.io.Reader)">setClob</a></span>&#8203;(int&nbsp;parameterIndex,
       java.io.Reader&nbsp;reader)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to a <code>Reader</code> object.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setClob(int,java.io.Reader,long)">setClob</a></span>&#8203;(int&nbsp;parameterIndex,
       java.io.Reader&nbsp;reader,
       long&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to a <code>Reader</code> object.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setClob(int,java.sql.Clob)">setClob</a></span>&#8203;(int&nbsp;parameterIndex,
       java.sql.Clob&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.Clob</code> object.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setCursorName(java.lang.String)">setCursorName</a></span>&#8203;(java.lang.String&nbsp;name)</code></th>
<td class="colLast">
<div class="block">Sets the SQL cursor name to the given <code>String</code>, which
 will be used by subsequent <code>Statement</code> object
 <code>execute</code> methods.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDate(int,java.sql.Date)">setDate</a></span>&#8203;(int&nbsp;parameterIndex,
       java.sql.Date&nbsp;x)</code></th>
<td class="colLast">
<div class="block">(JDBC4 clarification:)
 Sets the designated parameter to the given <code>java.sql.Date</code> value
 using the default time zone of the virtual machine that is running
 the application.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDate(int,java.sql.Date,java.util.Calendar)">setDate</a></span>&#8203;(int&nbsp;parameterIndex,
       java.sql.Date&nbsp;x,
       java.util.Calendar&nbsp;cal)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.Date</code> value,
 using the given <code>Calendar</code> object.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDouble(int,double)">setDouble</a></span>&#8203;(int&nbsp;parameterIndex,
         double&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given Java <code>double</code> value.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setEscapeProcessing(boolean)">setEscapeProcessing</a></span>&#8203;(boolean&nbsp;enable)</code></th>
<td class="colLast">
<div class="block">Sets escape processing on or off.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setFetchDirection(int)">setFetchDirection</a></span>&#8203;(int&nbsp;direction)</code></th>
<td class="colLast">
<div class="block">Gives the driver a hint as to the direction in which
 rows will be processed in <code>ResultSet</code>
 objects created using this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setFetchSize(int)">setFetchSize</a></span>&#8203;(int&nbsp;rows)</code></th>
<td class="colLast">
<div class="block">(JDBC4 clarification:)
 Gives the JDBC driver a hint as to the number of rows that should
 be fetched from the database when more rows are needed for
 <code>ResultSet</code> objects generated by this <code>Statement</code>.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setFloat(int,float)">setFloat</a></span>&#8203;(int&nbsp;parameterIndex,
        float&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given Java <code>float</code> value.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setInt(int,int)">setInt</a></span>&#8203;(int&nbsp;parameterIndex,
      int&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given Java <code>int</code> value.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setLargeMaxRows(long)">setLargeMaxRows</a></span>&#8203;(long&nbsp;max)</code></th>
<td class="colLast">
<div class="block">Sets the limit for the maximum number of rows that any
 <code>ResultSet</code> object  generated by this <code>Statement</code>
 object can contain to the given number.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setLong(int,long)">setLong</a></span>&#8203;(int&nbsp;parameterIndex,
       long&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given Java <code>long</code> value.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxFieldSize(int)">setMaxFieldSize</a></span>&#8203;(int&nbsp;max)</code></th>
<td class="colLast">
<div class="block">(JDBC4 clarification:) Sets the limit for the maximum number of bytes in a <code>ResultSet</code>
 Sets the limit for the maximum number of bytes that can be returned for
 character and binary column values in a <code>ResultSet</code>
 object produced by this <code>Statement</code> object.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxRows(int)">setMaxRows</a></span>&#8203;(int&nbsp;max)</code></th>
<td class="colLast">
<div class="block">(JDBC4 clarification:)
 Sets the limit for the maximum number of rows that any
 <code>ResultSet</code> object  generated by this <code>Statement</code>
 object can contain to the given number.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNCharacterStream(int,java.io.Reader)">setNCharacterStream</a></span>&#8203;(int&nbsp;parameterIndex,
                   java.io.Reader&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to a <code>Reader</code> object.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNCharacterStream(int,java.io.Reader,long)">setNCharacterStream</a></span>&#8203;(int&nbsp;parameterIndex,
                   java.io.Reader&nbsp;value,
                   long&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to a <code>Reader</code> object.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNClob(int,java.io.Reader)">setNClob</a></span>&#8203;(int&nbsp;parameterIndex,
        java.io.Reader&nbsp;reader)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to a <code>Reader</code> object.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNClob(int,java.io.Reader,long)">setNClob</a></span>&#8203;(int&nbsp;parameterIndex,
        java.io.Reader&nbsp;reader,
        long&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to a <code>Reader</code> object.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNClob(int,java.sql.NClob)">setNClob</a></span>&#8203;(int&nbsp;parameterIndex,
        java.sql.NClob&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to a <code>java.sql.NClob</code> object.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNString(int,java.lang.String)">setNString</a></span>&#8203;(int&nbsp;parameterIndex,
          java.lang.String&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>String</code> object.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNull(int,int)">setNull</a></span>&#8203;(int&nbsp;parameterIndex,
       int&nbsp;sqlType)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to SQL <code>NULL</code>.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNull(int,int,java.lang.String)">setNull</a></span>&#8203;(int&nbsp;parameterIndex,
       int&nbsp;sqlType,
       java.lang.String&nbsp;typeName)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to SQL <code>NULL</code>.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setObject(int,java.lang.Object)">setObject</a></span>&#8203;(int&nbsp;parameterIndex,
         java.lang.Object&nbsp;x)</code></th>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setObject(int,java.lang.Object,int)">setObject</a></span>&#8203;(int&nbsp;parameterIndex,
         java.lang.Object&nbsp;x,
         int&nbsp;targetSqlType)</code></th>
<td class="colLast">
<div class="block">Sets the value of the designated parameter with the given object.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setObject(int,java.lang.Object,int,int)">setObject</a></span>&#8203;(int&nbsp;parameterIndex,
         java.lang.Object&nbsp;x,
         int&nbsp;targetSqlType,
         int&nbsp;scaleOrLength)</code></th>
<td class="colLast">
<div class="block">Sets the value of the designated parameter with the given object.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setObject(int,java.lang.Object,java.sql.SQLType)">setObject</a></span>&#8203;(int&nbsp;parameterIndex,
         java.lang.Object&nbsp;x,
         java.sql.SQLType&nbsp;targetSqlType)</code></th>
<td class="colLast">
<div class="block">Sets the value of the designated parameter with the given object.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setObject(int,java.lang.Object,java.sql.SQLType,int)">setObject</a></span>&#8203;(int&nbsp;parameterIndex,
         java.lang.Object&nbsp;x,
         java.sql.SQLType&nbsp;targetSqlType,
         int&nbsp;scaleOrLength)</code></th>
<td class="colLast">
<div class="block">Sets the value of the designated parameter with the given object.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPoolable(boolean)">setPoolable</a></span>&#8203;(boolean&nbsp;poolable)</code></th>
<td class="colLast">
<div class="block">Requests that a <code>Statement</code> be pooled or not pooled.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setQueryTimeout(int)">setQueryTimeout</a></span>&#8203;(int&nbsp;seconds)</code></th>
<td class="colLast">
<div class="block">Sets the number of seconds the driver will wait for a
 <code>Statement</code> object to execute to the given number of seconds.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRef(int,java.sql.Ref)">setRef</a></span>&#8203;(int&nbsp;parameterIndex,
      java.sql.Ref&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given
  <code>REF(&lt;structured-type&gt;)</code> value.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRowId(int,java.sql.RowId)">setRowId</a></span>&#8203;(int&nbsp;parameterIndex,
        java.sql.RowId&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.RowId</code> object.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setShort(int,short)">setShort</a></span>&#8203;(int&nbsp;parameterIndex,
        short&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given Java <code>short</code> value.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setSQLXML(int,java.sql.SQLXML)">setSQLXML</a></span>&#8203;(int&nbsp;parameterIndex,
         java.sql.SQLXML&nbsp;xmlObject)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.SQLXML</code> object.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setString(int,java.lang.String)">setString</a></span>&#8203;(int&nbsp;parameterIndex,
         java.lang.String&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given Java <code>String</code> value.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setTime(int,java.sql.Time)">setTime</a></span>&#8203;(int&nbsp;parameterIndex,
       java.sql.Time&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.Time</code> value.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setTime(int,java.sql.Time,java.util.Calendar)">setTime</a></span>&#8203;(int&nbsp;parameterIndex,
       java.sql.Time&nbsp;x,
       java.util.Calendar&nbsp;cal)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.Time</code> value,
 using the given <code>Calendar</code> object.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setTimestamp(int,java.sql.Timestamp)">setTimestamp</a></span>&#8203;(int&nbsp;parameterIndex,
            java.sql.Timestamp&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.Timestamp</code> value.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setTimestamp(int,java.sql.Timestamp,java.util.Calendar)">setTimestamp</a></span>&#8203;(int&nbsp;parameterIndex,
            java.sql.Timestamp&nbsp;x,
            java.util.Calendar&nbsp;cal)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.sql.Timestamp</code> value,
 using the given <code>Calendar</code> object.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setUnicodeStream(int,java.io.InputStream,int)">setUnicodeStream</a></span>&#8203;(int&nbsp;parameterIndex,
                java.io.InputStream&nbsp;x,
                int&nbsp;length)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Sun does not include a reason, but presumably
      this is because setCharacterStream is now preferred</div>
</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setURL(int,java.net.URL)">setURL</a></span>&#8203;(int&nbsp;parameterIndex,
      java.net.URL&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Sets the designated parameter to the given <code>java.net.URL</code> value.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">
<div class="block">Retrieves a String representation of this object.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unwrap(java.lang.Class)">unwrap</a></span>&#8203;(java.lang.Class&lt;T&gt;&nbsp;iface)</code></th>
<td class="colLast">
<div class="block">Returns an object that implements the given interface to allow access to
 non-standard methods, or standard methods not exposed by the proxy.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.sql.Statement">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;java.sql.Statement</h3>
<code>closeOnCompletion, enquoteIdentifier, enquoteLiteral, enquoteNCharLiteral, executeLargeUpdate, executeLargeUpdate, executeLargeUpdate, executeLargeUpdate, isCloseOnCompletion, isSimpleIdentifier</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="executeQuery()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeQuery</h4>
<pre class="methodSignature">public&nbsp;java.sql.ResultSet&nbsp;executeQuery()
                                throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Executes the SQL query in this <code>PreparedStatement</code> object
 and returns the <code>ResultSet</code> object generated by the query.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeQuery</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>ResultSet</code> object that contains the data produced by the
         query; never <code>null</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed  <code>PreparedStatement</code> or the SQL
            statement does not return a <code>ResultSet</code> object</dd>
</dl>
</li>
</ul>
<a id="executeUpdate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeUpdate</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;executeUpdate()
                  throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code> object,
 (JDBC4 clarification:)
 which must be an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or
 <code>DELETE</code>; or an SQL statement that returns nothing,
 such as a DDL statement.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeUpdate</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(JDBC4 clarification:) either (1) the row count for SQL Data Manipulation Language (DML) statements
         or (2) 0 for SQL statements that return nothing</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed  <code>PreparedStatement</code>
 or the SQL
            statement returns a <code>ResultSet</code> object</dd>
</dl>
</li>
</ul>
<a id="setNull(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNull</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNull&#8203;(int&nbsp;parameterIndex,
                    int&nbsp;sqlType)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>.

 <P><B>Note:</B> You must specify the parameter's SQL type.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 HSQLDB currently ignores the sqlType argument.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setNull</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>sqlType</code> - the SQL type code defined in <code>java.sql.Types</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if <code>sqlType</code> is
 a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
 <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
 <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
 or  <code>STRUCT</code> data type and the JDBC driver does not support
 this data type</dd>
</dl>
</li>
</ul>
<a id="setBoolean(int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBoolean</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setBoolean&#8203;(int&nbsp;parameterIndex,
                       boolean&nbsp;x)
                throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>boolean</code> value.
 The driver converts this
 (JDBC4 Modified:)
 to an SQL <code>BIT</code> or <code>BOOLEAN</code> value when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 HSQLDB supports BOOLEAN type for boolean values. This method can also
 be used to set the value of a parameter of the SQL type BIT(1), which is
 a bit string consisting of a 0 or 1.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setBoolean</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setByte(int,byte)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setByte</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setByte&#8203;(int&nbsp;parameterIndex,
                    byte&nbsp;x)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>byte</code> value.
 The driver converts this
 to an SQL <code>TINYINT</code> value when it sends it to the database.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setByte</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setShort(int,short)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setShort</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setShort&#8203;(int&nbsp;parameterIndex,
                     short&nbsp;x)
              throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>short</code> value.
 The driver converts this
 to an SQL <code>SMALLINT</code> value when it sends it to the database.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setShort</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setInt(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setInt</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setInt&#8203;(int&nbsp;parameterIndex,
                   int&nbsp;x)
            throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>int</code> value.
 The driver converts this
 to an SQL <code>INTEGER</code> value when it sends it to the database.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setInt</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setLong(int,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLong</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setLong&#8203;(int&nbsp;parameterIndex,
                    long&nbsp;x)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>long</code> value.
 The driver converts this
 to an SQL <code>BIGINT</code> value when it sends it to the database.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setLong</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setFloat(int,float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFloat</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setFloat&#8203;(int&nbsp;parameterIndex,
                     float&nbsp;x)
              throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>float</code> value.
 The driver converts this
 (JDBC4 correction:)
 to an SQL <code>REAL</code> value when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Since 1.7.1, HSQLDB handles Java positive/negative Infinity
 and NaN <code>float</code> values consistent with the Java Language
 Specification; these <em>special</em> values are now correctly stored
 to and retrieved from the database.
 </div>
 <!-- start release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setFloat</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setDouble(int,double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDouble</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setDouble&#8203;(int&nbsp;parameterIndex,
                      double&nbsp;x)
               throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>double</code> value.
 The driver converts this
 to an SQL <code>DOUBLE</code> value when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Since 1.7.1, HSQLDB handles Java positive/negative Infinity
 and NaN <code>double</code> values consistent with the Java Language
 Specification; these <em>special</em> values are now correctly stored
 to and retrieved from the database.
 </div>
 <!-- start release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setDouble</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setBigDecimal(int,java.math.BigDecimal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBigDecimal</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setBigDecimal&#8203;(int&nbsp;parameterIndex,
                          java.math.BigDecimal&nbsp;x)
                   throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.math.BigDecimal</code> value.
 The driver converts this to an SQL <code>NUMERIC</code> value when
 it sends it to the database.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setBigDecimal</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setString(int,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setString</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setString&#8203;(int&nbsp;parameterIndex,
                      java.lang.String&nbsp;x)
               throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given Java <code>String</code> value.
 The driver converts this
 to an SQL <code>VARCHAR</code> or <code>LONGVARCHAR</code> value
 (depending on the argument's
 size relative to the driver's limits on <code>VARCHAR</code> values)
 when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Including 2.0, HSQLDB represents all XXXCHAR values internally as
 java.lang.String objects; there is no appreciable difference between
 CHAR, VARCHAR and LONGVARCHAR.
 </div>
 <!-- start release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setString</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setBytes(int,byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBytes</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setBytes&#8203;(int&nbsp;parameterIndex,
                     byte[]&nbsp;x)
              throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given Java array of bytes.  The driver converts
 this to an SQL <code>VARBINARY</code> or <code>LONGVARBINARY</code>
 (depending on the argument's size relative to the driver's limits on
 <code>VARBINARY</code> values) when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Including 2.0, HSQLDB represents all XXXBINARY values the same way
 internally; there is no appreciable difference between BINARY,
 VARBINARY and LONGVARBINARY as far as JDBC is concerned.
 </div>
 <!-- start release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setBytes</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setDate(int,java.sql.Date)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDate</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setDate&#8203;(int&nbsp;parameterIndex,
                    java.sql.Date&nbsp;x)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 (JDBC4 clarification:)
 Sets the designated parameter to the given <code>java.sql.Date</code> value
 using the default time zone of the virtual machine that is running
 the application.
 The driver converts this
 to an SQL <code>DATE</code> value when it sends it to the database.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone of the
 client application is used as time zone
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setDate</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setTime(int,java.sql.Time)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTime</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setTime&#8203;(int&nbsp;parameterIndex,
                    java.sql.Time&nbsp;x)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code> value.
 The driver converts this
 to an SQL <code>TIME</code> value when it sends it to the database.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone of the
 client application is used as time zone
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setTime</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setTimestamp(int,java.sql.Timestamp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTimestamp</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setTimestamp&#8203;(int&nbsp;parameterIndex,
                         java.sql.Timestamp&nbsp;x)
                  throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Timestamp</code> value.
 The driver
 converts this to an SQL <code>TIMESTAMP</code> value when it sends it to the
 database.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone of the
 client application is used as time zone.<p>

 When this method is used to set a parameter of type TIME or
 TIME WITH TIME ZONE, then the nanosecond value of the Timestamp object
 will be used if the TIME parameter accepts fractional seconds.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setTimestamp</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setAsciiStream(int,java.io.InputStream,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setAsciiStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setAsciiStream&#8203;(int&nbsp;parameterIndex,
                           java.io.InputStream&nbsp;x,
                           int&nbsp;length)
                    throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large ASCII value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code>. Data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from ASCII to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <!-- end generic documentation -->
 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 From HSQLDB 2.0 this method uses the US-ASCII character encoding to convert bytes
 from the stream into the characters of a String.<p>
 This method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.<p>

 For long streams (larger than a few megabytes) with CLOB targets,
 it is more efficient to use a version of setCharacterStream which takes
 the a length parameter.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setAsciiStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the Java input stream that contains the ASCII parameter value</dd>
<dd><code>length</code> - the number of bytes in the stream</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setUnicodeStream(int,java.io.InputStream,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUnicodeStream</h4>
<pre class="methodSignature">@Deprecated
public&nbsp;void&nbsp;setUnicodeStream&#8203;(int&nbsp;parameterIndex,
                             java.io.InputStream&nbsp;x,
                             int&nbsp;length)
                      throws java.sql.SQLException</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Sun does not include a reason, but presumably
      this is because setCharacterStream is now preferred</div>
</div>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which
 will have the specified number of bytes.
 (JDBC4 deleted:)
 [A Unicode character has two bytes, with the first byte being the high
 byte, and the second being the low byte.] <p>

 When a very large Unicode value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from Unicode to the database char format.

 (JDBC4 added:)
 The byte format of the Unicode stream must be a Java UTF-8, as defined in the
 Java Virtual Machine Specification.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 From 1.7.0 to 1.8.0.x, this method complies with behavior as defined by
 the JDBC3 specification (the stream is treated as though it has UTF16
 encoding). <p>

 Starting with 2.0, this method behaves according to the JDBC4
 specification (the stream is treated as though it has UTF-8
 encoding, as defined in the Java Virtual Machine Specification) when
 built under JDK 1.6+; otherwise, it behaves as defined by the JDBC3
 specification.  Regardless, this method is deprecated: please use
 setCharacterStream(...) instead.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setUnicodeStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - a <code>java.io.InputStream</code> object that contains the
        Unicode parameter value
 (JDBC4 deleted:)
       [as two-byte Unicode characters]</dd>
<dd><code>length</code> - the number of bytes in the stream</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support
 this method</dd>
</dl>
</li>
</ul>
<a id="setBinaryStream(int,java.io.InputStream,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBinaryStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setBinaryStream&#8203;(int&nbsp;parameterIndex,
                            java.io.InputStream&nbsp;x,
                            int&nbsp;length)
                     throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large binary value is input to a <code>LONGVARBINARY</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Since 1.7.2, this method works according to the standard.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setBinaryStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the java input stream which contains the binary parameter value</dd>
<dd><code>length</code> - the number of bytes in the stream</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="clearParameters()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearParameters</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;clearParameters()
                     throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Clears the current parameter values immediately.
 <P>In general, parameter values remain in force for repeated use of a
 statement. Setting a parameter value automatically clears its
 previous value.  However, in some cases it is useful to immediately
 release the resources used by the current parameter values; this can
 be done by calling the method <code>clearParameters</code>.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>clearParameters</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
</dl>
</li>
</ul>
<a id="setObject(int,java.lang.Object,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setObject</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setObject&#8203;(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      int&nbsp;targetSqlType,
                      int&nbsp;scaleOrLength)
               throws java.sql.SQLException</pre>
<div class="block"><p>Sets the value of the designated parameter with the given object. The second
 argument must be an object type; for integral values, the
 <code>java.lang</code> equivalent objects should be used.

 If the second argument is an <code>InputStream</code> then the stream must contain
 the number of bytes specified by scaleOrLength.  If the second argument is a
 <code>Reader</code> then the reader must contain the number of characters specified
 by scaleOrLength. If these conditions are not true the driver will generate a
 <code>SQLException</code> when the prepared statement is executed.

 <p>The given Java object will be converted to the given targetSqlType
 before being sent to the database.

 If the object has a custom mapping (is of a class implementing the
 interface <code>SQLData</code>),
 the JDBC driver should call the method <code>SQLData.writeSQL</code> to
 write it to the SQL data stream.
 If, on the other hand, the object is of a class implementing
 <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,  <code>NClob</code>,
  <code>Struct</code>, <code>java.net.URL</code>,
 or <code>Array</code>, the driver should pass it to the database as a
 value of the corresponding SQL type.

 <p>Note that this method may be used to pass database-specific
 abstract data types.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setObject</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the object containing the input parameter value</dd>
<dd><code>targetSqlType</code> - the SQL type (as defined in java.sql.Types) to be
 sent to the database. The scale argument may further qualify this type.</dd>
<dd><code>scaleOrLength</code> - for <code>java.sql.Types.DECIMAL</code>
          or <code>java.sql.Types.NUMERIC types</code>,
          this is the number of digits after the decimal point. For
          Java Object types <code>InputStream</code> and <code>Reader</code>,
          this is the length
          of the data in the stream or reader.  For all other types,
          this value will be ignored.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>PreparedStatement</code> or
            if the Java Object specified by x is an InputStream
            or Reader object and the value of the scale parameter is less
            than zero</dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if <code>targetSqlType</code> is
 a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
 <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
 <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
 or  <code>STRUCT</code> data type and the JDBC driver does not support
 this data type</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Types</code></dd>
</dl>
</li>
</ul>
<a id="setObject(int,java.lang.Object,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setObject</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setObject&#8203;(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      int&nbsp;targetSqlType)
               throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the value of the designated parameter with the given object.
 This method is like the method <code>setObject</code>
 above, except that it assumes a scale of zero.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Since 1.7.2, this method supports conversions listed in the
 conversion table B-5 of the JDBC 3 specification.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setObject</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the object containing the input parameter value</dd>
<dd><code>targetSqlType</code> - the SQL type (as defined in java.sql.Types) to be
                      sent to the database</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if <code>targetSqlType</code> is
 a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
 <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
 <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
 or  <code>STRUCT</code> data type and the JDBC driver does not support
 this data type</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setObject(int,java.lang.Object)"><code>setObject(int,Object)</code></a></dd>
</dl>
</li>
</ul>
<a id="setObject(int,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setObject</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setObject&#8203;(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x)
               throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 <p>Sets the value of the designated parameter using the given object.
 The second parameter must be of type <code>Object</code>; therefore, the
 <code>java.lang</code> equivalent objects should be used for built-in types.

 <p>The JDBC specification specifies a standard mapping from
 Java <code>Object</code> types to SQL types.  The given argument
 will be converted to the corresponding SQL type before being
 sent to the database.

 <p>Note that this method may be used to pass database-
 specific abstract data types, by using a driver-specific Java
 type.

 If the object is of a class implementing the interface <code>SQLData</code>,
 the JDBC driver should call the method <code>SQLData.writeSQL</code>
 to write it to the SQL data stream.
 If, on the other hand, the object is of a class implementing
 <code>Ref</code>, <code>Blob</code>, <code>Clob</code>, (JDBC4 new:) [ <code>NClob</code> ],
  <code>Struct</code>, <code>java.net.URL</code>, (JDBC4 new:) [ <code>RowId</code>, <code>SQLXML</code> ]
 or <code>Array</code>, the driver should pass it to the database as a
 value of the corresponding SQL type.
 <P>
 <b>Note:</b> Not all databases allow for a non-typed Null to be sent to
 the backend. For maximum portability, the <code>setNull</code> or the
 <code>setObject(int parameterIndex, Object x, int sqlType)</code>
 method should be used
 instead of <code>setObject(int parameterIndex, Object x)</code>.
 <p>
 <b>Note:</b> This method throws an exception if there is an ambiguity, for example, if the
 object is of a class implementing more than one of the interfaces named above.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1><p>

 Since 1.7.2, this method supports conversions listed in the conversion
 table B-5 of the JDBC 3 specification.
 </div></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setObject</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the object containing the input parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
  this method is called on a closed <code>PreparedStatement</code>
 or the type of the given object is ambiguous</dd>
</dl>
</li>
</ul>
<a id="execute()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>execute</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;execute()
                throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Executes the SQL statement in this <code>PreparedStatement</code> object,
 which may be any kind of SQL statement.
 Some prepared statements return multiple results; the <code>execute</code>
 method handles these complex statements as well as the simpler
 form of statements handled by the methods <code>executeQuery</code>
 and <code>executeUpdate</code>.
 <P>
 The <code>execute</code> method returns a <code>boolean</code> to
 indicate the form of the first result.  You must call either the method
 <code>getResultSet</code> or <code>getUpdateCount</code>
 to retrieve the result; you must call <code>getMoreResults</code> to
 move to any subsequent result(s).
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 If the statement is a call to a PROCEDURE, it may return multiple
 multiple fetchable results. <p>

 </div></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>execute</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first result is a <code>ResultSet</code>
         object; <code>false</code> if the first result is an update
         count or there is no result</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>PreparedStatement</code>
 or an argument is supplied to this method</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="JDBCStatement.html#execute(java.lang.String)"><code>JDBCStatement.execute(java.lang.String)</code></a>, 
<a href="JDBCStatement.html#getResultSet()"><code>JDBCStatement.getResultSet()</code></a>, 
<a href="JDBCStatement.html#getUpdateCount()"><code>JDBCStatement.getUpdateCount()</code></a>, 
<a href="JDBCStatement.html#getMoreResults()"><code>JDBCStatement.getMoreResults()</code></a></dd>
</dl>
</li>
</ul>
<a id="addBatch()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addBatch</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addBatch()
              throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Adds a set of parameters to this <code>PreparedStatement</code>
 object's batch of commands.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Since 1.7.2, this feature is supported.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>addBatch</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="JDBCStatement.html#addBatch(java.lang.String)"><code>JDBCStatement.addBatch(java.lang.String)</code></a></dd>
</dl>
</li>
</ul>
<a id="setCharacterStream(int,java.io.Reader,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCharacterStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setCharacterStream&#8203;(int&nbsp;parameterIndex,
                               java.io.Reader&nbsp;reader,
                               int&nbsp;length)
                        throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.
 When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.Reader</code> object. The data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from UNICODE to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 From HSQLDB 2.0 this method uses streaming to send data
 when the target is a CLOB.<p>
 HSQLDB represents CHARACTER and related SQL types as UTF16 Unicode
 internally, so this method does not perform any conversion.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setCharacterStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>reader</code> - the <code>java.io.Reader</code> object that contains the
        Unicode data</dd>
<dd><code>length</code> - the number of characters in the stream</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="setRef(int,java.sql.Ref)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRef</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setRef&#8203;(int&nbsp;parameterIndex,
                   java.sql.Ref&nbsp;x)
            throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given
  <code>REF(&lt;structured-type&gt;)</code> value.
 The driver converts this to an SQL <code>REF</code> value when it
 sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Including 2.0 HSQLDB does not support the SQL REF type. Calling this method
 throws an exception.

 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setRef</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - an SQL <code>REF</code> value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="setBlob(int,java.sql.Blob)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBlob</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setBlob&#8203;(int&nbsp;parameterIndex,
                    java.sql.Blob&nbsp;x)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Blob</code> object.
 The driver converts this to an SQL <code>BLOB</code> value when it
 sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 For parameters of type Blob, setBlob works normally.<p>

 In addition since 1.7.2, setBlob is supported for BINARY and VARBINARY
 parameters. In this context, the Blob object is
 hard-limited to those of length less than or equal to Integer.MAX_VALUE.
 In practice, soft limits such as available heap and maximum disk usage
 per file (such as the transaction log) dictate a much smaller maximum
 length. <p>

 For BINARY and VARBINARY parameter types setBlob(i,x) is roughly
 equivalent (null and length handling not shown) to:

 <pre class="JavaCodeExample">
 <b>setBinaryStream</b>(i, x.<b>getBinaryStream</b>(), (<span class="JavaKeyWord">int</span>) x.<b>length</b>());
 </pre></div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setBlob</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - a <code>Blob</code> object that maps an SQL <code>BLOB</code> value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="setClob(int,java.sql.Clob)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setClob</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setClob&#8203;(int&nbsp;parameterIndex,
                    java.sql.Clob&nbsp;x)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Clob</code> object.
 The driver converts this to an SQL <code>CLOB</code> value when it
 sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 For parameters of type Clob, setClob works normally.<p>

 In addition since 1.7.2, setClob is supported for CHARACTER and VARCHAR
 parameters. In this context, the Clob object is
 hard-limited to those of length less than or equal to Integer.MAX_VALUE.
 In practice, soft limits such as available heap and maximum disk usage
 per file (such as the transaction log) dictate a much smaller maximum
 length. <p>

 For CHARACTER and VARCHAR parameter types setClob(i,x) is roughly
 equivalent (null and length handling not shown) to:

 <pre class="JavaCodeExample">
 <b>setCharacterStream</b>(i, x.<b>getCharacterStream</b>(), (<span class="JavaKeyWord">int</span>) x.<b>length</b>());
 </pre></div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setClob</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - a <code>Clob</code> object that maps an SQL <code>CLOB</code> value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="setArray(int,java.sql.Array)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setArray</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setArray&#8203;(int&nbsp;parameterIndex,
                     java.sql.Array&nbsp;x)
              throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Array</code> object.
 The driver converts this to an SQL <code>ARRAY</code> value when it
 sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 From version 2.0, HSQLDB supports the SQL ARRAY type.

 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setArray</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - an <code>Array</code> object that maps an SQL <code>ARRAY</code> value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="getMetaData()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMetaData</h4>
<pre class="methodSignature">public&nbsp;java.sql.ResultSetMetaData&nbsp;getMetaData()
                                       throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves a <code>ResultSetMetaData</code> object that contains
 information about the columns of the <code>ResultSet</code> object
 that will be returned when this <code>PreparedStatement</code> object
 is executed.
 <P>
 Because a <code>PreparedStatement</code> object is pre-compiled, it is
 possible to know about the <code>ResultSet</code> object that it will
 return without having to execute it.  Consequently, it is possible
 to invoke the method <code>getMetaData</code> on a
 <code>PreparedStatement</code> object rather than waiting to execute
 it and then invoking the <code>ResultSet.getMetaData</code> method
 on the <code>ResultSet</code> object that is returned.
 <P>
 <B>NOTE:</B> Using this method may be expensive for some drivers due
 to the lack of underlying DBMS support.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Since 1.7.2, this feature is supported and is <em>inexpensive</em> as
 it is backed by underlying DBMS support.  If the statement
 generates an update count, then null is returned.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getMetaData</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the description of a <code>ResultSet</code> object's columns or
         <code>null</code> if the driver cannot return a
         <code>ResultSetMetaData</code> object</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support
 this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="setDate(int,java.sql.Date,java.util.Calendar)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDate</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setDate&#8203;(int&nbsp;parameterIndex,
                    java.sql.Date&nbsp;x,
                    java.util.Calendar&nbsp;cal)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Date</code> value,
 using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>DATE</code> value,
 which the driver then sends to the database.  With
 a <code>Calendar</code> object, the driver can calculate the date
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the application.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setDate</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dd><code>cal</code> - the <code>Calendar</code> object the driver will use
            to construct the date</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="setTime(int,java.sql.Time,java.util.Calendar)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTime</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setTime&#8203;(int&nbsp;parameterIndex,
                    java.sql.Time&nbsp;x,
                    java.util.Calendar&nbsp;cal)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Time</code> value,
 using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>TIME</code> value,
 which the driver then sends to the database.  With
 a <code>Calendar</code> object, the driver can calculate the time
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the application.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone (including
 Daylight Saving Time) of the Calendar is used as time zone for the
 value.<p>

 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setTime</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dd><code>cal</code> - the <code>Calendar</code> object the driver will use
            to construct the time</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="setTimestamp(int,java.sql.Timestamp,java.util.Calendar)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTimestamp</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setTimestamp&#8203;(int&nbsp;parameterIndex,
                         java.sql.Timestamp&nbsp;x,
                         java.util.Calendar&nbsp;cal)
                  throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.sql.Timestamp</code> value,
 using the given <code>Calendar</code> object.  The driver uses
 the <code>Calendar</code> object to construct an SQL <code>TIMESTAMP</code> value,
 which the driver then sends to the database.  With a
  <code>Calendar</code> object, the driver can calculate the timestamp
 taking into account a custom timezone.  If no
 <code>Calendar</code> object is specified, the driver uses the default
 timezone, which is that of the virtual machine running the application.
 <!-- end generic documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 When a setXXX method is used to set a parameter of type
 TIMESTAMP WITH TIME ZONE or TIME WITH TIME ZONE the time zone (including
 Daylight Saving Time) of the Calendar is used as time zone.<p>
 In this case, if the Calendar argument is null, then the default Calendar
 for the clients JVM is used as the Calendar<p>

 When this method is used to set a parameter of type TIME or
 TIME WITH TIME ZONE, then the nanosecond value of the Timestamp object
 is used if the TIME parameter accepts fractional seconds.<p>

 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setTimestamp</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dd><code>cal</code> - the <code>Calendar</code> object the driver will use
            to construct the timestamp</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="setNull(int,int,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNull</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNull&#8203;(int&nbsp;parameterIndex,
                    int&nbsp;sqlType,
                    java.lang.String&nbsp;typeName)
             throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to SQL <code>NULL</code>.
 This version of the method <code>setNull</code> should
 be used for user-defined types and REF type parameters.  Examples
 of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
 named array types.

 <P><B>Note:</B> To be portable, applications must give the
 SQL type code and the fully-qualified SQL type name when specifying
 a NULL user-defined or REF parameter.  In the case of a user-defined type
 the name is the type name of the parameter itself.  For a REF
 parameter, the name is the type name of the referenced type.  If
 a JDBC driver does not need the type code or type name information,
 it may ignore it.

 Although it is intended for user-defined and Ref parameters,
 this method may be used to set a null parameter of any JDBC type.
 If the parameter does not have a user-defined or REF type, the given
 typeName is ignored.

 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 HSQLDB simply ignores the sqlType and typeName arguments.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setNull</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>sqlType</code> - a value from <code>java.sql.Types</code></dd>
<dd><code>typeName</code> - the fully-qualified name of an SQL user-defined type;
  ignored if the parameter is not a user-defined type or REF</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if <code>sqlType</code> is
 a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
 <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
 <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
 or  <code>STRUCT</code> data type and the JDBC driver does not support
 this data type or if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="executeBatch()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeBatch</h4>
<pre class="methodSignature">public&nbsp;int[]&nbsp;executeBatch()
                   throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Submits a batch of commands to the database for execution and
 if all commands execute successfully, returns an array of update counts.
 The <code>int</code> elements of the array that is returned are ordered
 to correspond to the commands in the batch, which are ordered
 according to the order in which they were added to the batch.
 The elements in the array returned by the method <code>executeBatch</code>
 may be one of the following:
 <OL>
 <LI>A number greater than or equal to zero -- indicates that the
 command was processed successfully and is an update count giving the
 number of rows in the database that were affected by the command's
 execution
 <LI>A value of <code>SUCCESS_NO_INFO</code> -- indicates that the command was
 processed successfully but that the number of rows affected is
 unknown
 <P>
 If one of the commands in a batch update fails to execute properly,
 this method throws a <code>BatchUpdateException</code>, and a JDBC
 driver may or may not continue to process the remaining commands in
 the batch.  However, the driver's behavior must be consistent with a
 particular DBMS, either always continuing to process commands or never
 continuing to process commands.  If the driver continues processing
 after a failure, the array returned by the method
 <code>BatchUpdateException.getUpdateCounts</code>
 will contain as many elements as there are commands in the batch, and
 at least one of the elements will be the following:
 <LI>A value of <code>EXECUTE_FAILED</code> -- indicates that the command failed
 to execute successfully and occurs only if a driver continues to
 process commands after a command fails
 </OL>
 <P>
 A driver is not required to implement this method.
 The possible implementations and return values have been modified in
 the Java 2 SDK, Standard Edition, version 1.3 to
 accommodate the option of continuing to process commands in a batch
 update after a <code>BatchUpdateException</code> object has been thrown.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Starting with HSQLDB 1.7.2, this feature is supported. <p>

 HSQLDB stops execution of commands in a batch when one of the commands
 results in an exception. The size of the returned array equals the
 number of commands that were executed successfully.<p>

 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeBatch</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of update counts containing one element for each
 command in the batch.  The elements of the array are ordered according
 to the order in which commands were added to the batch.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>Statement</code> or the
 driver does not support batch statements. Throws <code>BatchUpdateException</code>
 (a subclass of <code>SQLException</code>) if one of the commands sent to the
 database fails to execute properly or attempts to return a result set.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.3</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#addBatch()"><code>addBatch()</code></a>, 
<code>DatabaseMetaData.supportsBatchUpdates()</code></dd>
</dl>
</li>
</ul>
<a id="setEscapeProcessing(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setEscapeProcessing</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setEscapeProcessing&#8203;(boolean&nbsp;enable)
                         throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets escape processing on or off.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 As per JDBC spec, calling this method has no effect.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setEscapeProcessing</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>enable</code> - <code>true</code> to enable escape processing;
     <code>false</code> to disable it</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs</dd>
</dl>
</li>
</ul>
<a id="addBatch(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addBatch</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addBatch&#8203;(java.lang.String&nbsp;sql)
              throws java.sql.SQLException</pre>
<div class="block">This method should always throw if called for a PreparedStatement or
 CallableStatement.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>addBatch</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sql</code> - ignored</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - always</dd>
</dl>
</li>
</ul>
<a id="executeQuery(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeQuery</h4>
<pre class="methodSignature">public&nbsp;java.sql.ResultSet&nbsp;executeQuery&#8203;(java.lang.String&nbsp;sql)
                                throws java.sql.SQLException</pre>
<div class="block">This method should always throw if called for a PreparedStatement or
 CallableStatement.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeQuery</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sql</code> - ignored</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>nothing</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - always</dd>
</dl>
</li>
</ul>
<a id="execute(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>execute</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;execute&#8203;(java.lang.String&nbsp;sql)
                throws java.sql.SQLException</pre>
<div class="block">This method should always throw if called for a PreparedStatement or
 CallableStatement.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>execute</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sql</code> - ignored</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>nothing</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - always</dd>
</dl>
</li>
</ul>
<a id="executeUpdate(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeUpdate</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;executeUpdate&#8203;(java.lang.String&nbsp;sql)
                  throws java.sql.SQLException</pre>
<div class="block">This method should always throw if called for a PreparedStatement or
 CallableStatement.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeUpdate</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sql</code> - ignored</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>nothing</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - always</dd>
</dl>
</li>
</ul>
<a id="close()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>close</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;close()
           throws java.sql.SQLException</pre>
<div class="block">Does the specialized work required to free this object's resources and
 that of it's parent class. <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>close</code>&nbsp;in interface&nbsp;<code>java.lang.AutoCloseable</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>close</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs</dd>
</dl>
</li>
</ul>
<a id="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Retrieves a String representation of this object.  <p>

 The representation is of the form: <p>

 class-name@hash[sql=[char-sequence], parameters=[p1, ...pi, ...pn]] <p>

 p1, ...pi, ...pn are the String representations of the currently set
 parameter values that will be used with the non-batch execution
 methods. <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a String representation of this object</dd>
</dl>
</li>
</ul>
<a id="setURL(int,java.net.URL)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setURL</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setURL&#8203;(int&nbsp;parameterIndex,
                   java.net.URL&nbsp;x)
            throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the designated parameter to the given <code>java.net.URL</code> value.
 The driver converts this to an SQL <code>DATALINK</code> value
 when it sends it to the database.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Including 2.0, HSQLDB does not support the DATALINK SQL type for which this
 method is intended. Calling this method throws an exception.

 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setURL</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the <code>java.net.URL</code> object to be set</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.4, HSQL 1.7.0</dd>
</dl>
</li>
</ul>
<a id="getParameterMetaData()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getParameterMetaData</h4>
<pre class="methodSignature">public&nbsp;java.sql.ParameterMetaData&nbsp;getParameterMetaData()
                                                throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the number, types and properties of this
 <code>PreparedStatement</code> object's parameters.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Since 1.7.2, this feature is supported.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getParameterMetaData</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>ParameterMetaData</code> object that contains information
         about the number, types and properties for each
  parameter marker of this <code>PreparedStatement</code> object</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.4, HSQL 1.7.0</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>ParameterMetaData</code></dd>
</dl>
</li>
</ul>
<a id="executeUpdate(java.lang.String,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeUpdate</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;executeUpdate&#8203;(java.lang.String&nbsp;sql,
                         int&nbsp;autoGeneratedKeys)
                  throws java.sql.SQLException</pre>
<div class="block">Statement methods that must be overridden in this class and throw
 an exception.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeUpdate</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code></dd>
</dl>
</li>
</ul>
<a id="execute(java.lang.String,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>execute</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;execute&#8203;(java.lang.String&nbsp;sql,
                       int&nbsp;autoGeneratedKeys)
                throws java.sql.SQLException</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>execute</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code></dd>
</dl>
</li>
</ul>
<a id="executeUpdate(java.lang.String,int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeUpdate</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;executeUpdate&#8203;(java.lang.String&nbsp;sql,
                         int[]&nbsp;columnIndexes)
                  throws java.sql.SQLException</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeUpdate</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code></dd>
</dl>
</li>
</ul>
<a id="execute(java.lang.String,int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>execute</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;execute&#8203;(java.lang.String&nbsp;sql,
                       int[]&nbsp;columnIndexes)
                throws java.sql.SQLException</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>execute</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code></dd>
</dl>
</li>
</ul>
<a id="executeUpdate(java.lang.String,java.lang.String[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeUpdate</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;executeUpdate&#8203;(java.lang.String&nbsp;sql,
                         java.lang.String[]&nbsp;columnNames)
                  throws java.sql.SQLException</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeUpdate</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code></dd>
</dl>
</li>
</ul>
<a id="execute(java.lang.String,java.lang.String[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>execute</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;execute&#8203;(java.lang.String&nbsp;sql,
                       java.lang.String[]&nbsp;columnNames)
                throws java.sql.SQLException</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>execute</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code></dd>
</dl>
</li>
</ul>
<a id="getMoreResults(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMoreResults</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getMoreResults&#8203;(int&nbsp;current)
                       throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Moves to this <code>Statement</code> object's next result, deals with
 any current <code>ResultSet</code> object(s) according  to the instructions
 specified by the given flag, and returns
 <code>true</code> if the next result is a <code>ResultSet</code> object.

 <P>There are no more results when the following is true:
 <PRE><code>
     // stmt is a Statement object
     ((stmt.getMoreResults(current) == false) &amp;&amp; (stmt.getUpdateCount() == -1))
 </code></PRE>
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 HSQLDB supports this feature. <p>

 This is used with CallableStatement objects that return multiple
 ResultSet objects.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getMoreResults</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>current</code> - one of the following <code>Statement</code>
        constants indicating what should happen to current
        <code>ResultSet</code> objects obtained using the method
        <code>getResultSet</code>:
        <code>Statement.CLOSE_CURRENT_RESULT</code>,
        <code>Statement.KEEP_CURRENT_RESULT</code>, or
        <code>Statement.CLOSE_ALL_RESULTS</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the next result is a <code>ResultSet</code>
         object; <code>false</code> if it is an update count or there are no
         more results</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>Statement</code> or the argument
             supplied is not one of the following:
        <code>Statement.CLOSE_CURRENT_RESULT</code>,
        <code>Statement.KEEP_CURRENT_RESULT</code>, or
        <code>Statement.CLOSE_ALL_RESULTS</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.4, HSQLDB 1.7</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#execute()"><code>execute()</code></a></dd>
</dl>
</li>
</ul>
<a id="getGeneratedKeys()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGeneratedKeys</h4>
<pre class="methodSignature">public&nbsp;java.sql.ResultSet&nbsp;getGeneratedKeys()
                                    throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves any auto-generated keys created as a result of executing this
 <code>Statement</code> object. If this <code>Statement</code> object did
 not generate any keys, an empty <code>ResultSet</code>
 object is returned.
 <p>(JDBC4 clarification:)
 <p><B>Note:</B>If the columns which represent the auto-generated keys were not specified,
 the JDBC driver implementation will determine the columns which best represent the auto-generated keys.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Starting with version 2.0, HSQLDB supports this feature with single-row and
 multi-row insert, update and merge statements. <p>

 This method returns a result set only if
 the executeUpdate methods that was used is one of the three methods that
 have the extra parameter indicating return of generated keys<p>

 If the executeUpdate method did not specify the columns which represent
 the auto-generated keys the IDENTITY column or GENERATED column(s) of the
 table are returned.<p>

 The executeUpdate methods with column indexes or column names return the
 post-insert or post-update values of the specified columns, whether the
 columns are generated or not. This allows values that have been modified
 by execution of triggers to be returned.<p>

 If column names or indexes provided by the user in the executeUpdate()
 method calls do not correspond to table columns (incorrect names or
 indexes larger than the column count), an empty result is returned.

 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getGeneratedKeys</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>ResultSet</code> object containing the auto-generated key(s)
         generated by the execution of this <code>Statement</code> object</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.4, HSQLDB 1.7</dd>
</dl>
</li>
</ul>
<a id="getResultSetHoldability()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getResultSetHoldability</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getResultSetHoldability()
                            throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the result set holdability for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getResultSetHoldability</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>either <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or
         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.4, HSQLDB 1.7</dd>
</dl>
</li>
</ul>
<a id="isClosed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isClosed</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isClosed()</pre>
<div class="block">Retrieves whether this <code>Statement</code> object has been closed. A <code>Statement</code> is closed if the
 method close has been called on it, or if it is automatically closed.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>isClosed</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if this <code>Statement</code> object is closed; false if it is still open</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setRowId(int,java.sql.RowId)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRowId</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setRowId&#8203;(int&nbsp;parameterIndex,
                     java.sql.RowId&nbsp;x)
              throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to the given <code>java.sql.RowId</code> object. The
 driver converts this to a SQL <code>ROWID</code> value when it sends it
 to the database</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setRowId</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setNString(int,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNString</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNString&#8203;(int&nbsp;parameterIndex,
                       java.lang.String&nbsp;value)
                throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to the given <code>String</code> object.
 The driver converts this to a SQL <code>NCHAR</code> or
 <code>NVARCHAR</code> or <code>LONGNVARCHAR</code> value
 (depending on the argument's
 size relative to the driver's limits on <code>NVARCHAR</code> values)
 when it sends it to the database.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setNString</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - of the first parameter is 1, the second is 2, ...</dd>
<dd><code>value</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if the driver does not support national
         character sets;  if the driver can detect that a data conversion
  error could occur ; if a database access error occurs; or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setNCharacterStream(int,java.io.Reader,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNCharacterStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNCharacterStream&#8203;(int&nbsp;parameterIndex,
                                java.io.Reader&nbsp;value,
                                long&nbsp;length)
                         throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to a <code>Reader</code> object. The
 <code>Reader</code> reads the data till end-of-file is reached. The
 driver does the necessary conversion from Java character format to
 the national character set in the database.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setNCharacterStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - of the first parameter is 1, the second is 2, ...</dd>
<dd><code>value</code> - the parameter value</dd>
<dd><code>length</code> - the number of characters in the parameter data.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if the driver does not support national
         character sets;  if the driver can detect that a data conversion
  error could occur ; if a database access error occurs; or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setNClob(int,java.sql.NClob)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNClob</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNClob&#8203;(int&nbsp;parameterIndex,
                     java.sql.NClob&nbsp;value)
              throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to a <code>java.sql.NClob</code> object. The driver converts this to a
 SQL <code>NCLOB</code> value when it sends it to the database.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setNClob</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - of the first parameter is 1, the second is 2, ...</dd>
<dd><code>value</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if the driver does not support national
         character sets;  if the driver can detect that a data conversion
  error could occur ; if a database access error occurs; or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setClob(int,java.io.Reader,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setClob</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setClob&#8203;(int&nbsp;parameterIndex,
                    java.io.Reader&nbsp;reader,
                    long&nbsp;length)
             throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to a <code>Reader</code> object.  The reader must contain  the number
 of characters specified by length otherwise a <code>SQLException</code> will be
 generated when the <code>PreparedStatement</code> is executed.
 This method differs from the <code>setCharacterStream (int, Reader, int)</code> method
 because it informs the driver that the parameter value should be sent to
 the server as a <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used, the
 driver may have to do extra work to determine whether the parameter
 data should be send to the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setClob</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - index of the first parameter is 1, the second is 2, ...</dd>
<dd><code>reader</code> - An object that contains the data to set the parameter value to.</dd>
<dd><code>length</code> - the number of characters in the parameter data.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs, this method is called on
 a closed <code>PreparedStatement</code>, if parameterIndex does not correspond to a parameter
 marker in the SQL statement, or if the length specified is less than zero.</dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setBlob(int,java.io.InputStream,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBlob</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setBlob&#8203;(int&nbsp;parameterIndex,
                    java.io.InputStream&nbsp;inputStream,
                    long&nbsp;length)
             throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to a <code>InputStream</code> object.  The input stream must contain  the number
 of characters specified by length otherwise a <code>SQLException</code> will be
 generated when the <code>PreparedStatement</code> is executed.
 This method differs from the <code>setBinaryStream (int, InputStream, int)</code>
 method because it informs the driver that the parameter value should be
 sent to the server as a <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used,
 the driver may have to do extra work to determine whether the parameter
 data should be send to the server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>
 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 In HSQLDB 2.0, this method uses streaming to send the data when the
 stream is assigned to a BLOB target. For other binary targets the
 stream is read on the client side and a byte array is sent.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setBlob</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - index of the first parameter is 1,
 the second is 2, ...</dd>
<dd><code>inputStream</code> - An object that contains the data to set the parameter
 value to.</dd>
<dd><code>length</code> - the number of bytes in the parameter data.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>PreparedStatement</code>,
 if parameterIndex does not correspond
 to a parameter marker in the SQL statement,  if the length specified
 is less than zero or if the number of bytes in the input stream does not match
 the specified length.</dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setNClob(int,java.io.Reader,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNClob</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNClob&#8203;(int&nbsp;parameterIndex,
                     java.io.Reader&nbsp;reader,
                     long&nbsp;length)
              throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to a <code>Reader</code> object.  The reader must contain  the number
 of characters specified by length otherwise a <code>SQLException</code> will be
 generated when the <code>PreparedStatement</code> is executed.
 This method differs from the <code>setCharacterStream (int, Reader, int)</code> method
 because it informs the driver that the parameter value should be sent to
 the server as a <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used, the
 driver may have to do extra work to determine whether the parameter
 data should be send to the server as a <code>LONGNVARCHAR</code> or a <code>NCLOB</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setNClob</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - index of the first parameter is 1, the second is 2, ...</dd>
<dd><code>reader</code> - An object that contains the data to set the parameter value to.</dd>
<dd><code>length</code> - the number of characters in the parameter data.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if the length specified is less than zero;
 if the driver does not support national character sets;
 if the driver can detect that a data conversion
  error could occur;  if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setSQLXML(int,java.sql.SQLXML)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSQLXML</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setSQLXML&#8203;(int&nbsp;parameterIndex,
                      java.sql.SQLXML&nbsp;xmlObject)
               throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to the given <code>java.sql.SQLXML</code> object.
 The driver converts this to an
 SQL <code>XML</code> value when it sends it to the database.
 <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setSQLXML</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - index of the first parameter is 1, the second is 2, ...</dd>
<dd><code>xmlObject</code> - a <code>SQLXML</code> object that maps an SQL <code>XML</code> value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
  this method is called on a closed <code>PreparedStatement</code>
 or the <code>java.xml.transform.Result</code>,
  <code>Writer</code> or <code>OutputStream</code> has not been closed for
 the <code>SQLXML</code> object</dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setAsciiStream(int,java.io.InputStream,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setAsciiStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setAsciiStream&#8203;(int&nbsp;parameterIndex,
                           java.io.InputStream&nbsp;x,
                           long&nbsp;length)
                    throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large ASCII value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code>. Data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from ASCII to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 From HSQLDB 2.0 this method uses the US-ASCII character encoding to convert bytes
 from the stream into the characters of a String.<p>
 This method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.<p>

 For long streams (larger than a few megabytes) with CLOB targets,
 it is more efficient to use a version of setCharacterStream which takes
 the a length parameter.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setAsciiStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the Java input stream that contains the ASCII parameter value</dd>
<dd><code>length</code> - the number of bytes in the stream</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setBinaryStream(int,java.io.InputStream,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBinaryStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setBinaryStream&#8203;(int&nbsp;parameterIndex,
                            java.io.InputStream&nbsp;x,
                            long&nbsp;length)
                     throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to the given input stream, which will have
 the specified number of bytes.
 When a very large binary value is input to a <code>LONGVARBINARY</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 This method uses streaming to send the data when the
 stream is assigned to a BLOB target. For other binary targets the
 stream is read on the client side and a byte array is sent.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setBinaryStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the java input stream which contains the binary parameter value</dd>
<dd><code>length</code> - the number of bytes in the stream</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setCharacterStream(int,java.io.Reader,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCharacterStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setCharacterStream&#8203;(int&nbsp;parameterIndex,
                               java.io.Reader&nbsp;reader,
                               long&nbsp;length)
                        throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to the given <code>Reader</code>
 object, which is the given number of characters long.
 When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.Reader</code> object. The data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from UNICODE to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 This method uses streaming to send data
 when the target is a CLOB.<p>
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setCharacterStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>reader</code> - the <code>java.io.Reader</code> object that contains the
        Unicode data</dd>
<dd><code>length</code> - the number of characters in the stream</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="setAsciiStream(int,java.io.InputStream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setAsciiStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setAsciiStream&#8203;(int&nbsp;parameterIndex,
                           java.io.InputStream&nbsp;x)
                    throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to the given input stream.
 When a very large ASCII value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code>. Data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from ASCII to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setAsciiStream</code> which takes a length parameter.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 In HSQLDB 2.0, this method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.

 For long streams (larger than a few megabytes), it is more efficient to
 use a version of setCharacterStream which takes the a length parameter.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setAsciiStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the Java input stream that contains the ASCII parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6</dd>
</dl>
</li>
</ul>
<a id="setBinaryStream(int,java.io.InputStream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBinaryStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setBinaryStream&#8203;(int&nbsp;parameterIndex,
                            java.io.InputStream&nbsp;x)
                     throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to the given input stream.
 When a very large binary value is input to a <code>LONGVARBINARY</code>
 parameter, it may be more practical to send it via a
 <code>java.io.InputStream</code> object. The data will be read from the
 stream as needed until end-of-file is reached.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setBinaryStream</code> which takes a length parameter.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 This method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.<p>

 For long streams (larger than a few megabytes) with CLOB targets,
 it is more efficient to use a version of setCharacterStream which takes
 the a length parameter.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setBinaryStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the java input stream which contains the binary parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6</dd>
</dl>
</li>
</ul>
<a id="setCharacterStream(int,java.io.Reader)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCharacterStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setCharacterStream&#8203;(int&nbsp;parameterIndex,
                               java.io.Reader&nbsp;reader)
                        throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to the given <code>Reader</code>
 object.
 When a very large UNICODE value is input to a <code>LONGVARCHAR</code>
 parameter, it may be more practical to send it via a
 <code>java.io.Reader</code> object. The data will be read from the stream
 as needed until end-of-file is reached.  The JDBC driver will
 do any necessary conversion from UNICODE to the database char format.

 <P><B>Note:</B> This stream object can either be a standard
 Java stream object or your own subclass that implements the
 standard interface.
 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setCharacterStream</code> which takes a length parameter.

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 In HSQLDB 2.0, this method does not use streaming to send the data,
 whether the target is a CLOB or other binary object.

 For long streams (larger than a few megabytes), it is more efficient to
 use a version of setCharacterStream which takes the a length parameter.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setCharacterStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>reader</code> - the <code>java.io.Reader</code> object that contains the
        Unicode data</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6</dd>
</dl>
</li>
</ul>
<a id="setNCharacterStream(int,java.io.Reader)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNCharacterStream</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNCharacterStream&#8203;(int&nbsp;parameterIndex,
                                java.io.Reader&nbsp;value)
                         throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to a <code>Reader</code> object. The
   <code>Reader</code> reads the data till end-of-file is reached. The
   driver does the necessary conversion from Java character format to
   the national character set in the database.

   <P><B>Note:</B> This stream object can either be a standard
   Java stream object or your own subclass that implements the
   standard interface.
   <P><B>Note:</B> Consult your JDBC driver documentation to determine if
   it might be more efficient to use a version of
   <code>setNCharacterStream</code> which takes a length parameter.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setNCharacterStream</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - of the first parameter is 1, the second is 2, ...</dd>
<dd><code>value</code> - the parameter value</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a parameter
   marker in the SQL statement; if the driver does not support national
           character sets;  if the driver can detect that a data conversion
    error could occur; if a database access error occurs; or
   this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6</dd>
</dl>
</li>
</ul>
<a id="setClob(int,java.io.Reader)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setClob</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setClob&#8203;(int&nbsp;parameterIndex,
                    java.io.Reader&nbsp;reader)
             throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to a <code>Reader</code> object.
 This method differs from the <code>setCharacterStream (int, Reader)</code> method
 because it informs the driver that the parameter value should be sent to
 the server as a <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used, the
 driver may have to do extra work to determine whether the parameter
 data should be sent to the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code>

 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setClob</code> which takes a length parameter.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setClob</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - index of the first parameter is 1, the second is 2, ...</dd>
<dd><code>reader</code> - An object that contains the data to set the parameter value to.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs; this method is called on
 a closed <code>PreparedStatement</code>or if parameterIndex does not correspond to a parameter
 marker in the SQL statement</dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6</dd>
</dl>
</li>
</ul>
<a id="setBlob(int,java.io.InputStream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setBlob</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setBlob&#8203;(int&nbsp;parameterIndex,
                    java.io.InputStream&nbsp;inputStream)
             throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to a <code>InputStream</code> object.
 This method differs from the <code>setBinaryStream (int, InputStream)</code>
 method because it informs the driver that the parameter value should be
 sent to the server as a <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used,
 the driver may have to do extra work to determine whether the parameter
 data should be sent to the server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>

 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setBlob</code> which takes a length parameter.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setBlob</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - index of the first parameter is 1,
 the second is 2, ...</dd>
<dd><code>inputStream</code> - An object that contains the data to set the parameter
 value to.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement; if a database access error occurs;
 this method is called on a closed <code>PreparedStatement</code> or
 if parameterIndex does not correspond
 to a parameter marker in the SQL statement,</dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6</dd>
</dl>
</li>
</ul>
<a id="setNClob(int,java.io.Reader)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNClob</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNClob&#8203;(int&nbsp;parameterIndex,
                     java.io.Reader&nbsp;reader)
              throws java.sql.SQLException</pre>
<div class="block">Sets the designated parameter to a <code>Reader</code> object.
 This method differs from the <code>setCharacterStream (int, Reader)</code> method
 because it informs the driver that the parameter value should be sent to
 the server as a <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used, the
 driver may have to do extra work to determine whether the parameter
 data should be sent to the server as a <code>LONGNVARCHAR</code> or a <code>NCLOB</code>
 <P><B>Note:</B> Consult your JDBC driver documentation to determine if
 it might be more efficient to use a version of
 <code>setNClob</code> which takes a length parameter.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setNClob</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - index of the first parameter is 1, the second is 2, ...</dd>
<dd><code>reader</code> - An object that contains the data to set the parameter value to.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a parameter
 marker in the SQL statement;
 if the driver does not support national character sets;
 if the driver can detect that a data conversion
  error could occur;  if a database access error occurs or
 this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6</dd>
</dl>
</li>
</ul>
<a id="getMaxFieldSize()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxFieldSize</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getMaxFieldSize()
                    throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the maximum number of bytes that can be
 returned for character and binary column values in a <code>ResultSet</code>
 object produced by this <code>Statement</code> object.
 This limit applies only to  <code>BINARY</code>, <code>VARBINARY</code>,
 <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>,
 (JDBC4 new:) <code>NCHAR</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>
 and <code>LONGVARCHAR</code> columns.  If the limit is exceeded, the
 excess data is silently discarded.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 HSQLDB always returns zero, meaning there is no limit.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getMaxFieldSize</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current column size limit for columns storing character and
         binary values; zero means there is no limit</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setMaxFieldSize(int)"><code>setMaxFieldSize(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="setMaxFieldSize(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxFieldSize</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setMaxFieldSize&#8203;(int&nbsp;max)
                     throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 (JDBC4 clarification:) Sets the limit for the maximum number of bytes in a <code>ResultSet</code>
 Sets the limit for the maximum number of bytes that can be returned for
 character and binary column values in a <code>ResultSet</code>
 object produced by this <code>Statement</code> object.

 This limit applies
 only to <code>BINARY</code>, <code>VARBINARY</code>,
 <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>,
 (JDBC4 new:) <code>NCHAR</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code> and
 <code>LONGVARCHAR</code> fields.  If the limit is exceeded, the excess data
 is silently discarded. For maximum portability, use values
 greater than 256.
 <!-- emd generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 To present, calls to this method are simply ignored; HSQLDB always
 stores the full number of bytes when dealing with any of the field types
 mentioned above. These types all have an absolute maximum element upper
 bound determined by the Java array index limit
 java.lang.Integer.MAX_VALUE.  For XXXBINARY types, this translates to
 Integer.MAX_VALUE bytes.  For XXXCHAR types, this translates to
 2 * Integer.MAX_VALUE bytes (2 bytes / character). <p>

 In practice, field sizes are limited to values much smaller than the
 absolute maximum element upper bound, in particular due to limits imposed
 on the maximum available Java heap memory.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setMaxFieldSize</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>max</code> - the new column size limit in bytes; zero means there is no limit</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>Statement</code>
            or the condition <code>max &gt;= 0</code> is not satisfied</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getMaxFieldSize()"><code>getMaxFieldSize()</code></a></dd>
</dl>
</li>
</ul>
<a id="getMaxRows()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaxRows</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getMaxRows()
               throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the maximum number of rows that a
 <code>ResultSet</code> object produced by this
 <code>Statement</code> object can contain.  If this limit is exceeded,
 the excess rows are silently dropped.
 <!-- start generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getMaxRows</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current maximum number of rows for a <code>ResultSet</code>
         object produced by this <code>Statement</code> object;
         zero means there is no limit</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setMaxRows(int)"><code>setMaxRows(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="setMaxRows(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxRows</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setMaxRows&#8203;(int&nbsp;max)
                throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 (JDBC4 clarification:)
 Sets the limit for the maximum number of rows that any
 <code>ResultSet</code> object  generated by this <code>Statement</code>
 object can contain to the given number.
 If the limit is exceeded, the excess
 rows are silently dropped.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setMaxRows</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>max</code> - the new max rows limit; zero means there is no limit</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>Statement</code>
            or the condition <code>max &gt;= 0</code> is not satisfied</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getMaxRows()"><code>getMaxRows()</code></a></dd>
</dl>
</li>
</ul>
<a id="getQueryTimeout()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getQueryTimeout</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getQueryTimeout()
                    throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the number of seconds the driver will
 wait for a <code>Statement</code> object to execute.
 If the limit is exceeded, a
 <code>SQLException</code> is thrown.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 To present, HSQLDB always returns zero, meaning there
 is no limit.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getQueryTimeout</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current query timeout limit in seconds; zero means there is
         no limit</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setQueryTimeout(int)"><code>setQueryTimeout(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="setQueryTimeout(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setQueryTimeout</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setQueryTimeout&#8203;(int&nbsp;seconds)
                     throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the number of seconds the driver will wait for a
 <code>Statement</code> object to execute to the given number of seconds.
 If the limit is exceeded, an <code>SQLException</code> is thrown. A JDBC
 (JDBC4 clarification:)
 driver must apply this limit to the <code>execute</code>,
 <code>executeQuery</code> and <code>executeUpdate</code> methods. JDBC driver
 implementations may also apply this limit to <code>ResultSet</code> methods
 (consult your driver vendor documentation for details).
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 The maximum number of seconds to wait is 32767.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setQueryTimeout</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>seconds</code> - the new query timeout limit in seconds; zero means
        there is no limit</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>Statement</code>
            or the condition <code>seconds &gt;= 0</code> is not satisfied</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getQueryTimeout()"><code>getQueryTimeout()</code></a></dd>
</dl>
</li>
</ul>
<a id="cancel()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cancel</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;cancel()
            throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Cancels this <code>Statement</code> object if both the DBMS and
 driver support aborting an SQL statement.
 This method can be used by one thread to cancel a statement that
 is being executed by another thread.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 HSQLDB version 2.3.4 and later supports aborting an SQL query
 or data update statement.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>cancel</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support
 this method</dd>
</dl>
</li>
</ul>
<a id="getWarnings()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWarnings</h4>
<pre class="methodSignature">public&nbsp;java.sql.SQLWarning&nbsp;getWarnings()
                                throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the first warning reported by calls on this <code>Statement</code> object.
 Subsequent <code>Statement</code> object warnings will be chained to this
 <code>SQLWarning</code> object.

 <p>The warning chain is automatically cleared each time
 a statement is (re)executed. This method may not be called on a closed
 <code>Statement</code> object; doing so will cause an <code>SQLException</code>
 to be thrown.

 <P><B>Note:</B> If you are processing a <code>ResultSet</code> object, any
 warnings associated with reads on that <code>ResultSet</code> object
 will be chained on it rather than on the <code>Statement</code>
 object that produced it.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 From 1.9 HSQLDB, produces Statement warnings.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getWarnings</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the first <code>SQLWarning</code> object or <code>null</code>
         if there are no warnings</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
</dl>
</li>
</ul>
<a id="clearWarnings()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearWarnings</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;clearWarnings()
                   throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Clears all the warnings reported on this <code>Statement</code>
 object. After a call to this method,
 the method <code>getWarnings</code> will return
 <code>null</code> until a new warning is reported for this
 <code>Statement</code> object.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Supported in HSQLDB 1.9.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>clearWarnings</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
</dl>
</li>
</ul>
<a id="setCursorName(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCursorName</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setCursorName&#8203;(java.lang.String&nbsp;name)
                   throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Sets the SQL cursor name to the given <code>String</code>, which
 will be used by subsequent <code>Statement</code> object
 <code>execute</code> methods. This name can then be
 used in SQL positioned update or delete statements to identify the
 current row in the <code>ResultSet</code> object generated by this
 statement.  If the database does not support positioned update/delete,
 this method is a noop.  To insure that a cursor has the proper isolation
 level to support updates, the cursor's <code>SELECT</code> statement
 should have the form <code>SELECT FOR UPDATE</code>.  If
 <code>FOR UPDATE</code> is not present, positioned updates may fail.

 <P><B>Note:</B> By definition, the execution of positioned updates and
 deletes must be done by a different <code>Statement</code> object than
 the one that generated the <code>ResultSet</code> object being used for
 positioning. Also, cursor names must be unique within a connection.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Including 2.0, HSQLDB does not support named cursors;
 calls to this method are ignored.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setCursorName</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>name</code> - the new cursor name, which must be unique within
             a connection</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support this method</dd>
</dl>
</li>
</ul>
<a id="getResultSet()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getResultSet</h4>
<pre class="methodSignature">public&nbsp;java.sql.ResultSet&nbsp;getResultSet()
                                throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
  Retrieves the current result as a <code>ResultSet</code> object.
  This method should be called only once per result.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Without an interceding call to executeXXX, each invocation of this
 method will produce a new, initialized ResultSet instance referring to
 the current result, if any.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getResultSet</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current result as a <code>ResultSet</code> object or
 <code>null</code> if the result is an update count or there are no more results</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#execute()"><code>execute()</code></a></dd>
</dl>
</li>
</ul>
<a id="getUpdateCount()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUpdateCount</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getUpdateCount()
                   throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
  Retrieves the current result as an update count;
  if the result is a <code>ResultSet</code> object or there are no more results, -1
  is returned. This method should be called only once per result.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getUpdateCount</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current result as an update count; -1 if the current result is a
 <code>ResultSet</code> object or there are no more results</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#execute()"><code>execute()</code></a></dd>
</dl>
</li>
</ul>
<a id="getMoreResults()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMoreResults</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;getMoreResults()
                       throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Moves to this <code>Statement</code> object's next result, returns
 <code>true</code> if it is a <code>ResultSet</code> object, and
 implicitly closes any current <code>ResultSet</code>
 object(s) obtained with the method <code>getResultSet</code>.

 <P>There are no more results when the following is true:
 <PRE><code>
     // stmt is a Statement object
     ((stmt.getMoreResults() == false) &amp;&amp; (stmt.getUpdateCount() == -1))
 </code></PRE>
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getMoreResults</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the next result is a <code>ResultSet</code>
         object; <code>false</code> if it is an update count or there are
         no more results</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#execute()"><code>execute()</code></a></dd>
</dl>
</li>
</ul>
<a id="setFetchDirection(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFetchDirection</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setFetchDirection&#8203;(int&nbsp;direction)
                       throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Gives the driver a hint as to the direction in which
 rows will be processed in <code>ResultSet</code>
 objects created using this <code>Statement</code> object.  The
 default value is <code>ResultSet.FETCH_FORWARD</code>.
 <P>
 Note that this method sets the default fetch direction for
 result sets generated by this <code>Statement</code> object.
 Each result set has its own methods for getting and setting
 its own fetch direction.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Up to 1.8.0.x, HSQLDB supports only <code>FETCH_FORWARD</code>;
 Setting any other value would throw an <code>SQLException</code>
 stating that the operation is not supported. <p>

 Starting with 2.0, HSQLDB accepts any valid value.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setFetchDirection</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>direction</code> - the initial direction for processing rows</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>Statement</code>
 or the given direction
 is not one of <code>ResultSet.FETCH_FORWARD</code>,
 <code>ResultSet.FETCH_REVERSE</code>, or <code>ResultSet.FETCH_UNKNOWN</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getFetchDirection()"><code>getFetchDirection()</code></a></dd>
</dl>
</li>
</ul>
<a id="getFetchDirection()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFetchDirection</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getFetchDirection()
                      throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the direction for fetching rows from
 database tables that is the default for result sets
 generated from this <code>Statement</code> object.
 If this <code>Statement</code> object has not set
 a fetch direction by calling the method <code>setFetchDirection</code>,
 the return value is implementation-specific.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Up to 1.8.0.x, HSQLDB always returned FETCH_FORWARD.

 Starting with 2.0, HSQLDB returns FETCH_FORWARD by default, or
 whatever value has been explicitly assigned by invoking
 <code>setFetchDirection</code>.
 .
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getFetchDirection</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the default fetch direction for result sets generated
          from this <code>Statement</code> object</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setFetchDirection(int)"><code>setFetchDirection(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="setFetchSize(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFetchSize</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setFetchSize&#8203;(int&nbsp;rows)
                  throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 (JDBC4 clarification:)
 Gives the JDBC driver a hint as to the number of rows that should
 be fetched from the database when more rows are needed for
 <code>ResultSet</code> objects generated by this <code>Statement</code>.
 If the value specified is zero, then the hint is ignored.
 The default value is zero.
 <!-- start generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 HSQLDB uses the specified value as a hint, but may process more or fewer
 rows than specified.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setFetchSize</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rows</code> - the number of rows to fetch</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>Statement</code> or the
        (JDBC4 modified:)
        condition  <code>&lt;code&gt;rows &gt;= 0&lt;/code&gt;</code> is not satisfied.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getFetchSize()"><code>getFetchSize()</code></a></dd>
</dl>
</li>
</ul>
<a id="getFetchSize()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFetchSize</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getFetchSize()
                 throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the number of result set rows that is the default
 fetch size for <code>ResultSet</code> objects
 generated from this <code>Statement</code> object.
 If this <code>Statement</code> object has not set
 a fetch size by calling the method <code>setFetchSize</code>,
 the return value is implementation-specific.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <b>HSQLDB-Specific Information</b> <p>

 HSQLDB returns 0 by default, or the fetch size specified by setFetchSize
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getFetchSize</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the default fetch size for result sets generated
          from this <code>Statement</code> object</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setFetchSize(int)"><code>setFetchSize(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="getResultSetConcurrency()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getResultSetConcurrency</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getResultSetConcurrency()
                            throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the result set concurrency for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 HSQLDB supports <code>CONCUR_READ_ONLY</code> and
 <code>CONCUR_READ_UPDATEBLE</code> concurrency.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getResultSetConcurrency</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>either <code>ResultSet.CONCUR_READ_ONLY</code> or
 <code>ResultSet.CONCUR_UPDATABLE</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="getResultSetType()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getResultSetType</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getResultSetType()
                     throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the result set type for <code>ResultSet</code> objects
 generated by this <code>Statement</code> object.
 <!-- end generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 HSQLDB 1.7.0 and later versions support <code>TYPE_FORWARD_ONLY</code>
 and <code>TYPE_SCROLL_INSENSITIVE</code>.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getResultSetType</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
 <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
 <code>ResultSet.TYPE_SCROLL_SENSITIVE</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="clearBatch()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearBatch</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;clearBatch()
                throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Empties this <code>Statement</code> object's current list of
 SQL commands.
 <P>
 (JDBC4 clarification:) <p>
 <B>NOTE:</B>  Support of an ability to batch updates is optional.
 <!-- start generic documentation -->

 <!-- start release-specific documentation -->
 <div class="ReleaseSpecificDocumentation">
 <h1>HSQLDB-Specific Information:</h1> <p>

 Starting with HSQLDB 1.7.2, this feature is supported.
 </div>
 <!-- end release-specific documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>clearBatch</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
  this method is called on a closed <code>Statement</code> or the
 driver does not support batch updates</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#addBatch()"><code>addBatch()</code></a></dd>
</dl>
</li>
</ul>
<a id="getConnection()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getConnection</h4>
<pre class="methodSignature">public&nbsp;java.sql.Connection&nbsp;getConnection()
                                  throws java.sql.SQLException</pre>
<div class="block"><!-- start generic documentation -->
 Retrieves the <code>Connection</code> object
 that produced this <code>Statement</code> object.
 <!-- end generic documentation --></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getConnection</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the connection that produced this statement</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.2</dd>
</dl>
</li>
</ul>
<a id="setPoolable(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPoolable</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setPoolable&#8203;(boolean&nbsp;poolable)
                 throws java.sql.SQLException</pre>
<div class="block">Requests that a <code>Statement</code> be pooled or not pooled.  The value
 specified is a hint to the statement pool implementation indicating
 whether the application wants the statement to be pooled.  It is up to
 the statement pool manager as to whether the hint is used.
 <p>
 The poolable value of a statement is applicable to both internal
 statement caches implemented by the driver and external statement caches
 implemented by application servers and other applications.
 <p>
 By default, a <code>Statement</code> is not poolable when created, and
 a <code>PreparedStatement</code> and <code>CallableStatement</code>
 are poolable when created.
 <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setPoolable</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>poolable</code> - requests that the statement be pooled if true and
                                          that the statement not be pooled if false
 <p></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if this method is called on a closed
 <code>Statement</code>
 <p></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="isPoolable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPoolable</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isPoolable()
                   throws java.sql.SQLException</pre>
<div class="block">Returns a  value indicating whether the <code>Statement</code>
 is poolable or not.
 <p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>isPoolable</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the <code>Statement</code>
 is poolable; <code>false</code> otherwise</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if this method is called on a closed
 <code>Statement</code>
 <p></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0
 <p></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setPoolable(boolean)"><code>setPoolable(boolean)</code></a></dd>
</dl>
</li>
</ul>
<a id="unwrap(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unwrap</h4>
<pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;T&nbsp;unwrap&#8203;(java.lang.Class&lt;T&gt;&nbsp;iface)
             throws java.sql.SQLException</pre>
<div class="block">Returns an object that implements the given interface to allow access to
 non-standard methods, or standard methods not exposed by the proxy.

 If the receiver implements the interface then the result is the receiver
 or a proxy for the receiver. If the receiver is a wrapper
 and the wrapped object implements the interface then the result is the
 wrapped object or a proxy for the wrapped object. Otherwise return the
 the result of calling <code>unwrap</code> recursively on the wrapped object
 or a proxy for that result. If the receiver is not a
 wrapper and does not implement the interface, then an <code>SQLException</code> is thrown.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>unwrap</code>&nbsp;in interface&nbsp;<code>java.sql.Wrapper</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>iface</code> - A Class defining an interface that the result must implement.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an object that implements the interface. May be a proxy for the actual implementing object.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - If no object found that implements the interface</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="isWrapperFor(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isWrapperFor</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isWrapperFor&#8203;(java.lang.Class&lt;?&gt;&nbsp;iface)
                     throws java.sql.SQLException</pre>
<div class="block">Returns true if this either implements the interface argument or is directly or indirectly a wrapper
 for an object that does. Returns false otherwise. If this implements the interface then return true,
 else if this is a wrapper then return the result of recursively calling <code>isWrapperFor</code> on the wrapped
 object. If this does not implement the interface and is not a wrapper, return false.
 This method should be implemented as a low-cost operation compared to <code>unwrap</code> so that
 callers can use this method to avoid expensive <code>unwrap</code> calls that may fail. If this method
 returns true then calling <code>unwrap</code> with the same argument should succeed.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>isWrapperFor</code>&nbsp;in interface&nbsp;<code>java.sql.Wrapper</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>iface</code> - a Class defining an interface.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if this implements the interface or directly or indirectly wraps an object that does.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if an error occurs while determining whether this is a wrapper
 for an object with the given interface.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.6, HSQLDB 2.0</dd>
</dl>
</li>
</ul>
<a id="getLargeUpdateCount()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLargeUpdateCount</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getLargeUpdateCount()
                         throws java.sql.SQLException</pre>
<div class="block">Retrieves the current result as an update count; if the result
 is a <code>ResultSet</code> object or there are no more results, -1
  is returned. This method should be called only once per result.
 <p>
 This method should be used when the returned row count may exceed
 <code>Integer.MAX_VALUE</code>.
<p>
 The public implementation will throw <code>UnsupportedOperationException</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getLargeUpdateCount</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current result as an update count; -1 if the current result
 is a <code>ResultSet</code> object or there are no more results</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.8</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#execute()"><code>execute()</code></a></dd>
</dl>
</li>
</ul>
<a id="setLargeMaxRows(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLargeMaxRows</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setLargeMaxRows&#8203;(long&nbsp;max)
                     throws java.sql.SQLException</pre>
<div class="block">Sets the limit for the maximum number of rows that any
 <code>ResultSet</code> object  generated by this <code>Statement</code>
 object can contain to the given number.
 If the limit is exceeded, the excess
 rows are silently dropped.
 <p>
 This method should be used when the row limit may exceed
 <code>Integer.MAX_VALUE</code>.
<p>
 The default implementation will throw <code>UnsupportedOperationException</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setLargeMaxRows</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>max</code> - the new max rows limit; zero means there is no limit</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>Statement</code>
            or the condition <code>max &gt;= 0</code> is not satisfied</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.8</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getMaxRows()"><code>getMaxRows()</code></a></dd>
</dl>
</li>
</ul>
<a id="getLargeMaxRows()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLargeMaxRows</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;getLargeMaxRows()
                     throws java.sql.SQLException</pre>
<div class="block">Retrieves the maximum number of rows that a
 <code>ResultSet</code> object produced by this
 <code>Statement</code> object can contain.  If this limit is exceeded,
 the excess rows are silently dropped.
 <p>
 This method should be used when the returned row limit may exceed
 <code>Integer.MAX_VALUE</code>.
<p>
 The default implementation will return <code>0</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>getLargeMaxRows</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current maximum number of rows for a <code>ResultSet</code>
         object produced by this <code>Statement</code> object;
         zero means there is no limit</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs or
 this method is called on a closed <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.8</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setMaxRows(int)"><code>setMaxRows(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="executeLargeBatch()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeLargeBatch</h4>
<pre class="methodSignature">public&nbsp;long[]&nbsp;executeLargeBatch()
                         throws java.sql.SQLException</pre>
<div class="block">Submits a batch of commands to the database for execution and
 if all commands execute successfully, returns an array of update counts.
 The <code>long</code> elements of the array that is returned are ordered
 to correspond to the commands in the batch, which are ordered
 according to the order in which they were added to the batch.
 The elements in the array returned by the method <code>executeLargeBatch</code>
 may be one of the following:
 <OL>
 <LI>A number greater than or equal to zero -- indicates that the
 command was processed successfully and is an update count giving the
 number of rows in the database that were affected by the command's
 execution
 <LI>A value of <code>SUCCESS_NO_INFO</code> -- indicates that the command was
 processed successfully but that the number of rows affected is
 unknown
 <P>
 If one of the commands in a batch update fails to execute properly,
 this method throws a <code>BatchUpdateException</code>, and a JDBC
 driver may or may not continue to process the remaining commands in
 the batch.  However, the driver's behavior must be consistent with a
 particular DBMS, either always continuing to process commands or never
 continuing to process commands.  If the driver continues processing
 after a failure, the array returned by the method
 <code>BatchUpdateException.getLargeUpdateCounts</code>
 will contain as many elements as there are commands in the batch, and
 at least one of the elements will be the following:

 <LI>A value of <code>EXECUTE_FAILED</code> -- indicates that the command failed
 to execute successfully and occurs only if a driver continues to
 process commands after a command fails
 </OL>
 <p>
 This method should be used when the returned row count may exceed
 <code>Integer.MAX_VALUE</code>.
<p>
 The default implementation will throw <code>UnsupportedOperationException</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeLargeBatch</code>&nbsp;in interface&nbsp;<code>java.sql.Statement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of update counts containing one element for each
 command in the batch.  The elements of the array are ordered according
 to the order in which commands were added to the batch.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs,
 this method is called on a closed <code>Statement</code> or the
 driver does not support batch statements. Throws <code>BatchUpdateException</code>
 (a subclass of <code>SQLException</code>) if one of the commands sent to the
 database fails to execute properly or attempts to return a result set.</dd>
<dd><code>java.sql.SQLTimeoutException</code> - when the driver has determined that the
 timeout value that was specified by the <code>setQueryTimeout</code>
 method has been exceeded and has at least attempted to cancel
 the currently running <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.8</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#addBatch()"><code>addBatch()</code></a>, 
<code>DatabaseMetaData.supportsBatchUpdates()</code></dd>
</dl>
</li>
</ul>
<a id="setObject(int,java.lang.Object,java.sql.SQLType,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setObject</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setObject&#8203;(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      java.sql.SQLType&nbsp;targetSqlType,
                      int&nbsp;scaleOrLength)
               throws java.sql.SQLException</pre>
<div class="block"><p>Sets the value of the designated parameter with the given object.

 If the second argument is an <code>InputStream</code> then the stream
 must contain the number of bytes specified by scaleOrLength.
 If the second argument is a <code>Reader</code> then the reader must
 contain the number of characters specified by scaleOrLength. If these
 conditions are not true the driver will generate a
 <code>SQLException</code> when the prepared statement is executed.

 <p>The given Java object will be converted to the given targetSqlType
 before being sent to the database.

 If the object has a custom mapping (is of a class implementing the
 interface <code>SQLData</code>),
 the JDBC driver should call the method <code>SQLData.writeSQL</code> to
 write it to the SQL data stream.
 If, on the other hand, the object is of a class implementing
 <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,  <code>NClob</code>,
  <code>Struct</code>, <code>java.net.URL</code>,
 or <code>Array</code>, the driver should pass it to the database as a
 value of the corresponding SQL type.

 <p>Note that this method may be used to pass database-specific
 abstract data types.
<P>
 The default implementation will throw <code>SQLFeatureNotSupportedException</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setObject</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the object containing the input parameter value</dd>
<dd><code>targetSqlType</code> - the SQL type to be sent to the database. The
 scale argument may further qualify this type.</dd>
<dd><code>scaleOrLength</code> - for <code>java.sql.JDBCType.DECIMAL</code>
          or <code>java.sql.JDBCType.NUMERIC types</code>,
          this is the number of digits after the decimal point. For
          Java Object types <code>InputStream</code> and <code>Reader</code>,
          this is the length
          of the data in the stream or reader.  For all other types,
          this value will be ignored.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a
 parameter marker in the SQL statement; if a database access error occurs
 or this method is called on a closed <code>PreparedStatement</code>  or
            if the Java Object specified by x is an InputStream
            or Reader object and the value of the scale parameter is less
            than zero</dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if
 the JDBC driver does not support the specified targetSqlType</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.8</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>JDBCType</code>, 
<code>SQLType</code></dd>
</dl>
</li>
</ul>
<a id="setObject(int,java.lang.Object,java.sql.SQLType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setObject</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setObject&#8203;(int&nbsp;parameterIndex,
                      java.lang.Object&nbsp;x,
                      java.sql.SQLType&nbsp;targetSqlType)
               throws java.sql.SQLException</pre>
<div class="block">Sets the value of the designated parameter with the given object.

 This method is similar to <a href="#setObject(int,java.lang.Object,java.sql.SQLType,int)"><code>setObject(int parameterIndex,
 Object x, SQLType targetSqlType, int scaleOrLength)</code></a>,
 except that it assumes a scale of zero.
<P>
 The default implementation will throw <code>SQLFeatureNotSupportedException</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>setObject</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameterIndex</code> - the first parameter is 1, the second is 2, ...</dd>
<dd><code>x</code> - the object containing the input parameter value</dd>
<dd><code>targetSqlType</code> - the SQL type to be sent to the database</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if parameterIndex does not correspond to a
 parameter marker in the SQL statement; if a database access error occurs
 or this method is called on a closed <code>PreparedStatement</code></dd>
<dd><code>java.sql.SQLFeatureNotSupportedException</code> - if the JDBC driver does not support
 the specified targetSqlType</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.8</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>JDBCType</code>, 
<code>SQLType</code></dd>
</dl>
</li>
</ul>
<a id="executeLargeUpdate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeLargeUpdate</h4>
<pre class="methodSignature">public&nbsp;long&nbsp;executeLargeUpdate()
                        throws java.sql.SQLException</pre>
<div class="block">Executes the SQL statement in this <code>PreparedStatement</code> object,
 which must be an SQL Data Manipulation Language (DML) statement,
 such as <code>INSERT</code>, <code>UPDATE</code> or
 <code>DELETE</code>; or an SQL statement that returns nothing,
 such as a DDL statement.
 <p>
 This method should be used when the returned row count may exceed
 <code>Integer.MAX_VALUE</code>.
 <p>
 The default implementation will throw <code>UnsupportedOperationException</code></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>executeLargeUpdate</code>&nbsp;in interface&nbsp;<code>java.sql.PreparedStatement</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>either (1) the row count for SQL Data Manipulation Language
 (DML) statements or (2) 0 for SQL statements that return nothing</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database access error occurs;
 this method is called on a closed  <code>PreparedStatement</code>
 or the SQL statement returns a <code>ResultSet</code> object</dd>
<dd><code>java.sql.SQLTimeoutException</code> - when the driver has determined that the
 timeout value that was specified by the <code>setQueryTimeout</code>
 method has been exceeded and has at least attempted to cancel
 the currently running <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.8</dd>
</dl>
</li>
</ul>
<a id="closeOnCompletion()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closeOnCompletion</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;closeOnCompletion()
                       throws java.sql.SQLException</pre>
<div class="block">Specifies that this <code>Statement</code> will be closed when all its
 dependent result sets are closed. If execution of the <code>Statement</code>
 does not produce any result sets, this method has no effect.
 <p>
 <strong>Note:</strong> Multiple calls to <code>closeOnCompletion</code> do
 not toggle the effect on this <code>Statement</code>. However, a call to
 <code>closeOnCompletion</code> does effect both the subsequent execution of
 statements, and statements that currently have open, dependent,
 result sets.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if this method is called on a closed
 <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.7 M11 2010/09/10 (b123), HSQLDB 2.0.1</dd>
</dl>
</li>
</ul>
<a id="isCloseOnCompletion()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>isCloseOnCompletion</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isCloseOnCompletion()
                            throws java.sql.SQLException</pre>
<div class="block">Returns a value indicating whether this <code>Statement</code> will be
 closed when all its dependent result sets are closed.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the <code>Statement</code> will be closed when all
 of its dependent result sets are closed; <code>false</code> otherwise</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if this method is called on a closed
 <code>Statement</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>JDK 1.7 M11 2010/09/10 (b123), HSQLDB 2.0.1</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/JDBCPreparedStatement.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small><i>Copyright  2001 - 2021 HSQL Development Group.</i></small></p>
</footer>
</body>
</html>
