var Rollup = (function (exports) {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	/*

	Inheritence "Class"
	-------------------
	see: http://ejohn.org/blog/simple-javascript-inheritance/
	To subclass, use:

		var MyClass = Class.extend({
			init: function
		})

	*/
	// https://stackoverflow.com/a/15052240/5353542

	/* Simple JavaScript Inheritance for ES 5.1
	 * based on http://ejohn.org/blog/simple-javascript-inheritance/
	 *  (inspired by base2 and Prototype)
	 * MIT Licensed.
	 */
	(function(global) {
		var fnTest = /xyz/.test(function(){}) ? /\b_super\b/ : /.*/;

		// The base Class implementation (does nothing)
		function Class(){}

		// Create a new Class that inherits from this class
		Class.extend = function(props) {
		  var _super = this.prototype;

		  // Set up the prototype to inherit from the base class
		  // (but without running the init constructor)
		  var proto = Object.create(_super);

		  // Copy the properties over onto the new prototype
		  for (var name in props) {
			// Check if we're overwriting an existing function
			proto[name] = typeof props[name] === "function" &&
			  typeof _super[name] == "function" && fnTest.test(props[name])
			  ? (function(name, fn){
				  return function() {
					var tmp = this._super;

					// Add a new ._super() method that is the same method
					// but on the super-class
					this._super = _super[name];

					// The method only need to be bound temporarily, so we
					// remove it when we're done executing
					var ret = fn.apply(this, arguments);
					this._super = tmp;

					return ret;
				  };
				})(name, props[name])
			  : props[name];
		  }

		  // The new constructor
		  var newClass = typeof proto.init === "function"
			? proto.hasOwnProperty("init")
			  ? proto.init // All construction is actually done in the init method
			  : function SubClass(){ _super.init.apply(this, arguments); }
			: function EmptyClass(){};

		  // Populate our constructed prototype object
		  newClass.prototype = proto;

		  // Enforce the constructor to be what we expect
		  proto.constructor = newClass;

		  // And make this class extendable
		  newClass.extend = Class.extend;

		  return newClass;
		};

		// export
		global.Class = Class;
	  })(commonjsGlobal);

	var _class = {

	};

	// String.prototype.includes polyfill
	// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	if (!String.prototype.includes) {
		String.prototype.includes = function(search, start) {
			if (typeof start !== 'number') {
				start = 0;
			}
			if (start + search.length > this.length) {
				return false;
			} else {
				return this.indexOf(search, start) !== -1;
			}
		};
	}
	// Array.prototype.includes polyfill
	// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/includes
	if (!Array.prototype.includes) {
		Object.defineProperty(Array.prototype, 'includes', {
			value: function(searchElement, fromIndex) {
				if (this == null) {
					throw new TypeError('"this" is null or not defined');
				}
				var o = Object(this);
				var len = o.length >>> 0;
				if (len === 0) {
					return false;
				}
				var n = fromIndex | 0;
				var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
				while (k < len) {
					if (o[k] === searchElement) {
						return true;
					}
					k++;
				}
				return false;
			}
		});
	}


	if (typeof String.prototype.trimLeft !== "function") {
		String.prototype.trimLeft = function() {
			return this.replace(/^\s+/, "");
		};
	}
	if (typeof String.prototype.trimRight !== "function") {
		String.prototype.trimRight = function() {
			return this.replace(/\s+$/, "");
		};
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	if (typeof Object.assign != 'function') {
		// Must be writable: true, enumerable: false, configurable: true
		Object.defineProperty(Object, "assign", {
			value: function assign(target) { // .length of function is 2
				var arguments$1 = arguments;

				if (target == null) { // TypeError if undefined or null
					throw new TypeError('Cannot convert undefined or null to object');
				}

				var to = Object(target);

				for (var index = 1; index < arguments.length; index++) {
					var nextSource = arguments$1[index];

					if (nextSource != null) { // Skip over if undefined or null
						for (var nextKey in nextSource) {
							// Avoid bugs when hasOwnProperty is shadowed
							if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
								to[nextKey] = nextSource[nextKey];
							}
						}
					}
				}
				return to;
			},
			writable: true,
			configurable: true
		});
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// provide a namespace
	if(!window.frappe)
		{ window.frappe = {}; }

	frappe.provide = function(namespace) {
		// docs: create a namespace //
		var nsl = namespace.split('.');
		var parent = window;
		for(var i=0; i<nsl.length; i++) {
			var n = nsl[i];
			if(!parent[n]) {
				parent[n] = {};
			}
			parent = parent[n];
		}
		return parent;
	};

	frappe.provide("locals");
	frappe.provide("frappe.flags");
	frappe.provide("frappe.settings");
	frappe.provide("frappe.utils");
	frappe.provide("frappe.ui.form");
	frappe.provide("frappe.modules");
	frappe.provide("frappe.templates");
	frappe.provide("frappe.test_data");
	frappe.provide('frappe.desk.form');
	frappe.provide('frappe.desk.report');
	frappe.provide('frappe.utils');
	frappe.provide('frappe.model');
	frappe.provide('frappe.user');
	frappe.provide('frappe.session');
	frappe.provide('locals.DocType');

	// for listviews
	frappe.provide("frappe.listview_settings");
	frappe.provide("frappe.listview_parent_route");

	// constants
	window.NEWLINE = '\n';
	window.TAB = 9;
	window.UP_ARROW = 38;
	window.DOWN_ARROW = 40;

	// proxy for user globals defined in desk.js

	// API globals
	window.cur_frm=null;

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// library to mange assets (js, css, models, html) etc in the app.
	// will try and get from localStorge if latest are available
	// depends on frappe.versions to manage versioning

	frappe.require = function(items, callback) {
		if(typeof items === "string") {
			items = [items];
		}
		frappe.assets.execute(items, callback);
	};

	frappe.assets = {
		check: function() {
			// if version is different then clear localstorage
			if(window._version_number != localStorage.getItem("_version_number")) {
				frappe.assets.clear_local_storage();
				console.log("Cleared App Cache.");
			}

			if(localStorage._last_load) {
				var not_updated_since = new Date() - new Date(localStorage._last_load);
				if(not_updated_since < 10000 || not_updated_since > 86400000) {
					frappe.assets.clear_local_storage();
				}
			} else {
				frappe.assets.clear_local_storage();
			}

			frappe.assets.init_local_storage();
		},

		init_local_storage: function() {
			localStorage._last_load = new Date();
			localStorage._version_number = window._version_number;
			if(frappe.boot) { localStorage.metadata_version = frappe.boot.metadata_version; }
		},

		clear_local_storage: function() {
			$.each(["_last_load", "_version_number", "metadata_version", "page_info",
				"last_visited"], function(i, key) {
				localStorage.removeItem(key);
			});

			// clear assets
			for(var key in localStorage) {
				if(key.indexOf("desk_assets:")===0 || key.indexOf("_page:")===0
					|| key.indexOf("_doctype:")===0 || key.indexOf("preferred_breadcrumbs:")===0) {
					localStorage.removeItem(key);
				}
			}
			console.log("localStorage cleared");
		},


		// keep track of executed assets
		executed_ : [],

		// pass on to the handler to set
		execute: function(items, callback) {
			var to_fetch = [];
			for(var i=0, l=items.length; i<l; i++) {
				if(!frappe.assets.exists(items[i])) {
					to_fetch.push(items[i]);
				}
			}
			if(to_fetch.length) {
				frappe.assets.fetch(to_fetch, function() {
					frappe.assets.eval_assets(items, callback);
				});
			} else {
				frappe.assets.eval_assets(items, callback);
			}
		},

		eval_assets: function(items, callback) {
			for(var i=0, l=items.length; i<l; i++) {
				// execute js/css if not already.
				var path = items[i];
				if(frappe.assets.executed_.indexOf(path)===-1) {
					// execute
					frappe.assets.handler[frappe.assets.extn(path)](frappe.assets.get(path), path);
					frappe.assets.executed_.push(path);
				}
			}
			callback && callback();
		},

		// check if the asset exists in
		// localstorage
		exists: function(src) {
			if(frappe.assets.executed_.indexOf(src)!== -1) {
				return true;
			}
			if(frappe.boot.developer_mode) {
				return false;
			}
			if(frappe.assets.get(src)) {
				return true;
			} else {
				return false;
			}
		},

		// load an asset via
		fetch: function(items, callback) {
			// this is virtual page load, only get the the source
			// *without* the template

			frappe.call({
				type: "GET",
				method:"frappe.client.get_js",
				args: {
					"items": items
				},
				callback: function(r) {
					$.each(items, function(i, src) {
						frappe.assets.add(src, r.message[i]);
					});
					callback();
				},
				freeze: true,
			});
		},

		add: function(src, txt) {
			if('localStorage' in window) {
				try {
					frappe.assets.set(src, txt);
				} catch(e) {
					// if quota is exceeded, clear local storage and set item
					frappe.assets.clear_local_storage();
					frappe.assets.set(src, txt);
				}
			}
		},

		get: function(src) {
			return localStorage.getItem("desk_assets:" + src);
		},

		set: function(src, txt) {
			localStorage.setItem("desk_assets:" + src, txt);
		},

		extn: function(src) {
			if(src.indexOf('?')!=-1) {
				src = src.split('?').slice(-1)[0];
			}
			return src.split('.').slice(-1)[0];
		},

		handler: {
			js: function(txt, src) {
				frappe.dom.eval(txt);
			},
			css: function(txt, src) {
				frappe.dom.set_style(txt);
			}
		},
	};

	function format (str, args) {
		if(str==undefined) { return str; }

		this.unkeyed_index = 0;
		return str.replace(/\{(\w*)\}/g, function(match, key) {

			if (key === '') {
				key = this.unkeyed_index;
				this.unkeyed_index++;
			}
			if (key == +key) {
				return args[key] !== undefined
					? args[key]
					: match;
			}
		}.bind(this));
	}

	if (jQuery) {
		jQuery.format = format;
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// for license information please see license.txt

	frappe.provide("frappe.form.formatters");

	frappe.form.link_formatters = {};

	frappe.form.formatters = {
		_right: function(value, options) {
			if(options && (options.inline || options.only_value)) {
				return value;
			} else {
				return "<div style='text-align: right'>" + value + "</div>";
			}
		},
		Data: function(value) {
			return value==null ? "" : value;
		},
		Select: function(value) {
			return __(frappe.form.formatters["Data"](value));
		},
		Float: function(value, docfield, options, doc) {
			// don't allow 0 precision for Floats, hence or'ing with null
			var precision = docfield.precision
				|| cint(frappe.boot.sysdefaults && frappe.boot.sysdefaults.float_precision)
				|| null;
			if (docfield.options && docfield.options.trim()) {
				// options points to a currency field, but expects precision of float!
				docfield.precision = precision;
				return frappe.form.formatters.Currency(value, docfield, options, doc);

			} else {
				// show 1.000000 as 1
				if (!(options || {}).always_show_decimals && !is_null(value)) {
					var temp = cstr(value).split(".");
					if (temp[1]==undefined || cint(temp[1])===0) {
						precision = 0;
					}
				}

				return frappe.form.formatters._right(
					((value==null || value==="")
						? ""
						: format_number(value, null, precision)), options);
			}
		},
		Int: function(value, docfield, options) {
			return frappe.form.formatters._right(value==null ? "" : cint(value), options)
		},
		Percent: function(value, docfield, options) {
			return frappe.form.formatters._right(flt(value, 2) + "%", options)
		},
		Rating: function(value) {
			return ("<span class=\"rating\">\n\t" + (Array.from(new Array(5)).map(function (_, i) { return ("<i class=\"fa fa-fw fa-star " + (i < (value || 0) ? "star-click": "") + " star-icon\" data-idx=\"" + ((i+1)) + "\"></i>"); }
		).join('')) + "\n\t\t</span>");
		},
		Currency: function (value, docfield, options, doc) {
			var currency  = frappe.meta.get_field_currency(docfield, doc);
			var precision = docfield.precision || cint(frappe.boot.sysdefaults.currency_precision) || 2;

			// If you change anything below, it's going to hurt a company in UAE, a bit.
			if (precision > 2) {
				var parts	 = cstr(value).split("."); // should be minimum 2, comes from the DB
				var decimals = parts.length > 1 ? parts[1] : ""; // parts.length == 2 ???

				if ( decimals.length < 3 || decimals.length < precision ) {
					var fraction = frappe.model.get_value(":Currency", currency, "fraction_units") || 100; // if not set, minimum 2.
					precision      = cstr(fraction).length - 1;
				}
			}

			value = (value == null || value === "") ? "" : format_currency(value, currency, precision);

			if ( options && options.only_value ) {
				return value;
			} else {
				return frappe.form.formatters._right(value, options);
			}
		},
		Check: function(value) {
			if(value) {
				return '<i class="octicon octicon-check" style="margin-right: 3px;"></i>';
			} else {
				return '<i class="fa fa-square disabled-check"></i>';
			}
		},
		Link: function(value, docfield, options, doc) {
			var doctype = docfield._options || docfield.options;
			var original_value = value;
			if(value && value.match && value.match(/^['"].*['"]$/)) {
				value.replace(/^.(.*).$/, "$1");
			}

			if(options && (options.for_print || options.only_value)) {
				return value;
			}

			if(frappe.form.link_formatters[doctype]) {
				// don't apply formatters in case of composite (parent field of same type)
				if (doc && doctype !== doc.doctype) {
					value = frappe.form.link_formatters[doctype](value, doc);
				}
			}

			if(!value) {
				return "";
			}
			if(value[0] == "'" && value[value.length -1] == "'") {
				return value.substring(1, value.length - 1);
			}
			if(docfield && docfield.link_onclick) {
				return repl('<a onclick="%(onclick)s">%(value)s</a>',
					{onclick: docfield.link_onclick.replace(/"/g, '&quot;'), value:value});
			} else if(docfield && doctype) {
				return ("<a class=\"grey\"\n\t\t\t\thref=\"#Form/" + (encodeURIComponent(doctype)) + "/" + (encodeURIComponent(original_value)) + "\"\n\t\t\t\tdata-doctype=\"" + doctype + "\"\n\t\t\t\tdata-name=\"" + original_value + "\">\n\t\t\t\t" + (__(options && options.label || value)) + "</a>")
			} else {
				return value;
			}
		},
		Date: function(value) {
			if (value) {
				value = frappe.datetime.str_to_user(value);
				// handle invalid date
				if (value==="Invalid date") {
					value = null;
				}
			}

			return value || "";
		},
		DateRange: function(value) {
			if($.isArray(value)) {
				return __("{0} to {1}", [
					frappe.datetime.str_to_user(value[0]),
					frappe.datetime.str_to_user(value[1])
				]);
			} else {
				return value || "";
			}
		},
		Datetime: function(value) {
			if(value) {
				var m = moment(frappe.datetime.convert_to_user_tz(value));
				if(frappe.boot.sysdefaults.time_zone) {
					m = m.tz(frappe.boot.sysdefaults.time_zone);
				}
				return m.format(frappe.boot.sysdefaults.date_format.toUpperCase() + ', h:mm a z');
			} else {
				return "";
			}
		},
		Text: function(value) {
			if(value) {
				var tags = ["<p", "<div", "<br", "<table"];
				var match = false;

				for(var i=0; i<tags.length; i++) {
					if(value.match(tags[i])) {
						match = true;
						break;
					}
				}

				if(!match) {
					value = frappe.utils.replace_newlines(value);
				}
			}

			return frappe.form.formatters.Data(value);
		},
		LikedBy: function(value) {
			var html = "";
			$.each(JSON.parse(value || "[]"), function(i, v) {
				if(v) { html+= frappe.avatar(v); }
			});
			return html;
		},
		Tag: function(value) {
			var html = "";
			$.each((value || "").split(","), function(i, v) {
				if(v) { html+= '<span class="label label-info" \
				style="margin-right: 7px; cursor: pointer;"\
				data-field="_user_tags" data-label="'+v+'">'+v +'</span>'; }
			});
			return html;
		},
		Comment: function(value) {
			var html = "";
			$.each(JSON.parse(value || "[]"), function(i, v) {
				if(v) { html+= '<span class="label label-warning" \
				style="margin-right: 7px;"\
				data-field="_comments" data-label="'+v.name+'">'+v.comment+'</span>'; }
			});
			return html;
		},
		Assign: function(value) {
			var html = "";
			$.each(JSON.parse(value || "[]"), function(i, v) {
				if(v) { html+= '<span class="label label-warning" \
				style="margin-right: 7px;"\
				data-field="_assign">'+v+'</span>'; }
			});
			return html;
		},
		SmallText: function(value) {
			return frappe.form.formatters.Text(value);
		},
		TextEditor: function(value) {
			return frappe.form.formatters.Text(value);
		},
		Code: function(value) {
			return "<pre>" + (value==null ? "" : $("<div>").text(value).html()) + "</pre>"
		},
		WorkflowState: function(value) {
			var workflow_state = frappe.get_doc("Workflow State", value);
			if(workflow_state) {
				return repl("<span class='label label-%(style)s' \
				data-workflow-state='%(value)s'\
				style='padding-bottom: 4px; cursor: pointer;'>\
				<i class='fa fa-small fa-white fa-%(icon)s'></i> %(value)s</span>", {
						value: value,
						style: workflow_state.style.toLowerCase(),
						icon: workflow_state.icon
					});
			} else {
				return "<span class='label'>" + value + "</span>";
			}
		},
		Email: function(value) {
			return $("<div></div>").text(value).html();
		},
		FileSize: function(value) {
			if(value > 1048576) {
				value = flt(flt(value) / 1048576, 1) + "M";
			} else if (value > 1024) {
				value = flt(flt(value) / 1024, 1) + "K";
			}
			return value;
		},
		TableMultiSelect: function(rows, df, options) {
			rows = rows || [];
			var meta = frappe.get_meta(df.options);
			var link_field = meta.fields.find(function (df) { return df.fieldtype === 'Link'; });
			var formatted_values = rows.map(function (row) {
				var value = row[link_field.fieldname];
				return frappe.format(value, link_field, options, row);
			});
			return formatted_values.join(', ');
		}
	};

	frappe.form.get_formatter = function(fieldtype) {
		if(!fieldtype)
			{ fieldtype = "Data"; }
		return frappe.form.formatters[fieldtype.replace(/ /g, "")] || frappe.form.formatters.Data;
	};

	frappe.format = function(value, df, options, doc) {
		if(!df) { df = {"fieldtype":"Data"}; }
		var fieldtype = df.fieldtype || "Data";

		// format Dynamic Link as a Link
		if(fieldtype==="Dynamic Link") {
			fieldtype = "Link";
			df._options = doc ? doc[df.options] : null;
		}

		var formatter = df.formatter || frappe.form.get_formatter(fieldtype);

		var formatted = formatter(value, df, options, doc);

		if (typeof formatted == "string")
			{ formatted = frappe.dom.remove_script_and_style(formatted); }

		return formatted;
	};

	frappe.get_format_helper = function(doc) {
		var helper = {
			get_formatted: function(fieldname) {
				var df = frappe.meta.get_docfield(doc.doctype, fieldname);
				if(!df) { console.log("fieldname not found: " + fieldname); }
				return frappe.format(doc[fieldname], df, {inline:1}, doc);
			}
		};
		$.extend(helper, doc);
		return helper;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// add a new dom element
	frappe.provide('frappe.dom');

	frappe.dom = {
		id_count: 0,
		freeze_count: 0,
		by_id: function(id) {
			return document.getElementById(id);
		},
		get_unique_id: function() {
			var id = 'unique-' + frappe.dom.id_count;
			frappe.dom.id_count++;
			return id;
		},
		set_unique_id: function(ele) {
			var $ele = $(ele);
			if($ele.attr('id')) {
				return $ele.attr('id');
			}
			var id = 'unique-' + frappe.dom.id_count;
			$ele.attr('id', id);
			frappe.dom.id_count++;
			return id;
		},
		eval: function(txt) {
			if(!txt) { return; }
			var el = document.createElement('script');
			el.appendChild(document.createTextNode(txt));
			// execute the script globally
			document.getElementsByTagName('head')[0].appendChild(el);
		},
		remove_script_and_style: function(txt) {
			var evil_tags = ["script", "style", "noscript", "title", "meta", "base", "head"];
			var regex = new RegExp(evil_tags.map(function (tag) { return ("<" + tag + ">.*<\\/" + tag + ">"); }).join('|'));
			if (!regex.test(txt)) {
				// no evil tags found, skip the DOM method entirely!
				return txt;
			}

			var div = document.createElement('div');
			div.innerHTML = txt;
			var found = false;
			evil_tags.forEach(function(e) {
				var elements = div.getElementsByTagName(e);
				i = elements.length;
				while (i--) {
					found = true;
					elements[i].parentNode.removeChild(elements[i]);
				}
			});

			// remove links with rel="stylesheet"
			var elements = div.getElementsByTagName('link');
			var i = elements.length;
			while (i--) {
				if (elements[i].getAttribute("rel")=="stylesheet"){
					found = true;
					elements[i].parentNode.removeChild(elements[i]);
				}
			}
			if(found) {
				return div.innerHTML;
			} else {
				// don't disturb
				return txt;
			}
		},
		is_element_in_viewport: function (el, tolerance) {
			if ( tolerance === void 0 ) tolerance=0;


			//special bonus for those using jQuery
			if (typeof jQuery === "function" && el instanceof jQuery) {
				el = el[0];
			}

			var rect = el.getBoundingClientRect();

			return (
				rect.top + tolerance >= 0
				&& rect.left + tolerance >= 0
				&& rect.bottom - tolerance <= $(window).height()
				&& rect.right - tolerance <= $(window).width()
			);
		},

		set_style: function(txt, id) {
			if(!txt) { return; }

			var se = document.createElement('style');
			se.type = "text/css";

			if (id) {
				var element = document.getElementById(id);
				if (element) {
					element.parentNode.removeChild(element);
				}
				se.id = id;
			}

			if (se.styleSheet) {
				se.styleSheet.cssText = txt;
			} else {
				se.appendChild(document.createTextNode(txt));
			}
			document.getElementsByTagName('head')[0].appendChild(se);
			return se;
		},
		add: function(parent, newtag, className, cs, innerHTML, onclick) {
			if(parent && parent.substr){ parent = frappe.dom.by_id(parent); }
			var c = document.createElement(newtag);
			if(parent)
				{ parent.appendChild(c); }

			// if image, 3rd parameter is source
			if(className) {
				if(newtag.toLowerCase()=='img')
					{ c.src = className; }
				else
					{ c.className = className; }
			}
			if(cs) { frappe.dom.css(c,cs); }
			if(innerHTML) { c.innerHTML = innerHTML; }
			if(onclick) { c.onclick = onclick; }
			return c;
		},
		css: function(ele, s) {
			if(ele && s) {
				$.extend(ele.style, s);
			}
			return ele;
		},
		activate: function($parent, $child, common_class, active_class) {
			if ( active_class === void 0 ) active_class='active';

			$parent.find(("." + common_class + "." + active_class))
				.removeClass(active_class);
			$child.addClass(active_class);
		},
		freeze: function(msg, css_class) {
			// blur
			if(!$('#freeze').length) {
				var freeze = $('<div id="freeze" class="modal-backdrop fade"></div>')
					.on("click", function() {
						if (cur_frm && cur_frm.cur_grid) {
							cur_frm.cur_grid.toggle_view();
							return false;
						}
					})
					.appendTo("#body_div");

				freeze.html(repl('<div class="freeze-message-container"><div class="freeze-message"><p class="lead">%(msg)s</p></div></div>',
					{msg: msg || ""}));

				setTimeout(function() { freeze.addClass("in"); }, 1);

			} else {
				$("#freeze").addClass("in");
			}

			if (css_class) {
				$("#freeze").addClass(css_class);
			}

			frappe.dom.freeze_count++;
		},
		unfreeze: function() {
			if(!frappe.dom.freeze_count) { return; } // anything open?
			frappe.dom.freeze_count--;
			if(!frappe.dom.freeze_count) {
				var freeze = $('#freeze').removeClass("in").remove();
			}
		},
		save_selection: function() {
			// via http://stackoverflow.com/questions/5605401/insert-link-in-contenteditable-element
			if (window.getSelection) {
				var sel = window.getSelection();
				if (sel.getRangeAt && sel.rangeCount) {
					var ranges = [];
					for (var i = 0, len = sel.rangeCount; i < len; ++i) {
						ranges.push(sel.getRangeAt(i));
					}
					return ranges;
				}
			} else if (document.selection && document.selection.createRange) {
				return document.selection.createRange();
			}
			return null;
		},
		restore_selection: function(savedSel) {
			if (savedSel) {
				if (window.getSelection) {
					var sel = window.getSelection();
					sel.removeAllRanges();
					for (var i = 0, len = savedSel.length; i < len; ++i) {
						sel.addRange(savedSel[i]);
					}
				} else if (document.selection && savedSel.select) {
					savedSel.select();
				}
			}
		},
		is_touchscreen: function() {
			return ('ontouchstart' in window)
		},
		handle_broken_images: function handle_broken_images(container) {
			$(container).find('img').on('error', function (e) {
				var $img = $(e.currentTarget);
				$img.addClass('no-image');
			});
		},
		scroll_to_bottom: function scroll_to_bottom(container) {
			var $container = $(container);
			$container.scrollTop($container[0].scrollHeight);
		},
		file_to_base64: function file_to_base64(file_obj) {
			return new Promise(function (resolve) {
				var reader = new FileReader();
				reader.onload = function() {
					resolve(reader.result);
				};
				reader.readAsDataURL(file_obj);
			});
		},
		scroll_to_section: function scroll_to_section(section_name) {
			setTimeout(function () {
				var section = $(("a:contains(\"" + section_name + "\")"));
				if (section.length) {
					if(section.parent().hasClass('collapsed')) {
						// opens the section
						section.click();
					}
					frappe.ui.scroll(section.parent().parent());
				}
			}, 200);
		},
		pixel_to_inches: function pixel_to_inches(pixels) {
			var div = $('<div id="dpi" style="height: 1in; width: 1in; left: 100%; position: fixed; top: 100%;"></div>');
			div.appendTo(document.body);

			var dpi_x = document.getElementById('dpi').offsetWidth;
			var inches = pixels / dpi_x;
			div.remove();

			return inches;
		}
	};

	frappe.ellipsis = function(text, max) {
		if(!max) { max = 20; }
		text = cstr(text);
		if(text.length > max) {
			text = text.substr(0, max) + '...';
		}
		return text;
	};

	frappe.run_serially = function(tasks) {
		var result = Promise.resolve();
		tasks.forEach(function (task) {
			if(task) {
				result = result.then ? result.then(task) : Promise.resolve();
			}
		});
		return result;
	};

	frappe.load_image = function (src, onload, onerror, preprocess) {
		if ( preprocess === void 0 ) preprocess = function () {};

		var tester = new Image();
		tester.onload = function() {
			onload(this);
		};
		tester.onerror = onerror;

		preprocess(tester);
		tester.src = src;
	};

	frappe.timeout = function (seconds) {
		return new Promise(function (resolve) {
			setTimeout(function () { return resolve(); }, seconds * 1000);
		});
	};

	frappe.scrub = function(text, spacer) {
		if ( spacer === void 0 ) spacer='_';

		return text.replace(/ /g, spacer).toLowerCase();
	};

	frappe.get_modal = function(title, content) {
		return $(("<div class=\"modal fade\" style=\"overflow: auto;\" tabindex=\"-1\">\n\t\t<div class=\"modal-dialog\">\n\t\t\t<div class=\"modal-content\">\n\t\t\t\t<div class=\"modal-header\">\n\t\t\t\t\t<div class=\"flex justify-between\">\n\t\t\t\t\t\t<div class=\"fill-width\">\n\t\t\t\t\t\t\t<span class=\"indicator hidden\"></span>\n\t\t\t\t\t\t\t<h4 class=\"modal-title\" style=\"font-weight: bold;\">" + title + "</h4>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<div class=\"text-right buttons\">\n\t\t\t\t\t\t\t\t<button type=\"button\" class=\"btn btn-default btn-sm btn-modal-minimize hide\">\n\t\t\t\t\t\t\t\t\t<i class=\"octicon octicon-chevron-down\" style=\"padding: 1px 0px;\"></i>\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button type=\"button\" class=\"btn btn-default btn-sm btn-modal-close\" data-dismiss=\"modal\">\n\t\t\t\t\t\t\t\t\t<i class=\"octicon octicon-x visible-xs\" style=\"padding: 1px 0px;\"></i>\n\t\t\t\t\t\t\t\t\t<span class=\"hidden-xs\">" + (__("Close")) + "</span>\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button type=\"button\" class=\"btn btn-primary btn-sm hide\">\n\t\t\t\t\t\t\t\t\t" + (__("Confirm")) + "\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"modal-body ui-front\">" + content + "</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>"));
	};

	frappe.is_online = function() {
		if (frappe.boot.developer_mode == 1) {
			// always online in developer_mode
			return true;
		}
		if ('onLine' in navigator) {
			return navigator.onLine;
		}
		return true;
	};

	// bind online/offline events
	$(window).on('online', function() {
		frappe.show_alert({
			indicator: 'green',
			message: __('You are connected to internet.')
		});
	});

	$(window).on('offline', function() {
		frappe.show_alert({
			indicator: 'orange',
			message: __('Connection lost. Some features might not work.')
		});
	});

	frappe.ui.form.Layout = Class.extend({
		init: function(opts) {
			this.views = {};
			this.pages = [];
			this.sections = [];
			this.fields_list = [];
			this.fields_dict = {};

			$.extend(this, opts);
		},
		make: function() {
			if(!this.parent && this.body) {
				this.parent = this.body;
			}
			this.wrapper = $('<div class="form-layout">').appendTo(this.parent);
			this.message = $('<div class="form-message text-muted small hidden"></div>').appendTo(this.wrapper);
			if(!this.fields) {
				this.fields = this.get_doctype_fields();
			}
			this.setup_tabbing();
			this.render();
		},
		show_empty_form_message: function() {
			if(!(this.wrapper.find(".frappe-control:visible").length || this.wrapper.find(".section-head.collapsed").length)) {
				this.show_message(__("This form does not have any input"));
			}
		},
		get_doctype_fields: function() {
			var fields = [
				{
					parent: this.frm.doctype,
					fieldtype: 'Data',
					fieldname: '__newname',
					reqd: 1,
					hidden: 1,
					label: __('Name'),
					get_status: function(field) {
						if (field.frm && field.frm.is_new()
							&& field.frm.meta.autoname
							&& ['prompt', 'name'].includes(field.frm.meta.autoname.toLowerCase())) {
							return 'Write';
						}
						return 'None';
					}
				}
			];
			fields = fields.concat(frappe.meta.sort_docfields(frappe.meta.docfield_map[this.doctype]));
			return fields;
		},
		show_message: function(html, color) {
			if (this.message_color) {
				// remove previous color
				this.message.removeClass(this.message_color);
			}
			this.message_color = (color && ['yellow', 'blue'].includes(color)) ? color : 'blue';
			if(html) {
				if(html.substr(0, 1)!=='<') {
					// wrap in a block
					html = '<div>' + html + '</div>';
				}
				this.message.removeClass('hidden').addClass(this.message_color);
				$(html).appendTo(this.message);
			} else {
				this.message.empty().addClass('hidden');
			}
		},
		render: function(new_fields) {
			var me = this;
			var fields = new_fields || this.fields;

			this.section = null;
			this.column = null;

			if (this.with_dashboard) {
				this.setup_dashboard_section();
			}

			if (this.no_opening_section()) {
				this.make_section();
			}
			$.each(fields, function(i, df) {
				switch(df.fieldtype) {
					case "Fold":
						me.make_page(df);
						break;
					case "Section Break":
						me.make_section(df);
						break;
					case "Column Break":
						me.make_column(df);
						break;
					default:
						me.make_field(df);
				}
			});

		},

		no_opening_section: function() {
			return (this.fields[0] && this.fields[0].fieldtype!="Section Break") || !this.fields.length;
		},

		setup_dashboard_section: function() {
			if (this.no_opening_section()) {
				this.fields.unshift({fieldtype: 'Section Break'});
			}

			this.fields.unshift({
				fieldtype: 'Section Break',
				fieldname: '_form_dashboard',
				label: __('Dashboard'),
				cssClass: 'form-dashboard',
				collapsible: 1,
				//hidden: 1
			});
		},

		replace_field: function(fieldname, df, render) {
			df.fieldname = fieldname; // change of fieldname is avoided
			if (this.fields_dict[fieldname] && this.fields_dict[fieldname].df) {
				var fieldobj = this.init_field(df, render);
				this.fields_dict[fieldname].$wrapper.remove();
				this.fields_list.splice(this.fields_dict[fieldname], 1, fieldobj);
				this.fields_dict[fieldname] = fieldobj;
				if (this.frm) {
					fieldobj.perm = this.frm.perm;
				}
				this.section.fields_list.splice(this.section.fields_dict[fieldname], 1, fieldobj);
				this.section.fields_dict[fieldname] = fieldobj;
				this.refresh_fields([df]);
			}
		},

		make_field: function(df, colspan, render) {
			!this.section && this.make_section();
			!this.column && this.make_column();

			var fieldobj = this.init_field(df, render);
			this.fields_list.push(fieldobj);
			this.fields_dict[df.fieldname] = fieldobj;
			if(this.frm) {
				fieldobj.perm = this.frm.perm;
			}

			this.section.fields_list.push(fieldobj);
			this.section.fields_dict[df.fieldname] = fieldobj;
		},

		init_field: function(df, render) {
			if ( render === void 0 ) render = false;

			var fieldobj = frappe.ui.form.make_control({
				df: df,
				doctype: this.doctype,
				parent: this.column.wrapper.get(0),
				frm: this.frm,
				render_input: render
			});

			fieldobj.layout = this;
			return fieldobj;
		},

		make_page: function(df) {
			var me = this,
				head = $('<div class="form-clickable-section text-center">\
				<a class="btn-fold h6 text-muted">'+__("Show more details")+'</a>\
			</div>').appendTo(this.wrapper);

			this.page = $('<div class="form-page second-page hide"></div>').appendTo(this.wrapper);

			this.fold_btn = head.find(".btn-fold").on("click", function() {
				var page = $(this).parent().next();
				if(page.hasClass("hide")) {
					$(this).removeClass("btn-fold").html(__("Hide details"));
					page.removeClass("hide");
					frappe.utils.scroll_to($(this), true, 30);
					me.folded = false;
				} else {
					$(this).addClass("btn-fold").html(__("Show more details"));
					page.addClass("hide");
					me.folded = true;
				}
			});

			this.section = null;
			this.folded = true;
		},

		unfold: function() {
			this.fold_btn.trigger('click');
		},

		make_section: function(df) {
			this.section = new frappe.ui.form.Section(this, df);

			// append to layout fields
			if(df) {
				this.fields_dict[df.fieldname] = this.section;
				this.fields_list.push(this.section);
			}

			this.column = null;
		},

		make_column: function(df) {
			this.column = new frappe.ui.form.Column(this.section, df);
			if(df && df.fieldname) {
				this.fields_list.push(this.column);
			}
		},

		refresh: function(doc) {
			var me = this;
			if(doc) { this.doc = doc; }

			if (this.frm) {
				this.wrapper.find(".empty-form-alert").remove();
			}

			// NOTE this might seem redundant at first, but it needs to be executed when frm.refresh_fields is called
			me.attach_doc_and_docfields(true);

			if(this.frm && this.frm.wrapper) {
				$(this.frm.wrapper).trigger("refresh-fields");
			}

			// dependent fields
			this.refresh_dependency();

			// refresh sections
			this.refresh_sections();

			// collapse sections
			if(this.frm) {
				this.refresh_section_collapse();
			}
		},

		refresh_sections: function() {
			var cnt = 0;

			// hide invisible sections and set alternate background color
			this.wrapper.find(".form-section:not(.hide-control)").each(function() {
				var $this = $(this).removeClass("empty-section")
					.removeClass("visible-section")
					.removeClass("shaded-section");
				if(!$this.find(".frappe-control:not(.hide-control)").length
					&& !$this.hasClass('form-dashboard')) {
					// nothing visible, hide the section
					$this.addClass("empty-section");
				} else {
					$this.addClass("visible-section");
					if(cnt % 2) {
						$this.addClass("shaded-section");
					}
					cnt++;
				}
			});
		},

		refresh_fields: function(fields) {
			var fieldnames = fields.map(function (field) {
				if(field.fieldname) { return field.fieldname; }
			});

			this.fields_list.map(function (fieldobj) {
				if(fieldnames.includes(fieldobj.df.fieldname)) {
					fieldobj.refresh();
					if(fieldobj.df["default"]) {
						fieldobj.set_input(fieldobj.df["default"]);
					}
				}
			});
		},

		add_fields: function(fields) {
			this.render(fields);
			this.refresh_fields(fields);
		},

		refresh_section_collapse: function() {
			if(!this.doc) { return; }

			for(var i=0; i<this.sections.length; i++) {
				var section = this.sections[i];
				var df = section.df;
				if(df && df.collapsible) {
					var collapse = true;

					if(df.collapsible_depends_on) {
						collapse = !this.evaluate_depends_on_value(df.collapsible_depends_on);
					}

					if (collapse && section.has_missing_mandatory()) {
						collapse = false;
					}

					if(df.fieldname === '_form_dashboard') {
						collapse = localStorage.getItem('collapseFormDashboard')==='yes' ? true : false;
					}

					section.collapse(collapse);
				}
			}
		},

		attach_doc_and_docfields: function(refresh) {
			var me = this;
			for(var i=0, l=this.fields_list.length; i<l; i++) {
				var fieldobj = this.fields_list[i];
				if(me.doc) {
					fieldobj.doc = me.doc;
					fieldobj.doctype = me.doc.doctype;
					fieldobj.docname = me.doc.name;
					fieldobj.df = frappe.meta.get_docfield(me.doc.doctype,
						fieldobj.df.fieldname, me.frm ? me.frm.doc.name : me.doc.name) || fieldobj.df;

					// on form change, permissions can change
					if(me.frm) {
						fieldobj.perm = me.frm.perm;
					}
				}
				refresh && fieldobj.df && fieldobj.refresh && fieldobj.refresh();
			}
		},

		refresh_section_count: function() {
			this.wrapper.find(".section-count-label:visible").each(function(i) {
				$(this).html(i+1);
			});
		},
		setup_tabbing: function() {
			var me = this;
			this.wrapper.on("keydown", function(ev) {
				if(ev.which==9) {
					var current = $(ev.target),
						doctype = current.attr("data-doctype"),
						fieldname = current.attr("data-fieldname");
					if(doctype)
						{ return me.handle_tab(doctype, fieldname, ev.shiftKey); }
				}
			});
		},
		handle_tab: function(doctype, fieldname, shift) {
			var me = this,
				grid_row = null,
				prev = null,
				fields = me.fields_list,
				focused = false;

			// in grid
			if(doctype != me.doctype) {
				grid_row = me.get_open_grid_row();
				if(!grid_row || !grid_row.layout) {
					return;
				}
				fields = grid_row.layout.fields_list;
			}

			for(var i=0, len=fields.length; i < len; i++) {
				if(fields[i].df.fieldname==fieldname) {
					if(shift) {
						if(prev) {
							this.set_focus(prev);
						} else {
							$(this.primary_button).focus();
						}
						break;
					}
					if(i < len-1) {
						focused = me.focus_on_next_field(i, fields);
					}

					if (focused) {
						break;
					}
				}
				if(this.is_visible(fields[i]))
					{ prev = fields[i]; }
			}

			if (!focused) {
				// last field in this group
				if(grid_row) {
					// in grid
					if(grid_row.doc.idx==grid_row.grid.grid_rows.length) {
						// last row, close it and find next field
						grid_row.toggle_view(false, function() {
							grid_row.grid.frm.layout.handle_tab(grid_row.grid.df.parent, grid_row.grid.df.fieldname);
						});
					} else {
						// next row
						grid_row.grid.grid_rows[grid_row.doc.idx].toggle_view(true);
					}
				} else {
					$(this.primary_button).focus();
				}
			}

			return false;
		},
		focus_on_next_field: function(start_idx, fields) {
			// loop to find next eligible fields
			for(var i= start_idx + 1, len = fields.length; i < len; i++) {
				var field = fields[i];
				if(this.is_visible(field)) {
					if(field.df.fieldtype==="Table") {
						// open table grid
						if(!(field.grid.grid_rows && field.grid.grid_rows.length)) {
							// empty grid, add a new row
							field.grid.add_new_row();
						}
						// show grid row (if exists)
						field.grid.grid_rows[0].show_form();
						return true;

					} else if(!in_list(frappe.model.no_value_type, field.df.fieldtype)) {
						this.set_focus(field);
						return true;
					}
				}
			}
		},
		is_visible: function(field) {
			return field.disp_status==="Write" && (field.$wrapper && field.$wrapper.is(":visible"));
		},
		set_focus: function(field) {
			// next is table, show the table
			if(field.df.fieldtype=="Table") {
				if(!field.grid.grid_rows.length) {
					field.grid.add_new_row(1);
				} else {
					field.grid.grid_rows[0].toggle_view(true);
				}
			} else if(field.editor) {
				field.editor.set_focus();
			} else if(field.$input) {
				field.$input.focus();
			}
		},
		get_open_grid_row: function() {
			return $(".grid-row-open").data("grid_row");
		},
		refresh_dependency: function() {
			// Resolve "depends_on" and show / hide accordingly
			var me = this;

			// build dependants' dictionary
			var has_dep = false;

			for(var fkey in this.fields_list) {
				var f = this.fields_list[fkey];
				f.dependencies_clear = true;
				if(f.df.depends_on) {
					has_dep = true;
				}
			}

			if(!has_dep){ return; }

			// show / hide based on values
			for(var i=me.fields_list.length-1;i>=0;i--) {
				var f = me.fields_list[i];
				f.guardian_has_value = true;
				if(f.df.depends_on) {
					// evaluate guardian

					f.guardian_has_value = this.evaluate_depends_on_value(f.df.depends_on);

					// show / hide
					if(f.guardian_has_value) {
						if(f.df.hidden_due_to_dependency) {
							f.df.hidden_due_to_dependency = false;
							f.refresh();
						}
					} else {
						if(!f.df.hidden_due_to_dependency) {
							f.df.hidden_due_to_dependency = true;
							f.refresh();
						}
					}
				}
			}

			this.refresh_section_count();
		},
		evaluate_depends_on_value: function(expression) {
			var out = null;
			var doc = this.doc;

			if (!doc && this.get_values) {
				var doc = this.get_values(true);
			}

			if (!doc) {
				return;
			}

			var parent = this.frm ? this.frm.doc : null;

			if(typeof(expression) === 'boolean') {
				out = expression;

			} else if(typeof(expression) === 'function') {
				out = expression(doc);

			} else if(expression.substr(0,5)=='eval:') {
				try {
					out = eval(expression.substr(5));
					if(parent && parent.istable && expression.includes('is_submittable')) {
						out = true;
					}
				} catch(e) {
					frappe.throw(__('Invalid "depends_on" expression'));
				}

			} else if(expression.substr(0,3)=='fn:' && this.frm) {
				out = this.frm.script_manager.trigger(expression.substr(3), this.doctype, this.docname);
			} else {
				var value = doc[expression];
				if($.isArray(value)) {
					out = !!value.length;
				} else {
					out = !!value;
				}
			}

			return out;
		}
	});

	frappe.ui.form.Section = Class.extend({
		init: function(layout, df) {
			this.layout = layout;
			this.df = df || {};
			this.fields_list = [];
			this.fields_dict = {};

			this.make();
			// if(this.frm)
			// 	this.section.body.css({"padding":"0px 3%"})
			this.row = {
				wrapper: this.wrapper
			};

			if (this.df.collapsible && this.df.fieldname !== '_form_dashboard') {
				this.collapse(true);
			}

			this.refresh();
		},
		make: function() {
			if(!this.layout.page) {
				this.layout.page = $('<div class="form-page"></div>').appendTo(this.layout.wrapper);
			}

			this.wrapper = $('<div class="row form-section">')
				.appendTo(this.layout.page);
			this.layout.sections.push(this);

			if(this.df) {
				if(this.df.label) {
					this.make_head();
				}
				if(this.df.description) {
					$('<div class="col-sm-12 small text-muted form-section-description">' + __(this.df.description) + '</div>')
						.appendTo(this.wrapper);
				}
				if(this.df.cssClass) {
					this.wrapper.addClass(this.df.cssClass);
				}
			}


			// for bc
			this.body = $('<div class="section-body">').appendTo(this.wrapper);
		},
		make_head: function() {
			var me = this;
			if(!this.df.collapsible) {
				$('<div class="col-sm-12"><h6 class="form-section-heading uppercase">'
					+ __(this.df.label) + '</h6></div>')
					.appendTo(this.wrapper);
			} else {
				this.head = $('<div class="section-head"><a class="h6 uppercase">'
					+__(this.df.label)+'</a><span class="octicon octicon-chevron-down collapse-indicator"></span></div>').appendTo(this.wrapper);

				// show / hide based on status
				this.collapse_link = this.head.on("click", function() {
					me.collapse();
				});

				this.indicator = this.head.find(".collapse-indicator");
			}
		},
		refresh: function() {
			if(!this.df)
				{ return; }

			// hide if explictly hidden
			var hide = this.df.hidden || this.df.hidden_due_to_dependency;

			// hide if no perm
			if(!hide && this.layout && this.layout.frm && !this.layout.frm.get_perm(this.df.permlevel || 0, "read")) {
				hide = true;
			}

			this.wrapper.toggleClass("hide-control", !!hide);
		},
		collapse: function(hide) {
			// unknown edge case
			if (!(this.head && this.body)) {
				return;
			}

			if(hide===undefined) {
				hide = !this.body.hasClass("hide");
			}

			if (this.df.fieldname==='_form_dashboard') {
				localStorage.setItem('collapseFormDashboard', hide ? 'yes' : 'no');
			}

			this.body.toggleClass("hide", hide);
			this.head.toggleClass("collapsed", hide);
			this.indicator.toggleClass("octicon-chevron-down", hide);
			this.indicator.toggleClass("octicon-chevron-up", !hide);

			// refresh signature fields
			this.fields_list.forEach(function (f) {
				if (f.df.fieldtype=='Signature') {
					f.refresh();
				}
			});


		},
		has_missing_mandatory: function() {
			var missing_mandatory = false;
			for (var j=0, l=this.fields_list.length; j < l; j++) {
				var section_df = this.fields_list[j].df;
				if (section_df.reqd && this.layout.doc[section_df.fieldname]==null) {
					missing_mandatory = true;
					break;
				}
			}
			return missing_mandatory;
		}
	});

	frappe.ui.form.Column = Class.extend({
		init: function(section, df) {
			if(!df) { df = {}; }

			this.df = df;
			this.section = section;
			this.make();
			this.resize_all_columns();
		},
		make: function() {
			this.wrapper = $('<div class="form-column">\
			<form>\
			</form>\
		</div>').appendTo(this.section.body)
				.find("form")
				.on("submit", function() {
					return false;
				});

			if (this.df.label) {
				$('<label class="control-label">' + __(this.df.label)
					+ '</label>').appendTo(this.wrapper);
			}
		},
		resize_all_columns: function() {
			// distribute all columns equally
			var colspan = cint(12 / this.section.wrapper.find(".form-column").length);

			this.section.wrapper.find(".form-column").removeClass()
				.addClass("form-column")
				.addClass("col-sm-" + colspan);

		},
		refresh: function() {
			this.section.refresh();
		}
	});

	frappe.provide('frappe.ui');

	frappe.ui.FieldGroup = frappe.ui.form.Layout.extend({
		init: function(opts) {
			$.extend(this, opts);
			this.dirty = false;
			this._super();
			$.each(this.fields || [], function(i, f) {
				if(!f.fieldname && f.label) {
					f.fieldname = f.label.replace(/ /g, "_").toLowerCase();
				}
			});
			if(this.values) {
				this.set_values(this.values);
			}
		},
		make: function() {
			var this$1 = this;

			var me = this;
			if(this.fields) {
				this._super();
				this.refresh();
				// set default
				$.each(this.fields_list, function(i, field) {
					if (field.df["default"]) {
						var def_value = field.df["default"];

						if (def_value == 'Today' && field.df["fieldtype"] == 'Date') {
							def_value = frappe.datetime.get_today();
						}

						field.set_input(def_value);
						// if default and has depends_on, render its fields.
						me.refresh_dependency();
					}
				});

				if(!this.no_submit_on_enter) {
					this.catch_enter_as_submit();
				}

				$(this.wrapper).find('input, select').on('change', function () {
					this$1.dirty = true;

					frappe.run_serially([
						function () { return frappe.timeout(0.1); },
						function () { return me.refresh_dependency(); }
					]);
				});

			}
		},
		first_button: false,
		focus_on_first_input: function() {
			if(this.no_focus) { return; }
			$.each(this.fields_list, function(i, f) {
				if(!in_list(['Date', 'Datetime', 'Time', 'Check'], f.df.fieldtype) && f.set_focus) {
					f.set_focus();
					return false;
				}
			});
		},
		catch_enter_as_submit: function() {
			var me = this;
			$(this.body).find('input[type="text"], input[type="password"]').keypress(function(e) {
				if(e.which==13) {
					if(me.has_primary_action) {
						e.preventDefault();
						me.get_primary_btn().trigger("click");
					}
				}
			});
		},
		get_input: function(fieldname) {
			var field = this.fields_dict[fieldname];
			return $(field.txt ? field.txt : field.input);
		},
		get_field: function(fieldname) {
			return this.fields_dict[fieldname];
		},
		get_values: function(ignore_errors) {
			var ret = {};
			var errors = [];
			for(var key in this.fields_dict) {
				var f = this.fields_dict[key];
				if(f.get_value) {
					var v = f.get_value();
					if(f.df.reqd && is_null(v))
						{ errors.push(__(f.df.label)); }

					if(!is_null(v)) { ret[f.df.fieldname] = v; }
				}
			}
			if(errors.length && !ignore_errors) {
				frappe.msgprint({
					title: __('Missing Values Required'),
					message: __('Following fields have missing values:') +
						'<br><br><ul><li>' + errors.join('<li>') + '</ul>',
					indicator: 'orange'
				});
				return null;
			}
			return ret;
		},
		get_value: function(key) {
			var f = this.fields_dict[key];
			return f && (f.get_value ? f.get_value() : null);
		},
		set_value: function(key, val){
			var this$1 = this;

			return new Promise(function (resolve) {
				var f = this$1.fields_dict[key];
				if(f) {
					f.set_value(val).then(function () {
						f.set_input(val);
						this$1.refresh_dependency();
						resolve();
					});
				} else {
					resolve();
				}
			});
		},
		set_input: function(key, val) {
			return this.set_value(key, val);
		},
		set_values: function(dict) {
			for(var key in dict) {
				if(this.fields_dict[key]) {
					this.set_value(key, dict[key]);
				}
			}
		},
		clear: function() {
			for(var key in this.fields_dict) {
				var f = this.fields_dict[key];
				if(f && f.set_input) {
					f.set_input(f.df['default'] || '');
				}
			}
		},
		set_df_property: function (fieldname, prop, value) {
			var field    = this.get_field(fieldname);
			field.df[prop] = value;
			field.refresh();
		}
	});

	frappe.provide('frappe.ui');

	window.cur_dialog = null;

	frappe.ui.open_dialogs = [];

	frappe.ui.Dialog = class Dialog extends frappe.ui.FieldGroup {
		constructor(opts) {
			super();
			this.display = false;
			this.is_dialog = true;

			$.extend(this, { animate: true, size: null }, opts);
			this.make();
		}

		make() {
			var this$1 = this;

			this.$wrapper = frappe.get_modal("", "");

			if(this.static) {
				this.$wrapper.modal({
					backdrop: 'static',
					keyboard: false
				});
				this.get_close_btn().hide();
			}

			this.wrapper = this.$wrapper.find('.modal-dialog')
				.get(0);
			if ( this.size == "small" )
				{ $(this.wrapper).addClass("modal-sm"); }
			else if ( this.size == "large" )
				{ $(this.wrapper).addClass("modal-lg"); }

			this.make_head();
			this.modal_body = this.$wrapper.find(".modal-body");
			this.$body = $('<div></div>').appendTo(this.modal_body);
			this.body = this.$body.get(0);
			this.$message = $('<div class="hide modal-message"></div>').appendTo(this.modal_body);
			this.header = this.$wrapper.find(".modal-header");

			// make fields (if any)
			super.make();

			// show footer
			this.action = this.action || { primary: { }, secondary: { } };
			if(this.primary_action || (this.action.primary && this.action.primary.onsubmit)) {
				this.set_primary_action(this.primary_action_label || this.action.primary.label || __("Submit"),
					this.primary_action || this.action.primary.onsubmit);
			}

			if(this.secondary_action) {
				this.set_secondary_action(this.secondary_action);
			}

			if (this.secondary_action_label || (this.action.secondary && this.action.secondary.label)) {
				this.get_close_btn().html(this.secondary_action_label || this.action.secondary.label);
			}

			if (this.minimizable) {
				this.header.find('.modal-title').click(function () { return this$1.toggle_minimize(); });
				this.get_minimize_btn().removeClass('hide').on('click', function () { return this$1.toggle_minimize(); });
			}

			var me = this;
			this.$wrapper
				.on("hide.bs.modal", function() {
					me.display = false;
					me.secondary_action && me.secondary_action();

					if(frappe.ui.open_dialogs[frappe.ui.open_dialogs.length-1]===me) {
						frappe.ui.open_dialogs.pop();
						if(frappe.ui.open_dialogs.length) {
							window.cur_dialog = frappe.ui.open_dialogs[frappe.ui.open_dialogs.length-1];
						} else {
							window.cur_dialog = null;
						}
					}
					me.onhide && me.onhide();
					me.on_hide && me.on_hide();
				})
				.on("shown.bs.modal", function() {
					// focus on first input
					me.display = true;
					window.cur_dialog = me;
					frappe.ui.open_dialogs.push(me);
					me.focus_on_first_input();
					me.on_page_show && me.on_page_show();
					$(document).trigger('frappe.ui.Dialog:shown');
				})
				.on('scroll', function() {
					var $input = $('input:focus');
					if($input.length && ['Date', 'Datetime',
						'Time'].includes($input.attr('data-fieldtype'))) {
						$input.blur();
					}
				});

		}

		get_primary_btn() {
			return this.$wrapper.find(".modal-header .btn-primary");
		}

		get_minimize_btn() {
			return this.$wrapper.find(".modal-header .btn-modal-minimize");
		}

		set_message(text) {
			this.$message.removeClass('hide');
			this.$body.addClass('hide');
			this.$message.text(text);
		}

		clear_message() {
			this.$message.addClass('hide');
			this.$body.removeClass('hide');
		}

		clear() {
			super.clear();
			this.clear_message();
		}

		set_primary_action(label, click) {
			this.has_primary_action = true;
			var me = this;
			return this.get_primary_btn()
				.removeClass("hide")
				.html(label)
				.click(function() {
					me.primary_action_fulfilled = true;
					// get values and send it
					// as first parameter to click callback
					// if no values then return
					var values = me.get_values();
					if(!values) { return; }
					click && click.apply(me, [values]);
				});
		}

		set_secondary_action(click) {
			this.get_close_btn().on('click', click);
		}

		disable_primary_action() {
			this.get_primary_btn().addClass('disabled');
		}
		enable_primary_action() {
			this.get_primary_btn().removeClass('disabled');
		}
		make_head() {
			this.set_title(this.title);
		}
		set_title(t) {
			this.$wrapper.find(".modal-title").html(t);
		}
		show() {
			// show it
			if ( this.animate ) {
				this.$wrapper.addClass('fade');
			} else {
				this.$wrapper.removeClass('fade');
			}
			this.$wrapper.modal("show");

			// clear any message
			this.clear_message();

			this.primary_action_fulfilled = false;
			this.is_visible = true;
			return this;
		}
		hide() {
			this.$wrapper.modal("hide");
			this.is_visible = false;
		}
		get_close_btn() {
			return this.$wrapper.find(".btn-modal-close");
		}
		no_cancel() {
			this.get_close_btn().toggle(false);
		}
		cancel() {
			this.get_close_btn().trigger("click");
		}
		toggle_minimize() {
			var modal = this.$wrapper.closest('.modal').toggleClass('modal-minimize');
			modal.attr('tabindex') ? modal.removeAttr('tabindex') : modal.attr('tabindex', -1);
			this.get_minimize_btn().find('i').toggleClass('octicon-chevron-down').toggleClass('octicon-chevron-up');
			this.is_minimized = !this.is_minimized;
			this.on_minimize_toggle && this.on_minimize_toggle(this.is_minimized);
			this.header.find('.modal-title').toggleClass('cursor-pointer');
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.messages");

	frappe.messages.waiting = function(parent, msg) {
		return $(frappe.messages.get_waiting_message(msg))
			.appendTo(parent);
	};

	frappe.messages.get_waiting_message = function(msg) {
		return repl('<div class="msg-box" style="width: 63%; margin: 30px auto;">\
		<p class="text-center">%(msg)s</p></div>', { msg: msg });
	};

	frappe.throw = function(msg) {
		if(typeof msg==='string') {
			msg = {message: msg, title: __('Error')};
		}
		if(!msg.indicator) { msg.indicator = 'red'; }
		frappe.msgprint(msg);
		throw new Error(msg.message);
	};

	frappe.confirm = function(message, ifyes, ifno) {
		var d = new frappe.ui.Dialog({
			title: __("Confirm"),
			fields: [
				{fieldtype:"HTML", options:("<p class=\"frappe-confirm-message\">" + message + "</p>")}
			],
			primary_action_label: __("Yes"),
			primary_action: function() {
				if(ifyes) { ifyes(); }
				d.hide();
			},
			secondary_action_label: __("No")
		});
		d.show();

		// flag, used to bind "okay" on enter
		d.confirm_dialog = true;

		// no if closed without primary action
		if(ifno) {
			d.onhide = function() {
				if(!d.primary_action_fulfilled) {
					ifno();
				}
			};
		}
		return d;
	};

	frappe.prompt = function(fields, callback, title, primary_label) {
		if (typeof fields === "string") {
			fields = [{
				label: fields,
				fieldname: "value",
				fieldtype: "Data",
				reqd: 1
			}];
		}
		if(!$.isArray(fields)) { fields = [fields]; }
		var d = new frappe.ui.Dialog({
			fields: fields,
			title: title || __("Enter Value"),
		});
		d.set_primary_action(primary_label || __("Submit"), function() {
			var values = d.get_values();
			if(!values) {
				return;
			}
			d.hide();
			callback(values);
		});
		d.show();
		return d;
	};

	frappe.msgprint = function(msg, title) {
		if(!msg) { return; }

		if($.isPlainObject(msg)) {
			var data = msg;
		} else {
			// passed as JSON
			if(typeof msg==='string' && msg.substr(0,1)==='{') {
				var data = JSON.parse(msg);
			} else {
				var data = {'message': msg, 'title': title};
			}
		}

		if(!data.indicator) {
			data.indicator = 'blue';
		}

		if(data.message instanceof Array) {
			data.message.forEach(function(m) {
				frappe.msgprint(m);
			});
			return;
		}

		if(data.alert) {
			frappe.show_alert(data);
			return;
		}

		if(!frappe.msg_dialog) {
			frappe.msg_dialog = new frappe.ui.Dialog({
				title: __("Message"),
				onhide: function() {
					if(frappe.msg_dialog.custom_onhide) {
						frappe.msg_dialog.custom_onhide();
					}
					frappe.msg_dialog.msg_area.empty();
				}
			});

			// setup and bind an action to the primary button
			if (data.primary_action) {
				frappe.msg_dialog.set_primary_action(__(data.primary_action.label || "Done"),
					data.primary_action.action);
			}

			// class "msgprint" is used in tests
			frappe.msg_dialog.msg_area = $('<div class="msgprint">')
				.appendTo(frappe.msg_dialog.body);

			frappe.msg_dialog.clear = function() {
				frappe.msg_dialog.msg_area.empty();
			};

			frappe.msg_dialog.indicator = frappe.msg_dialog.header.find('.indicator');
		}

		if(data.message==null) {
			data.message = '';
		}

		if(data.message.search(/<br>|<p>|<li>/)==-1) {
			msg = frappe.utils.replace_newlines(data.message);
		}

		var msg_exists = false;
		if(data.clear) {
			frappe.msg_dialog.msg_area.empty();
		} else {
			msg_exists = frappe.msg_dialog.msg_area.html();
		}

		if(data.title || !msg_exists) {
			// set title only if it is explicitly given
			// and no existing title exists
			frappe.msg_dialog.set_title(data.title || __('Message'));
		}

		// show / hide indicator
		if(data.indicator) {
			frappe.msg_dialog.indicator.removeClass().addClass('indicator ' + data.indicator);
		} else {
			frappe.msg_dialog.indicator.removeClass().addClass('hidden');
		}

		// width
		if (data.wide) {
			// msgprint should be narrower than the usual dialog
			if (frappe.msg_dialog.wrapper.classList.contains('msgprint-dialog')) {
				frappe.msg_dialog.wrapper.classList.remove('msgprint-dialog');
			}
		} else {
			// msgprint should be narrower than the usual dialog
			frappe.msg_dialog.wrapper.classList.add('msgprint-dialog');
		}


		if(msg_exists) {
			frappe.msg_dialog.msg_area.append("<hr>");
		// append a <hr> if another msg already exists
		}

		frappe.msg_dialog.msg_area.append(data.message);

		// make msgprint always appear on top
		frappe.msg_dialog.$wrapper.css("z-index", 2000);
		frappe.msg_dialog.show();

		return frappe.msg_dialog;
	};

	window.msgprint = frappe.msgprint;

	frappe.hide_msgprint = function(instant) {
		// clear msgprint
		if(frappe.msg_dialog && frappe.msg_dialog.msg_area) {
			frappe.msg_dialog.msg_area.empty();
		}
		if(frappe.msg_dialog && frappe.msg_dialog.$wrapper.is(":visible")) {
			if(instant) {
				frappe.msg_dialog.$wrapper.removeClass("fade");
			}
			frappe.msg_dialog.hide();
			if(instant) {
				frappe.msg_dialog.$wrapper.addClass("fade");
			}
		}
	};

	// update html in existing msgprint
	frappe.update_msgprint = function(html) {
		if(!frappe.msg_dialog || (frappe.msg_dialog && !frappe.msg_dialog.$wrapper.is(":visible"))) {
			frappe.msgprint(html);
		} else {
			frappe.msg_dialog.msg_area.html(html);
		}
	};

	frappe.verify_password = function(callback) {
		frappe.prompt({
			fieldname: "password",
			label: __("Enter your password"),
			fieldtype: "Password",
			reqd: 1
		}, function(data) {
			frappe.call({
				method: "frappe.core.doctype.user.user.verify_password",
				args: {
					password: data.password
				},
				callback: function(r) {
					if(!r.exc) {
						callback();
					}
				}
			});
		}, __("Verify Password"), __("Verify"));
	};

	frappe.show_progress = function(title, count, total, description) {
		if ( total === void 0 ) total=100;

		if(frappe.cur_progress && frappe.cur_progress.title === title && frappe.cur_progress.is_visible) {
			var dialog = frappe.cur_progress;
		} else {
			var dialog = new frappe.ui.Dialog({
				title: title,
			});
			dialog.progress = $("<div>\n\t\t\t<div class=\"progress\">\n\t\t\t\t<div class=\"progress-bar\"></div>\n\t\t\t</div>\n\t\t\t<p class=\"description text-muted small\"></p>\n\t\t</div").appendTo(dialog.body);
			dialog.progress_bar = dialog.progress.css({"margin-top": "10px"})
				.find(".progress-bar");
			dialog.$wrapper.removeClass("fade");
			dialog.show();
			frappe.cur_progress = dialog;
		}
		if (description) {
			dialog.progress.find('.description').text(description);
		}
		dialog.percent = cint(flt(count) * 100 / total);
		dialog.progress_bar.css({"width": dialog.percent + "%" });
		return dialog;
	};

	frappe.hide_progress = function() {
		if(frappe.cur_progress) {
			frappe.cur_progress.hide();
			frappe.cur_progress = null;
		}
	};

	// Floating Message
	frappe.show_alert = function(message, seconds, actions) {
		if ( seconds === void 0 ) seconds=7;
		if ( actions === void 0 ) actions={};

		if(typeof message==='string') {
			message = {
				message: message
			};
		}
		if(!$('#dialog-container').length) {
			$('<div id="dialog-container"><div id="alert-container"></div></div>').appendTo('body');
		}

		var body_html;

		if (message.body) {
			body_html = message.body;
		}

		var div = $("\n\t\t<div class=\"alert desk-alert\">\n\t\t\t<div class=\"alert-message small\"></div>\n\t\t\t<div class=\"alert-body\" style=\"display: none\"></div>\n\t\t\t<a class=\"close\">&times;</a>\n\t\t</div>");

		if(message.indicator) {
			div.find('.alert-message').append(("<span class=\"indicator " + (message.indicator) + "\"></span>"));
		}

		div.find('.alert-message').append(message.message);

		if (body_html) {
			div.find('.alert-body').show().html(body_html);
		}

		div.hide().appendTo("#alert-container").show()
			.css('transform', 'translateX(0)');

		div.find('.close, button').click(function() {
			div.remove();
			return false;
		});

		Object.keys(actions).map(function (key) {
			div.find(("[data-action=" + key + "]")).on('click', actions[key]);
		});

		div.delay(seconds * 1000).fadeOut(300);
		return div;
	};

	// Proxy for frappe.show_alert
	Object.defineProperty(window, 'show_alert', {
		get: function() {
			console.warn('Please use `frappe.show_alert` instead of `show_alert`. It will be deprecated soon.');
			return frappe.show_alert;
		}
	});

	frappe.provide('frappe.ui.keys.handlers');

	frappe.ui.keys.setup = function() {
		$(window).on('keydown', function(e) {
			var key = frappe.ui.keys.get_key(e);
			if(frappe.ui.keys.handlers[key]) {
				var out = null;
				for(var i=0, l = frappe.ui.keys.handlers[key].length; i<l; i++) {
					var handler = frappe.ui.keys.handlers[key][i];
					var _out = handler.apply(this, [e]);
					if(_out===false) {
						out = _out;
					}
				}
				return out;
			}
		});
	};

	frappe.ui.keys.get_key = function(e) {
		var keycode = e.keyCode || e.which;
		var key = frappe.ui.keys.key_map[keycode] || String.fromCharCode(keycode);

		if(e.ctrlKey || e.metaKey) {
			// add ctrl+ the key
			key = 'ctrl+' + key;
		}
		if(e.shiftKey) {
			// add ctrl+ the key
			key = 'shift+' + key;
		}
		if (e.altKey) {
			// add alt+ the key
			key = 'alt+' + key;
		}
		if (e.altKey && e.ctrlKey) {
			// add alt+ctrl+ the key or single key e.g f1,f2,etc..
			return key.toLowerCase();
		}
		return key.toLowerCase();
	};

	frappe.ui.keys.on = function(key, handler) {
		if(!frappe.ui.keys.handlers[key]) {
			frappe.ui.keys.handlers[key] = [];
		}
		frappe.ui.keys.handlers[key].push(handler);
	};

	frappe.ui.keys.on('ctrl+s', function(e) {
		frappe.app.trigger_primary_action();
		e.preventDefault();
		return false;
	});

	frappe.ui.keys.on('ctrl+g', function(e) {
		$("#navbar-search").focus();
		e.preventDefault();
		return false;
	});

	frappe.ui.keys.on('ctrl+b', function(e) {
		var route = frappe.get_route();
		if(route[0]==='Form' || route[0]==='List') {
			frappe.new_doc(route[1], true);
			e.preventDefault();
			return false;
		}
	});

	frappe.ui.keys.on('escape', function(e) {
		close_grid_and_dialog();
	});

	frappe.ui.keys.on('esc', function(e) {
		close_grid_and_dialog();
	});

	frappe.ui.keys.on('enter', function(e) {
		if(window.cur_dialog && cur_dialog.confirm_dialog) {
			cur_dialog.get_primary_btn().trigger('click');
		}
	});

	frappe.ui.keys.on('ctrl+down', function(e) {
		var grid_row = frappe.ui.form.get_open_grid_form();
		grid_row && grid_row.toggle_view(false, function() { grid_row.open_next(); });
	});

	frappe.ui.keys.on('ctrl+up', function(e) {
		var grid_row = frappe.ui.form.get_open_grid_form();
		grid_row && grid_row.toggle_view(false, function() { grid_row.open_prev(); });
	});

	frappe.ui.keys.on('shift+ctrl+r', function(e) {
		frappe.ui.toolbar.clear_cache();
	});

	frappe.ui.keys.key_map = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'ctrl',
		91: 'meta',
		18: 'alt',
		27: 'escape',
		37: 'left',
		39: 'right',
		38: 'up',
		40: 'down',
		32: 'space',
		112: 'f1',
		113: 'f2',
		114: 'f3',
		115: 'f4',
		116: 'f5'
	};

	// keyCode map
	frappe.ui.keyCode = {
		ESCAPE: 27,
		LEFT: 37,
		RIGHT: 39,
		UP: 38,
		DOWN: 40,
		ENTER: 13,
		TAB: 9,
		SPACE: 32,
		BACKSPACE: 8
	};

	function close_grid_and_dialog() {
		// close open grid row
		var open_row = $(".grid-row-open");
		if (open_row.length) {
			var grid_row = open_row.data("grid_row");
			grid_row.toggle_view(false);
			return false;
		}

		// close open dialog
		if (cur_dialog && !cur_dialog.no_cancel_flag) {
			cur_dialog.cancel();
			return false;
		}
	}

	// Copyright (c) 2017, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.ui");

	frappe.ui.color_map = {
		red: ["#ffc4c4", "#ff8989", "#ff4d4d", "#a83333"],
		brown: ["#ffe8cd", "#ffd19c", "#ffb868", "#a87945"],
		orange: ["#ffd2c2", "#ffa685", "#ff7846", "#a85b5b"],
		peach: ["#ffd7d7", "#ffb1b1", "#ff8989", "#a84f2e"],
		yellow: ["#fffacd", "#fff168", "#fff69c", "#a89f45"],
		yellowgreen: ["#ebf8cc", "#d9f399", "#c5ec63", "#7b933d"],
		green: ["#cef6d1", "#9deca2", "#6be273", "#428b46"],
		cyan: ["#d2f8ed", "#a4f3dd", "#77ecca", "#49937e"],
		skyblue: ["#d2f1ff", "#a6e4ff", "#78d6ff", "#4f8ea8"],
		blue: ["#d2d2ff", "#a3a3ff", "#7575ff", "#4d4da8"],
		purple: ["#dac7ff", "#b592ff", "#8e58ff", "#5e3aa8"],
		pink: ["#f8d4f8", "#f3aaf0", "#ec7dea", "#934f92"],
		white: ["#d1d8dd", "#fafbfc", "#ffffff", ""],
		black: ["#8D99A6", "#6c7680", "#36414c", "#212a33"]
	};

	frappe.ui.color = {
		get: function(color_name, shade) {
			if(color_name && shade) { return this.get_color_shade(color_name, shade); }
			if(color_name) { return this.get_color_shade(color_name, 'default'); }
			return frappe.ui.color_map;
		},
		get_color: function(color_name) {
			var color_names = Object.keys(frappe.ui.color_map);
			if(color_names.includes(color_name)) {
				return frappe.ui.color_map[color_name];
			} else {
				// eslint-disable-next-line
				console.warn(("'color_name' can be one of " + color_names + " and not " + color_name));
			}
		},
		get_color_shade: function(color_name, shade) {
			var shades = {
				'default': 2,
				'light': 1,
				'extra-light': 0,
				'dark': 3
			};

			if(Object.keys(shades).includes(shade)) {
				return frappe.ui.color_map[color_name][shades[shade]];
			} else {
				// eslint-disable-next-line
				console.warn(("'shade' can be one of " + (Object.keys(shades)) + " and not " + shade));
			}
		},
		all: function() {
			return Object.values(frappe.ui.color_map)
				.reduce(function (acc, curr) { return acc.concat(curr); } , []);
		},
		names: function() {
			return Object.keys(frappe.ui.color_map);
		},
		is_standard: function(color_name) {
			if(!color_name) { return false; }
			if(color_name.startsWith('#')) {
				return this.all().includes(color_name);
			}
			return this.names().includes(color_name);
		},
		get_color_name: function(hex) {
			for (var key in frappe.ui.color_map) {
				var colors = frappe.ui.color_map[key];
				if (colors.includes(hex)) { return key; }
			}
		},
		get_contrast_color: function(hex) {
			if(!this.validate_hex(hex)) {
				return;
			}
			if(!this.is_standard(hex)) {
				var brightness = this.brightness(hex);
				if(brightness < 128) {
					return this.lighten(hex, 0.5);
				}
				return this.lighten(hex, -0.5);
			}

			var color_name = this.get_color_name(hex);
			var colors = this.get_color(color_name);
			var shade_value = colors.indexOf(hex);
			if(shade_value <= 1) {
				return this.get(color_name, 'dark');
			}
			return this.get(color_name, 'extra-light');
		},

		validate_hex: function(hex) {
			// https://stackoverflow.com/a/8027444/5353542
			return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
		},

		lighten: function lighten(color, percent) {
			// https://stackoverflow.com/a/13542669/5353542
			var f = parseInt(color.slice(1), 16),
				t = percent < 0 ? 0 : 255,
				p = percent < 0 ? percent * -1 : percent,
				R = f >> 16,
				G = f >> 8 & 0x00FF,
				B = f & 0x0000FF;
			return "#" +
				(0x1000000 +
					(Math.round((t - R) * p) + R) *
					0x10000 +
					(Math.round((t - G) * p) + G) *
					0x100 + (Math.round((t - B) * p) + B)
				).toString(16).slice(1);
		},

		hex_to_rgb: function hex_to_rgb(hex) {
			if(hex.startsWith('#')) {
				hex = hex.substring(1);
			}
			var r = parseInt(hex.substring(0, 2), 16);
			var g = parseInt(hex.substring(2, 4), 16);
			var b = parseInt(hex.substring(4, 6), 16);
			return {r: r, g: g, b: b};
		},

		brightness: function brightness(hex) {
			var rgb = this.hex_to_rgb(hex);
			// https://www.w3.org/TR/AERT#color-contrast
			// 255 - brightest (#fff)
			// 0 - darkest (#000)
			return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
		}
	};

	frappe.provide('frappe.ui');

	frappe.ui.Sidebar = class Sidebar {
		constructor(ref) {
		var wrapper = ref.wrapper;
		var css_class = ref.css_class;

			this.wrapper = wrapper;
			this.css_class = css_class;
			this.items = {};
			this.make_dom();
		}

		make_dom() {
			this.wrapper.html(("\n\t\t\t<div class=\"" + (this.css_class) + " overlay-sidebar hidden-xs hidden-sm\">\n\t\t\t</div>\n\t\t"));

			this.$sidebar = this.wrapper.find('.' + this.css_class);
		}

		add_item(item, section, h6) {
			if ( h6 === void 0 ) h6=false;

			var $section, $li_item;
			if(!section && this.wrapper.find('.sidebar-menu').length === 0) {
				// if no section, add section with no heading
				$section = this.get_section();
			} else {
				$section = this.get_section(section);
			}

			if(item instanceof jQuery) {
				$li_item = $("<li>");
				item.appendTo($li_item);
			} else {
				var className = h6 ? 'h6' : '';
				var html = "<li class=" + className + ">\n\t\t\t\t<a " + (item.href ? ("href=\"" + (item.href) + "\"") : '') + ">" + (item.label) + "</a>\n\t\t\t</li>";
				$li_item = $(html).click(
					function () { return item.on_click && item.on_click(); }
				);
			}

			$section.append($li_item);

			if(item.name) {
				this.items[item.name] = $li_item;
			}
		}

		remove_item(name) {
			if(this.items[name]) {
				this.items[name].remove();
			}
		}

		get_section(section_heading) {
			if ( section_heading === void 0 ) section_heading="";

			var $section = $(this.wrapper.find(
				("[data-section-heading=\"" + section_heading + "\"]")));
			if($section.length) {
				return $section;
			}

			var $section_heading = section_heading ?
				("<li class=\"h6\">" + section_heading + "</li>") : '';

			$section = $(("\n\t\t\t<ul class=\"list-unstyled sidebar-menu\" data-section-heading=\"" + (section_heading || 'default') + "\">\n\t\t\t\t" + $section_heading + "\n\t\t\t</ul>\n\t\t"));

			this.$sidebar.append($section);
			return $section;
		}
	};

	frappe.ui.LinkPreview = class {

		constructor() {
			this.$links = [];
			this.LINK_CLASSES = 'a[data-doctype], input[data-fieldtype="Link"], .popover';
			this.popover_timeout = null;
			this.setup_events();
		}

		setup_events() {
			var this$1 = this;

			$(document.body).on('mouseover', this.LINK_CLASSES, function (e) {
				this$1.link_hovered = true;
				this$1.element = $(e.currentTarget);
				this$1.is_link = this$1.element.get(0).tagName.toLowerCase() === 'a';

				if(!this$1.element.parents().find('.popover').length) {
					this$1.identify_doc();
					this$1.popover = this$1.element.data("bs.popover");
					if(this$1.name && this$1.doctype) {
						this$1.setup_popover_control(e);
					}
				}
			});
			this.handle_popover_hide();

		}

		identify_doc() {
			if (this.is_link) {
				this.doctype = this.element.attr('data-doctype');
				this.name = this.element.attr('data-name');
				this.href = this.element.attr('href');
			} else {
				this.href = this.element.parents('.control-input-wrapper').find('.control-value a').attr('href');
				// input
				this.doctype = this.element.attr('data-target');
				this.name = this.element.val();
			}
		}

		setup_popover_control(e) {
			var this$1 = this;

			//If control field value is changed, new popover has to be created
			this.element.on('change',function (){
				this$1.new_popover = true;
			});
			if(!this.popover || this.new_popover) {
				this.get_preview_fields().then(function (preview_fields) {
					if(preview_fields.length) {
						this$1.data_timeout = setTimeout(function () {
							this$1.create_popover(e, preview_fields);
						}, 100);
					}
				});
			} else {
				this.popover_timeout = setTimeout(function () {
					if (this$1.element.is(':focus')) {
						return;
					}
					this$1.show_popover(e);
				}, 1000);
			}
		}

		create_popover(e, preview_fields) {
			var this$1 = this;

			this.new_popover = false;
			if (this.element.is(':focus')) {
				return;
			}

			this.get_preview_fields_value(preview_fields).then(function (preview_data){
				if(preview_data) {
					if(this$1.popover_timeout) {
						clearTimeout(this$1.popover_timeout);
					}

					this$1.popover_timeout = setTimeout(function () {
						if(this$1.popover) {
							var new_content = this$1.get_popover_html(preview_data);
							this$1.popover.options.content = new_content;
						} else {
							this$1.init_preview_popover(preview_data);
						}
						this$1.show_popover(e);

					}, 1000);
				}
			});
		}

		show_popover(e) {
			var this$1 = this;


			this.default_timeout = setTimeout(function (){
				this$1.clear_all_popovers();
			}, 10000);

			if(!this.is_link) {
				var left = e.pageX;
				this.element.popover('show');
				var width = $('.popover').width();
				$('.control-field-popover').css('left', (left-(width/2)) + 'px');
			} else {
				this.element.popover('show');
			}
		}

		handle_popover_hide() {
			var this$1 = this;

			$(document.body).on('mouseout', this.LINK_CLASSES, function () {
				// To allow popover to be hovered on
				if (!$('.popover:hover').length) {
					this$1.link_hovered = false;
				}
				if(!this$1.link_hovered) {
					if(this$1.data_timeout) {
						clearTimeout(this$1.data_timeout);
					}
					if (this$1.popover_timeout) {
						clearTimeout(this$1.popover_timeout);
					}
					if(this$1.default_timeout) {
						clearTimeout(this$1.default_timeout);
					}
					this$1.clear_all_popovers();
				}
			});

			$(window).on('hashchange', function () {
				this$1.clear_all_popovers();
			});
		}

		clear_all_popovers() {
			this.$links.forEach(function ($el) { return $el.popover('hide'); });
		}

		get_preview_fields() {
			var this$1 = this;

			return new Promise(function (resolve) {
				var dt = this$1.doctype;
				var fields = [];
				frappe.model.with_doctype(dt, function () {
					var meta = frappe.get_meta(dt);
					var meta_fields = meta.fields;

					if (!meta.show_preview_popup) {
						// no preview
						resolve([]);
						return;
					}

					meta_fields.filter(function (field) {
						// build list of fields to fetch
						if(field.in_preview) {
							fields.push({'name':field.fieldname,'type':field.fieldtype});
						}
					});

					// no preview fields defined, build list from mandatory fields
					if(!fields.length) {
						meta_fields.filter(function (field) {
							if(field.reqd) {
								fields.push({'name':field.fieldname,'type':field.fieldtype});
							}
						});
					}
					resolve(fields);
				});
			});
		}

		get_preview_fields_value(field_list) {
			return frappe.xcall('frappe.desk.link_preview.get_preview_data', {
				'doctype': this.doctype,
				'docname': this.name,
				'fields': field_list,
			});
		}

		init_preview_popover(preview_data) {
			var popover_content = this.get_popover_html(preview_data);
			this.element.popover({
				container: 'body',
				html: true,
				content: popover_content,
				trigger: 'manual',
				placement: 'top auto',
				animation: false,
			});

			var $popover = this.element.data('bs.popover').tip();

			$popover.addClass('link-preview-popover');
			$popover.toggleClass('control-field-popover', this.is_link);

			this.$links.push(this.element);

		}

		get_popover_html(preview_data) {
			var this$1 = this;

			if(!this.href) {
				this.href = window.location.href;
			}

			if(this.href && this.href.includes(' ')) {
				this.href = this.href.replace(new RegExp(' ', 'g'), '%20');
			}

			var image_html = '';
			var id_html = '';
			var content_html = '';
			var meta = frappe.get_meta(this.doctype);
			var title = preview_data.title;

			if(preview_data[meta.image_field]) {
				var image_url = encodeURI(preview_data[meta.image_field]);
				image_html += "\n\t\t\t<div class=\"preview-header\">\n\t\t\t\t<img src=" + image_url + " class=\"preview-image\"></img>\n\t\t\t</div>";
			}


			if(title && title != preview_data.name) {
				id_html+= "<a class=\"text-muted\" href=" + (this.href) + ">" + (preview_data.name) + "</a>";
			}
			if(!title) {
				title = preview_data.name;
			}

			Object.keys(preview_data).forEach(function (key) {
				if(key!=meta.image_field && key!='name' && key!=meta.title_field) {
					var value = this$1.truncate_value(preview_data[key]);
					var label = this$1.truncate_value(frappe.meta.get_label(this$1.doctype, key));
					content_html += "\n\t\t\t\t<div class=\"preview-field\">\n\t\t\t\t\t<div class='small preview-label text-muted bold'>" + label + "</div>\n\t\t\t\t\t<div class=\"small preview-value\"> " + value + " </div>\n\t\t\t\t</div>\n\t\t\t\t";
				}
			});

			content_html = "<div class=\"preview-table\">" + content_html + "</div>";

			var popover_content =
				"<div class=\"preview-popover-header\">" + image_html + "\n\t\t\t\t<div class=\"preview-header\">\n\t\t\t\t\t<div class=\"preview-main\">\n\t\t\t\t\t\t<a class=\"preview-name bold\" href=" + (this.href) + ">" + title + "</a>\n\t\t\t\t\t\t<span class=\"text-muted small\">" + (this.doctype) + " " + id_html + "</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<hr>\n\t\t\t<div class=\"popover-body\">\n\t\t\t\t" + content_html + "\n\t\t\t</div>";

			return popover_content;
		}

		truncate_value(value) {
			if (value.length > 280) {
				value = value.slice(0,280) + '...';
			}
			return value;
		}

	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// My HTTP Request

	frappe.provide('frappe.request');
	frappe.request.url = '/';
	frappe.request.ajax_count = 0;
	frappe.request.waiting_for_ajax = [];

	frappe.xcall = function(method, params) {
		return new Promise(function (resolve, reject) {
			frappe.call({
				method: method,
				args: params,
				callback: function (r) {
					resolve(r.message);
				},
				error: function (r) {
					reject(r.message);
				}
			});
		});
	};

	// generic server call (call page, object)
	frappe.call = function(opts) {
		if (!frappe.is_online()) {
			frappe.show_alert({
				indicator: 'orange',
				message: __('You are not connected to Internet. Retry after sometime.')
			}, 3);
			opts.always && opts.always();
			return $.ajax();
		}
		if (typeof arguments[0]==='string') {
			opts = {
				method: arguments[0],
				args: arguments[1],
				callback: arguments[2],
				headers: arguments[3]
			};
		}

		if(opts.quiet) {
			opts.no_spinner = true;
		}
		var args = $.extend({}, opts.args);

		// cmd
		if(opts.module && opts.page) {
			args.cmd = opts.module+'.page.'+opts.page+'.'+opts.page+'.'+opts.method;
		} else if(opts.doc) {
			$.extend(args, {
				cmd: "runserverobj",
				docs: frappe.get_doc(opts.doc.doctype, opts.doc.name),
				method: opts.method,
				args: opts.args,
			});
		} else if(opts.method) {
			args.cmd = opts.method;
		}

		var callback = function(data, response_text) {
			if(data.task_id) {
				// async call, subscribe
				frappe.socketio.subscribe(data.task_id, opts);

				if(opts.queued) {
					opts.queued(data);
				}
			}
			else if (opts.callback) {
				// ajax
				return opts.callback(data, response_text);
			}
		};

		var url = opts.url;
		if (!url) {
			url = '/api/method/' + args.cmd;
			delete args.cmd;
		}

		return frappe.request.call({
			type: opts.type || "POST",
			args: args,
			success: callback,
			error: opts.error,
			always: opts.always,
			btn: opts.btn,
			freeze: opts.freeze,
			freeze_message: opts.freeze_message,
			headers: opts.headers || {},
			// show_spinner: !opts.no_spinner,
			async: opts.async,
			url: url,
		});
	};


	frappe.request.call = function(opts) {
		frappe.request.prepare(opts);

		var statusCode = {
			200: function(data, xhr) {
				opts.success_callback && opts.success_callback(data, xhr.responseText);
			},
			401: function(xhr) {
				if(frappe.app.session_expired_dialog && frappe.app.session_expired_dialog.display) {
					frappe.app.redirect_to_login();
				} else {
					frappe.app.handle_session_expired();
				}
			},
			404: function(xhr) {
				frappe.msgprint({title:__("Not found"), indicator:'red',
					message: __('The resource you are looking for is not available')});
			},
			403: function(xhr) {
				if (frappe.get_cookie('sid')==='Guest') {
					// session expired
					frappe.app.handle_session_expired();
				}
				else if(xhr.responseJSON && xhr.responseJSON._error_message) {
					frappe.msgprint({
						title:__("Not permitted"), indicator:'red',
						message: xhr.responseJSON._error_message
					});

					xhr.responseJSON._server_messages = null;
				}
				else if (xhr.responseJSON && xhr.responseJSON._server_messages) {
					var _server_messages = JSON.parse(xhr.responseJSON._server_messages);

					// avoid double messages
					if (_server_messages.indexOf(__("Not permitted"))!==-1) {
						return;
					}
				}
				else {
					frappe.msgprint({
						title:__("Not permitted"), indicator:'red',
						message: __('You do not have enough permissions to access this resource. Please contact your manager to get access.')});
				}


			},
			508: function(xhr) {
				frappe.utils.play_sound("error");
				frappe.msgprint({title:__('Please try again'), indicator:'red',
					message:__("Another transaction is blocking this one. Please try again in a few seconds.")});
			},
			413: function(data, xhr) {
				frappe.msgprint({indicator:'red', title:__('File too big'), message:__("File size exceeded the maximum allowed size of {0} MB",
					[(frappe.boot.max_file_size || 5242880) / 1048576])});
			},
			417: function(xhr) {
				var r = xhr.responseJSON;
				if (!r) {
					try {
						r = JSON.parse(xhr.responseText);
					} catch (e) {
						r = xhr.responseText;
					}
				}

				opts.error_callback && opts.error_callback(r);
			},
			501: function(data, xhr) {
				if(typeof data === "string") { data = JSON.parse(data); }
				opts.error_callback && opts.error_callback(data, xhr.responseText);
			},
			500: function(xhr) {
				frappe.utils.play_sound("error");
				try {
					opts.error_callback && opts.error_callback();
					frappe.request.report_error(xhr, opts);
				} catch (e) {
					frappe.request.report_error(xhr, opts);
				}
			},
			504: function(xhr) {
				frappe.msgprint(__("Request Timed Out"));
				opts.error_callback && opts.error_callback();
			},
			502: function(xhr) {
				frappe.msgprint(__("Internal Server Error"));
			}
		};

		var ajax_args = {
			url: opts.url || frappe.request.url,
			data: opts.args,
			type: opts.type,
			dataType: opts.dataType || 'json',
			async: opts.async,
			headers: Object.assign({
				"X-Frappe-CSRF-Token": frappe.csrf_token,
				"Accept": "application/json",
	 			"X-Frappe-CMD": (opts.args && opts.args.cmd  || '') || ''
			}, opts.headers),
			cache: false
		};

		if (opts.args && opts.args.doctype) {
			ajax_args.headers["X-Frappe-Doctype"] = opts.args.doctype;
		}

		frappe.last_request = ajax_args.data;

		return $.ajax(ajax_args)
			.done(function(data, textStatus, xhr) {
				try {
					if(typeof data === "string") { data = JSON.parse(data); }

					// sync attached docs
					if(data.docs || data.docinfo) {
						frappe.model.sync(data);
					}

					// sync translated messages
					if(data.__messages) {
						$.extend(frappe._messages, data.__messages);
					}

					// callbacks
					var status_code_handler = statusCode[xhr.statusCode().status];
					if (status_code_handler) {
						status_code_handler(data, xhr);
					}
				} catch(e) {
					console.log("Unable to handle success response"); // eslint-disable-line
					console.trace(e); // eslint-disable-line
				}

			})
			.always(function(data, textStatus, xhr) {
				try {
					if(typeof data==="string") {
						data = JSON.parse(data);
					}
					if(data.responseText) {
						var xhr = data;
						data = JSON.parse(data.responseText);
					}
				} catch(e) {
					data = null;
					// pass
				}
				frappe.request.cleanup(opts, data);
				if(opts.always) {
					opts.always(data);
				}
			})
			.fail(function(xhr, textStatus) {
				try {
					var status_code_handler = statusCode[xhr.statusCode().status];
					if (status_code_handler) {
						status_code_handler(xhr);
					} else {
						// if not handled by error handler!
						opts.error_callback && opts.error_callback(xhr);
					}
				} catch(e) {
					console.log("Unable to handle failed response"); // eslint-disable-line
					console.trace(e); // eslint-disable-line
				}
			});
	};

	// call execute serverside request
	frappe.request.prepare = function(opts) {
		$("body").attr("data-ajax-state", "triggered");

		// btn indicator
		if(opts.btn) { $(opts.btn).prop("disabled", true); }

		// freeze page
		if(opts.freeze) { frappe.dom.freeze(opts.freeze_message); }

		// stringify args if required
		for(var key in opts.args) {
			if(opts.args[key] && ($.isPlainObject(opts.args[key]) || $.isArray(opts.args[key]))) {
				opts.args[key] = JSON.stringify(opts.args[key]);
			}
		}

		// no cmd?
		if(!opts.args.cmd && !opts.url) {
			console.log(opts);
			throw "Incomplete Request";
		}

		opts.success_callback = opts.success;
		opts.error_callback = opts.error;
		delete opts.success;
		delete opts.error;

	};

	frappe.request.cleanup = function(opts, r) {
		// stop button indicator
		if(opts.btn) {
			$(opts.btn).prop("disabled", false);
		}

		$("body").attr("data-ajax-state", "complete");

		// un-freeze page
		if(opts.freeze) { frappe.dom.unfreeze(); }

		if(r) {

			// session expired? - Guest has no business here!
			if(r.session_expired || frappe.get_cookie("sid")==="Guest") {
				frappe.app.handle_session_expired();
				return;
			}

			// show messages
			if(r._server_messages && !opts.silent) {
				r._server_messages = JSON.parse(r._server_messages);
				frappe.hide_msgprint();
				frappe.msgprint(r._server_messages);
			}

			// show errors
			if(r.exc) {
				r.exc = JSON.parse(r.exc);
				if(r.exc instanceof Array) {
					$.each(r.exc, function(i, v) {
						if(v) {
							console.log(v);
						}
					});
				} else {
					console.log(r.exc);
				}
			}

			// debug messages
			if(r._debug_messages) {
				if(opts.args) {
					console.log("======== arguments ========");
					console.log(opts.args);
					console.log("========");
				}
				$.each(JSON.parse(r._debug_messages), function(i, v) { console.log(v); });
				console.log("======== response ========");
				delete r._debug_messages;
				console.log(r);
				console.log("========");
			}
		}

		frappe.last_response = r;
	};

	frappe.after_server_call = function () {
		if(frappe.request.ajax_count) {
			return new Promise(function (resolve) {
				frappe.request.waiting_for_ajax.push(function () {
					resolve();
				});
			});
		} else {
			return null;
		}
	};

	frappe.after_ajax = function(fn) {
		return new Promise(function (resolve) {
			if(frappe.request.ajax_count) {
				frappe.request.waiting_for_ajax.push(function () {
					if(fn) { fn(); }
					resolve();
				});
			} else {
				if(fn) { fn(); }
				resolve();
			}
		});
	};

	frappe.request.report_error = function(xhr, request_opts) {
		var data = JSON.parse(xhr.responseText);
		var exc;
		if (data.exc) {
			try {
				exc = (JSON.parse(data.exc) || []).join("\n");
			} catch (e) {
				exc = data.exc;
			}
			delete data.exc;
		} else {
			exc = "";
		}

		var show_communication = function() {
			var error_report_message = [
				'<h5>Please type some additional information that could help us reproduce this issue:</h5>',
				'<div style="min-height: 100px; border: 1px solid #bbb; \
				border-radius: 5px; padding: 15px; margin-bottom: 15px;"></div>',
				'<hr>',
				'<h5>App Versions</h5>',
				'<pre>' + JSON.stringify(frappe.boot.versions, null, "\t") + '</pre>',
				'<h5>Route</h5>',
				'<pre>' + frappe.get_route_str() + '</pre>',
				'<hr>',
				'<h5>Error Report</h5>',
				'<pre>' + exc + '</pre>',
				'<hr>',
				'<h5>Request Data</h5>',
				'<pre>' + JSON.stringify(request_opts, null, "\t") + '</pre>',
				'<hr>',
				'<h5>Response JSON</h5>',
				'<pre>' + JSON.stringify(data, null, '\t')+ '</pre>'
			].join("\n");

			var communication_composer = new frappe.views.CommunicationComposer({
				subject: 'Error Report [' + frappe.datetime.nowdate() + ']',
				recipients: error_report_email,
				message: error_report_message,
				doc: {
					doctype: "User",
					name: frappe.session.user
				}
			});
			communication_composer.dialog.$wrapper.css("z-index", cint(frappe.msg_dialog.$wrapper.css("z-index")) + 1);
		};

		if (exc) {
			var error_report_email = frappe.boot.error_report_email;

			request_opts = frappe.request.cleanup_request_opts(request_opts);

			// window.msg_dialog = frappe.msgprint({message:error_message, indicator:'red', big: true});

			if (!frappe.error_dialog) {
				frappe.error_dialog = new frappe.ui.Dialog({
					title: 'Server Error',
					primary_action_label: __('Report'),
					primary_action: function () {
						if (error_report_email) {
							show_communication();
						} else {
							frappe.msgprint(__('Support Email Address Not Specified'));
						}
						frappe.error_dialog.hide();
					}
				});
				frappe.error_dialog.wrapper.classList.add('msgprint-dialog');

			}

			var parts = strip(exc).split('\n');

			frappe.error_dialog.$body.html(parts[parts.length - 1]);
			frappe.error_dialog.show();

		}
	};

	frappe.request.cleanup_request_opts = function(request_opts) {
		var doc = (request_opts.args || {}).doc;
		if (doc) {
			doc = JSON.parse(doc);
			$.each(Object.keys(doc), function(i, key) {
				if (key.indexOf("password")!==-1 && doc[key]) {
					// mask the password
					doc[key] = "*****";
				}
			});
			request_opts.args.doc = JSON.stringify(doc);
		}
		return request_opts;
	};

	$(document).ajaxSend(function() {
		frappe.request.ajax_count++;
	});

	$(document).ajaxComplete(function() {
		frappe.request.ajax_count--;
		if(!frappe.request.ajax_count) {
			$.each(frappe.request.waiting_for_ajax || [], function(i, fn) {
				fn();
			});
			frappe.request.waiting_for_ajax = [];
		}
	});

	frappe.socketio = {
		open_tasks: {},
		open_docs: [],
		emit_queue: [],
		init: function(port) {
			if ( port === void 0 ) port = 3000;

			if (!window.io) {
				return;
			}

			if (frappe.boot.disable_async) {
				return;
			}

			if (frappe.socketio.socket) {
				return;
			}

			//Enable secure option when using HTTPS
			if (window.location.protocol == "https:") {
				frappe.socketio.socket = io.connect(frappe.socketio.get_host(port), {secure: true});
			}
			else if (window.location.protocol == "http:") {
				frappe.socketio.socket = io.connect(frappe.socketio.get_host(port));
			}
			else if (window.location.protocol == "file:") {
				frappe.socketio.socket = io.connect(window.localStorage.server);
			}

			if (!frappe.socketio.socket) {
				console.log("Unable to connect to " + frappe.socketio.get_host(port));
				return;
			}

			frappe.socketio.socket.on('msgprint', function(message) {
				frappe.msgprint(message);
			});

			frappe.socketio.socket.on('eval_js', function(message) {
				eval(message);
			});

			frappe.socketio.socket.on('progress', function(data) {
				if(data.progress) {
					data.percent = flt(data.progress[0]) / data.progress[1] * 100;
				}
				if(data.percent) {
					if(data.percent==100) {
						frappe.hide_progress();
					} else {
						frappe.show_progress(data.title || __("Progress"), data.percent, 100, data.description);
					}
				}
			});

			frappe.socketio.setup_listeners();
			frappe.socketio.setup_reconnect();
			frappe.socketio.uploader = new frappe.socketio.SocketIOUploader();

			$(document).on('form-load form-rename', function(e, frm) {
				if (frm.is_new()) {
					return;
				}

				for (var i=0, l=frappe.socketio.open_docs.length; i<l; i++) {
					var d = frappe.socketio.open_docs[i];
					if (frm.doctype==d.doctype && frm.docname==d.name) {
						// already subscribed
						return false;
					}
				}

				frappe.socketio.doc_subscribe(frm.doctype, frm.docname);
			});

			$(document).on("form-refresh", function(e, frm) {
				if (frm.is_new()) {
					return;
				}

				frappe.socketio.doc_open(frm.doctype, frm.docname);
			});

			$(document).on('form-unload', function(e, frm) {
				if (frm.is_new()) {
					return;
				}

				// frappe.socketio.doc_unsubscribe(frm.doctype, frm.docname);
				frappe.socketio.doc_close(frm.doctype, frm.docname);
			});

			window.onbeforeunload = function() {
				if (!cur_frm || cur_frm.is_new()) {
					return;
				}

				// if tab/window is closed, notify other users
				if (cur_frm.doc) {
					frappe.socketio.doc_close(cur_frm.doctype, cur_frm.docname);
				}
			};
		},
		get_host: function(port) {
			if ( port === void 0 ) port = 3000;

			var host = window.location.origin;
			if(window.dev_server) {
				var parts = host.split(":");
				port = frappe.boot.socketio_port || port.toString() || '3000';
				if(parts.length > 2) {
					host = parts[0] + ":" + parts[1];
				}
				host = host + ":" + port;
			}
			return host;
		},
		subscribe: function(task_id, opts) {
			// TODO DEPRECATE

			frappe.socketio.socket.emit('task_subscribe', task_id);
			frappe.socketio.socket.emit('progress_subscribe', task_id);

			frappe.socketio.open_tasks[task_id] = opts;
		},
		task_subscribe: function(task_id) {
			frappe.socketio.socket.emit('task_subscribe', task_id);
		},
		task_unsubscribe: function(task_id) {
			frappe.socketio.socket.emit('task_unsubscribe', task_id);
		},
		doc_subscribe: function(doctype, docname) {
			if (frappe.flags.doc_subscribe) {
				console.log('throttled');
				return;
			}

			frappe.flags.doc_subscribe = true;

			// throttle to 1 per sec
			setTimeout(function() { frappe.flags.doc_subscribe = false; }, 1000);

			frappe.socketio.socket.emit('doc_subscribe', doctype, docname);
			frappe.socketio.open_docs.push({doctype: doctype, docname: docname});
		},
		doc_unsubscribe: function(doctype, docname) {
			frappe.socketio.socket.emit('doc_unsubscribe', doctype, docname);
			frappe.socketio.open_docs = $.filter(frappe.socketio.open_docs, function(d) {
				if(d.doctype===doctype && d.name===docname) {
					return null;
				} else {
					return d;
				}
			});
		},
		doc_open: function(doctype, docname) {
			// notify that the user has opened this doc, if not already notified
			if(!frappe.socketio.last_doc
				|| (frappe.socketio.last_doc[0]!=doctype && frappe.socketio.last_doc[0]!=docname)) {
				frappe.socketio.socket.emit('doc_open', doctype, docname);
			}
			frappe.socketio.last_doc = [doctype, docname];
		},
		doc_close: function(doctype, docname) {
			// notify that the user has closed this doc
			frappe.socketio.socket.emit('doc_close', doctype, docname);
		},

		setup_listeners: function() {
			frappe.socketio.socket.on('task_status_change', function(data) {
				frappe.socketio.process_response(data, data.status.toLowerCase());
			});
			frappe.socketio.socket.on('task_progress', function(data) {
				frappe.socketio.process_response(data, "progress");
			});
		},
		setup_reconnect: function() {
			// subscribe again to open_tasks
			frappe.socketio.socket.on("connect", function() {
				// wait for 5 seconds before subscribing again
				// because it takes more time to start python server than nodejs server
				// and we use validation requests to python server for subscribing
				setTimeout(function() {
					$.each(frappe.socketio.open_tasks, function(task_id, opts) {
						frappe.socketio.subscribe(task_id, opts);
					});

					// re-connect open docs
					$.each(frappe.socketio.open_docs, function(d) {
						if(locals[d.doctype] && locals[d.doctype][d.name]) {
							frappe.socketio.doc_subscribe(d.doctype, d.name);
						}
					});

					if (cur_frm && cur_frm.doc) {
						frappe.socketio.doc_open(cur_frm.doc.doctype, cur_frm.doc.name);
					}
				}, 5000);
			});
		},
		process_response: function(data, method) {
			if(!data) {
				return;
			}

			// success
			var opts = frappe.socketio.open_tasks[data.task_id];
			if(opts[method]) {
				opts[method](data);
			}

			// "callback" is std frappe term
			if(method==="success") {
				if(opts.callback) { opts.callback(data); }
			}

			// always
			frappe.request.cleanup(opts, data);
			if(opts.always) {
				opts.always(data);
			}

			// error
			if(data.status_code && data.status_code > 400 && opts.error) {
				opts.error(data);
			}
		}
	};

	frappe.provide("frappe.realtime");
	frappe.realtime.on = function(event, callback) {
		frappe.socketio.socket && frappe.socketio.socket.on(event, callback);
	};

	frappe.realtime.off = function(event, callback) {
		frappe.socketio.socket && frappe.socketio.socket.off(event, callback);
	};

	frappe.realtime.publish = function(event, message) {
		if(frappe.socketio.socket) {
			frappe.socketio.socket.emit(event, message);
		}
	};

	frappe.socketio.SocketIOUploader = class SocketIOUploader {
		constructor() {
		var this$1 = this;

			frappe.socketio.socket.on('upload-request-slice', function (data) {
				var place = data.currentSlice * this$1.chunk_size,
					slice = this$1.file.slice(place,
						place + Math.min(this$1.chunk_size, this$1.file.size - place));

				if (this$1.on_progress) {
					// update progress
					this$1.on_progress(place / this$1.file.size * 100);
				}

				this$1.reader.readAsArrayBuffer(slice);
				this$1.started = true;
				this$1.keep_alive();
			});

			frappe.socketio.socket.on('upload-end', function (data) {
				this$1.reader = null;
				this$1.file = null;
				if (data.file_url.substr(0, 7)==='/public') {
					data.file_url = data.file_url.substr(7);
				}
				this$1.callback(data);
			});

			frappe.socketio.socket.on('upload-error', function (data) {
				this$1.disconnect(false);
				frappe.msgprint({
					title: __('Upload Failed'),
					message: data.error,
					indicator: 'red'
				});
			});

			frappe.socketio.socket.on('disconnect', function () {
				this$1.disconnect();
			});
		}

		start(ref) {
			var this$1 = this;
			if ( ref === void 0 ) ref = {};
			var file = ref.file; if ( file === void 0 ) file = null;
			var is_private = ref.is_private; if ( is_private === void 0 ) is_private = 0;
			var filename = ref.filename; if ( filename === void 0 ) filename = '';
			var callback = ref.callback; if ( callback === void 0 ) callback = null;
			var on_progress = ref.on_progress; if ( on_progress === void 0 ) on_progress = null;
			var chunk_size = ref.chunk_size; if ( chunk_size === void 0 ) chunk_size = 24576;
			var fallback = ref.fallback; if ( fallback === void 0 ) fallback = null;


			if (this.reader) {
				frappe.throw(__('File Upload in Progress. Please try again in a few moments.'));
			}

			function fallback_required() {
				return !frappe.boot.sysdefaults.use_socketio_to_upload_file || !frappe.socketio.socket.connected;
			}

			if (fallback_required()) {
				return fallback ? fallback() : frappe.throw(__('Socketio is not connected. Cannot upload'));
			}

			this.reader = new FileReader();
			this.file = file;
			this.chunk_size = chunk_size;
			this.callback = callback;
			this.on_progress = on_progress;
			this.fallback = fallback;
			this.started = false;

			this.reader.onload = function () {
				frappe.socketio.socket.emit('upload-accept-slice', {
					is_private: is_private,
					name: filename,
					type: this$1.file.type,
					size: this$1.file.size,
					data: this$1.reader.result
				});
				this$1.keep_alive();
			};

			var slice = file.slice(0, this.chunk_size);
			this.reader.readAsArrayBuffer(slice);
		}

		keep_alive() {
			var this$1 = this;

			if (this.next_check) {
				clearTimeout (this.next_check);
			}
			this.next_check = setTimeout (function () {
				if (!this$1.started) {
					// upload never started, so try fallback
					if (this$1.fallback) {
						this$1.fallback();
					} else {
						this$1.disconnect();
					}
				}
				this$1.disconnect();
			}, 3000);
		}

		disconnect(with_message) {
			if ( with_message === void 0 ) with_message = true;

			if (this.reader) {
				this.reader = null;
				this.file = null;
				frappe.hide_progress();
				if (with_message) {
					frappe.msgprint({
						title: __('File Upload'),
						message: __('File Upload Disconnected. Please try again.'),
						indicator: 'red'
					});
				}
			}
		}
	};

	var isArray = Array.isArray;
	var keyList = Object.keys;
	var hasProp = Object.prototype.hasOwnProperty;

	var fastDeepEqual = function equal(a, b) {
	  if (a === b) { return true; }

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    var arrA = isArray(a)
	      , arrB = isArray(b)
	      , i
	      , length
	      , key;

	    if (arrA && arrB) {
	      length = a.length;
	      if (length != b.length) { return false; }
	      for (i = length; i-- !== 0;)
	        { if (!equal(a[i], b[i])) { return false; } }
	      return true;
	    }

	    if (arrA != arrB) { return false; }

	    var dateA = a instanceof Date
	      , dateB = b instanceof Date;
	    if (dateA != dateB) { return false; }
	    if (dateA && dateB) { return a.getTime() == b.getTime(); }

	    var regexpA = a instanceof RegExp
	      , regexpB = b instanceof RegExp;
	    if (regexpA != regexpB) { return false; }
	    if (regexpA && regexpB) { return a.toString() == b.toString(); }

	    var keys = keyList(a);
	    length = keys.length;

	    if (length !== keyList(b).length)
	      { return false; }

	    for (i = length; i-- !== 0;)
	      { if (!hasProp.call(b, keys[i])) { return false; } }

	    for (i = length; i-- !== 0;) {
	      key = keys[i];
	      if (!equal(a[key], b[key])) { return false; }
	    }

	    return true;
	  }

	  return a!==a && b!==b;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	frappe.provide('frappe.utils');

	Object.assign(frappe.utils, {
		get_random: function(len) {
			var text = "";
			var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

			for( var i=0; i < len; i++ )
				{ text += possible.charAt(Math.floor(Math.random() * possible.length)); }

			return text;
		},
		get_file_link: function(filename) {
			filename = cstr(filename);
			if(frappe.utils.is_url(filename)) {
				return filename;
			} else if(filename.indexOf("/")===-1) {
				return "files/" + filename;
			} else {
				return filename;
			}
		},
		replace_newlines: function replace_newlines(t) {
			return t?t.replace(/\n/g, '<br>'):'';
		},
		is_html: function(txt) {
			if (!txt) { return false; }

			if(txt.indexOf("<br>")==-1 && txt.indexOf("<p")==-1
				&& txt.indexOf("<img")==-1 && txt.indexOf("<div")==-1 && !txt.includes('<span')) {
				return false;
			}
			return true;
		},
		is_xs: function() {
			return $(document).width() < 768;
		},
		is_sm: function() {
			return $(document).width() < 991 && $(document).width() >= 768;
		},
		is_md: function() {
			return $(document).width() < 1199 && $(document).width() >= 991;
		},
		is_json: function(str) {
			try {
				JSON.parse(str);
			} catch (e) {
				return false;
			}
			return true;
		},
		strip_whitespace: function(html) {
			return (html || "").replace(/<p>\s*<\/p>/g, "").replace(/<br>(\s*<br>\s*)+/g, "<br><br>");
		},
		encode_tags: function(html) {
			var tagsToReplace = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;'
			};

			function replaceTag(tag) {
				return tagsToReplace[tag] || tag;
			}

			return html.replace(/[&<>]/g, replaceTag);
		},
		strip_original_content: function(txt) {
			var out = [],
				part = [],
				newline = txt.indexOf("<br>")===-1 ? "\n" : "<br>";

			$.each(txt.split(newline), function(i, t) {
				var tt = strip(t);
				if(tt && (tt.substr(0,1)===">" || tt.substr(0,4)==="&gt;")) {
					part.push(t);
				} else {
					out.push(t);
					part = [];
				}
			});
			return out.join(newline);
		},
		escape_html: function(txt) {
			return $("<div></div>").text(txt || "").html();
		},

		html2text: function(html) {
			var d = document.createElement('div');
			d.innerHTML = html;
			return d.textContent;
		},

		is_url: function(txt) {
			return txt.toLowerCase().substr(0,7)=='http://'
				|| txt.toLowerCase().substr(0,8)=='https://'
		},
		to_title_case: function(string, with_space) {
			if ( with_space === void 0 ) with_space=false;

			var titlecased_string = string.toLowerCase().replace(/(?:^|[\s-/])\w/g, function(match) {
				return match.toUpperCase();
			});

			var replace_with = with_space ? ' ' : '';

			return titlecased_string.replace(/-|_/g, replace_with);
		},
		toggle_blockquote: function(txt) {
			if (!txt) { return txt; }

			var content = $("<div></div>").html(txt);
			content.find("blockquote").parent("blockquote").addClass("hidden")
				.before('<p><a class="text-muted btn btn-default toggle-blockquote" style="padding: 2px 7px 0px; line-height: 1;"> \
					   \
				</a></p>');
			return content.html();
		},
		scroll_to: function(element, animate, additional_offset) {
			var y = 0;
			if(element && typeof element==='number') {
				y = element;
			} else if(element) {
				var header_offset = $(".navbar").height() + $(".page-head").height();
				var y = $(element).offset().top - header_offset - cint(additional_offset);
			}

			if(y < 0) {
				y = 0;
			}

			// already there
			if(y==$('html, body').scrollTop()) {
				return;
			}

			if (animate!==false) {
				$("html, body").animate({ scrollTop: y });
			} else {
				$(window).scrollTop(y);
			}

		},
		filter_dict: function(dict, filters) {
			var ret = [];
			if(typeof filters=='string') {
				return [dict[filters]]
			}
			$.each(dict, function(i, d) {
				for(var key in filters) {
					if($.isArray(filters[key])) {
						if(filters[key][0]=="in") {
							if(filters[key][1].indexOf(d[key])==-1)
								{ return; }
						} else if(filters[key][0]=="not in") {
							if(filters[key][1].indexOf(d[key])!=-1)
								{ return; }
						} else if(filters[key][0]=="<") {
							if (!(d[key] < filters[key])) { return; }
						} else if(filters[key][0]=="<=") {
							if (!(d[key] <= filters[key])) { return; }
						} else if(filters[key][0]==">") {
							if (!(d[key] > filters[key])) { return; }
						} else if(filters[key][0]==">=") {
							if (!(d[key] >= filters[key])) { return; }
						}
					} else {
						if(d[key]!=filters[key]) { return; }
					}
				}
				ret.push(d);
			});
			return ret;
		},
		comma_or: function(list) {
			return frappe.utils.comma_sep(list, " " + __("or") + " ");
		},
		comma_and: function(list) {
			return frappe.utils.comma_sep(list, " " + __("and") + " ");
		},
		comma_sep: function(list, sep) {
			if(list instanceof Array) {
				if(list.length==0) {
					return "";
				} else if (list.length==1) {
					return list[0];
				} else {
					return list.slice(0, list.length-1).join(", ") + sep + list.slice(-1)[0];
				}
			} else {
				return list;
			}
		},
		set_footnote: function(footnote_area, wrapper, txt) {
			if(!footnote_area) {
				footnote_area = $('<div class="text-muted footnote-area level">')
					.appendTo(wrapper);
			}

			if(txt) {
				footnote_area.html(txt);
			} else {
				footnote_area.remove();
				footnote_area = null;
			}
			return footnote_area;
		},
		get_args_dict_from_url: function(txt) {
			var args = {};
			$.each(decodeURIComponent(txt).split("&"), function(i, arg) {
				arg = arg.split("=");
				args[arg[0]] = arg[1];
			});
			return args;
		},
		get_url_from_dict: function(args) {
			return $.map(args, function(val, key) {
				if(val!==null)
					{ return encodeURIComponent(key)+"="+encodeURIComponent(val); }
				else
					{ return null; }
			}).join("&") || "";
		},
		validate_type: function ( val, type ) {
			// from https://github.com/guillaumepotier/Parsley.js/blob/master/parsley.js#L81
			var regExp;

			switch ( type ) {
				case "number":
					regExp = /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/;
					break;
				case "digits":
					regExp = /^\d+$/;
					break;
				case "alphanum":
					regExp = /^\w+$/;
					break;
				case "email":
					regExp = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
					break;
				case "url":
					regExp = /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
					break;
				case "dateIso":
					regExp = /^(\d{4})\D?(0[1-9]|1[0-2])\D?([12]\d|0[1-9]|3[01])$/;
					break;
				default:
					return false;
			}

			// test regExp if not null
			return '' !== val ? regExp.test( val ) : false;
		},
		guess_style: function(text, default_style, _colour) {
			var style = default_style || "default";
			var colour = "darkgrey";
			if(text) {
				if(has_words(["Pending", "Review", "Medium", "Not Approved"], text)) {
					style = "warning";
					colour = "orange";
				} else if(has_words(["Open", "Urgent", "High"], text)) {
					style = "danger";
					colour = "red";
				} else if(has_words(["Closed", "Finished", "Converted", "Completed", "Confirmed",
					"Approved", "Yes", "Active", "Available", "Paid"], text)) {
					style = "success";
					colour = "green";
				} else if(has_words(["Submitted"], text)) {
					style = "info";
					colour = "blue";
				}
			}
			return _colour ? colour : style;
		},

		guess_colour: function(text) {
			return frappe.utils.guess_style(text, null, true);
		},

		sort: function(list, key, compare_type, reverse) {
			if(!list || list.length < 2)
				{ return list || []; }

			var sort_fn = {
				"string": function(a, b) {
					return cstr(a[key]).localeCompare(cstr(b[key]));
				},
				"number": function(a, b) {
					return flt(a[key]) - flt(b[key]);
				}
			};

			if(!compare_type)
				{ compare_type = typeof list[0][key]==="string" ? "string" : "number"; }

			list.sort(sort_fn[compare_type]);

			if(reverse) { list.reverse(); }

			return list;
		},

		unique: function(list) {
			var dict = {},
				arr = [];
			for(var i=0, l=list.length; i < l; i++) {
				if(!dict.hasOwnProperty(list[i])) {
					dict[list[i]] = null;
					arr.push(list[i]);
				}
			}
			return arr;
		},

		remove_nulls: function(list) {
			var new_list = [];
			for (var i=0, l=list.length; i < l; i++) {
				if (!is_null(list[i])) {
					new_list.push(list[i]);
				}
			}
			return new_list;
		},

		all: function(lst) {
			for(var i=0, l=lst.length; i<l; i++) {
				if(!lst[i]) {
					return false;
				}
			}
			return true;
		},

		dict: function(keys,values) {
			// make dictionaries from keys and values
			var out = [];
			$.each(values, function(row_idx, row) {
				var new_row = {};
				$.each(keys, function(key_idx, key) {
					new_row[key] = row[key_idx];
				});
				out.push(new_row);
			});
			return out;
		},

		sum: function(list) {
			return list.reduce(function(previous_value, current_value) { return flt(previous_value) + flt(current_value); }, 0.0);
		},

		arrays_equal: function(arr1, arr2) {
			if (!arr1 || !arr2) {
				return false;
			}
			if (arr1.length != arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if ($.isArray(arr1[i])) {
					if (!frappe.utils.arrays_equal(arr1[i], arr2[i])) {
						return false;
					}
				}
				else if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		},

		intersection: function(a, b) {
			// from stackoverflow: http://stackoverflow.com/questions/1885557/simplest-code-for-array-intersection-in-javascript
			/* finds the intersection of
			 * two arrays in a simple fashion.
			 *
			 * PARAMS
			 *  a - first array, must already be sorted
			 *  b - second array, must already be sorted
			 *
			 * NOTES
			 *
			 *  Should have O(n) operations, where n is
			 *    n = MIN(a.length(), b.length())
			 */
			var ai=0, bi=0;
			var result = new Array();

			// sorted copies
			a = ([].concat(a)).sort();
			b = ([].concat(b)).sort();

			while( ai < a.length && bi < b.length ) {
				if (a[ai] < b[bi] ) { ai++; }
				else if (a[ai] > b[bi] ) { bi++; }
				else {
					/* they're equal */
					result.push(a[ai]);
					ai++;
					bi++;
				}
			}

			return result;
		},

		resize_image: function(reader, callback, max_width, max_height) {
			var tempImg = new Image();
			if(!max_width) { max_width = 600; }
			if(!max_height) { max_height = 400; }
			tempImg.src = reader.result;

			tempImg.onload = function() {
				var tempW = tempImg.width;
				var tempH = tempImg.height;
				if (tempW > tempH) {
					if (tempW > max_width) {
						tempH *= max_width / tempW;
						tempW = max_width;
					}
				} else {
					if (tempH > max_height) {
						tempW *= max_height / tempH;
						tempH = max_height;
					}
				}

				var canvas = document.createElement('canvas');
				canvas.width = tempW;
				canvas.height = tempH;
				var ctx = canvas.getContext("2d");
				ctx.drawImage(this, 0, 0, tempW, tempH);
				var dataURL = canvas.toDataURL("image/jpeg");
				setTimeout(function() { callback(dataURL); }, 10 );
			};
		},

		csv_to_array: function (strData, strDelimiter) {
			// Check to see if the delimiter is defined. If not,
			// then default to comma.
			strDelimiter = (strDelimiter || ",");

			// Create a regular expression to parse the CSV values.
			var objPattern = new RegExp(
				(
					// Delimiters.
					"(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

					// Quoted fields.
					"(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

					// Standard fields.
					"([^\"\\" + strDelimiter + "\\r\\n]*))"
				),
				"gi"
				);


			// Create an array to hold our data. Give the array
			// a default empty first row.
			var arrData = [[]];

			// Create an array to hold our individual pattern
			// matching groups.
			var arrMatches = null;


			// Keep looping over the regular expression matches
			// until we can no longer find a match.
			while ((arrMatches = objPattern.exec( strData ))){

				// Get the delimiter that was found.
				var strMatchedDelimiter = arrMatches[ 1 ];

				// Check to see if the given delimiter has a length
				// (is not the start of string) and if it matches
				// field delimiter. If id does not, then we know
				// that this delimiter is a row delimiter.
				if (
					strMatchedDelimiter.length &&
					strMatchedDelimiter !== strDelimiter
					){

					// Since we have reached a new row of data,
					// add an empty row to our data array.
					arrData.push( [] );

				}

				var strMatchedValue;

				// Now that we have our delimiter out of the way,
				// let's check to see which kind of value we
				// captured (quoted or unquoted).
				if (arrMatches[ 2 ]){

					// We found a quoted value. When we capture
					// this value, unescape any double quotes.
					strMatchedValue = arrMatches[ 2 ].replace(
						new RegExp( "\"\"", "g" ),
						"\""
						);

				} else {

					// We found a non-quoted value.
					strMatchedValue = arrMatches[ 3 ];

				}


				// Now that we have our value string, let's add
				// it to the data array.
				arrData[ arrData.length - 1 ].push( strMatchedValue );
			}

			// Return the parsed data.
			return( arrData );
		},

		warn_page_name_change: function(frm) {
			frappe.msgprint(__("Note: Changing the Page Name will break previous URL to this page."));
		},

		notify: function(subject, body, route, onclick) {
			console.log('push notifications are evil and deprecated');
		},

		set_title: function(title) {
			frappe._original_title = title;
			if(frappe._title_prefix) {
				title = frappe._title_prefix + " " + title.replace(/<[^>]*>/g, "");
			}
			document.title = title;
		},

		set_title_prefix: function(prefix) {
			frappe._title_prefix = prefix;

			// reset the original title
			frappe.utils.set_title(frappe._original_title);
		},

		is_image_file: function(filename) {
			if (!filename) { return false; }
			// url can have query params
			filename = filename.split('?')[0];
			return (/\.(gif|jpg|jpeg|tiff|png|svg)$/i).test(filename);
		},

		play_sound: function(name) {
			try {
				if (frappe.boot.user.mute_sounds) {
					return;
				}

				var audio = $("#sound-" + name)[0];
				audio.volume = audio.getAttribute("volume");
				audio.play();

			} catch(e) {
				console.log("Cannot play sound", name, e);
				// pass
			}

		},
		split_emails: function(txt) {
			var email_list = [];

			if (!txt) {
				return email_list;
			}

			// emails can be separated by comma or newline
			txt.split(/[,\n](?=(?:[^"]|"[^"]*")*$)/g).forEach(function(email) {
				email = email.trim();
				if (email) {
					email_list.push(email);
				}
			});

			return email_list;
		},
		supportsES6: function() {
			try {
				new Function("(a = 0) => a");
				return true;
			}
			catch (err) {
				return false;
			}
		}(),
		throttle: function (func, wait, options) {
			var context, args, result;
			var timeout = null;
			var previous = 0;
			if (!options) { options = {}; }

			var later = function () {
				previous = options.leading === false ? 0 : Date.now();
				timeout = null;
				result = func.apply(context, args);
				if (!timeout) { context = args = null; }
			};

			return function () {
				var now = Date.now();
				if (!previous && options.leading === false) { previous = now; }
				var remaining = wait - (now - previous);
				context = this;
				args = arguments;
				if (remaining <= 0 || remaining > wait) {
					if (timeout) {
						clearTimeout(timeout);
						timeout = null;
					}
					previous = now;
					result = func.apply(context, args);
					if (!timeout) { context = args = null; }
				} else if (!timeout && options.trailing !== false) {
					timeout = setTimeout(later, remaining);
				}
				return result;
			};
		},
		debounce: function(func, wait, immediate) {
			var timeout;
			return function() {
				var context = this, args = arguments;
				var later = function() {
					timeout = null;
					if (!immediate) { func.apply(context, args); }
				};
				var callNow = immediate && !timeout;
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
				if (callNow) { func.apply(context, args); }
			};
		},
		get_form_link: function(doctype, name, html, display_text) {
			if ( html === void 0 ) html = false;
			if ( display_text === void 0 ) display_text = null;

			var route = ['#Form', doctype, name].join('/');
			if (html) {
				return ("<a href=\"" + route + "\">" + (display_text || name) + "</a>");
			}
			return route;
		},
		get_route_label: function get_route_label(route_str) {
			var route = route_str.split('/');

			if (route[2] === 'Report' || route[0] === 'query-report') {
				return __('{0} Report', [route[3] || route[1]]);
			}
			if (route[0] === 'List') {
				return __('{0} List', [route[1]]);
			}
			if (route[0] === 'modules') {
				return __('{0} Modules', [route[1]]);
			}
			if (route[0] === 'dashboard') {
				return __('{0} Dashboard', [route[1]]);
			}
			return __(frappe.utils.to_title_case(route[0], true));
		},
		report_column_total: function(values, column, type) {
			if (values.length > 0) {
				if (column.column.fieldtype == "Percent" || type === "mean") {
					return values.reduce(function (a, b) { return a + flt(b); }) / values.length;
				} else if (column.column.fieldtype == "Int") {
					return values.reduce(function (a, b) { return a + cint(b); });
				} else if (frappe.model.is_numeric_field(column.column.fieldtype)) {
					return values.reduce(function (a, b) { return a + flt(b); });
				} else {
					return null;
				}
			}
			else {
				return null;
			}
		},

		deep_equal: function deep_equal$1(a, b) {
			return fastDeepEqual(a, b);
		},

		file_name_ellipsis: function file_name_ellipsis(filename, length) {
			var first_part_length = length * 2 / 3;
			var last_part_length = length - first_part_length;
			var parts = filename.split('.');
			var extn = parts.pop();
			var name = parts.join('');
			var first_part = name.slice(0, first_part_length);
			var last_part = name.slice(-last_part_length);
			if (name.length > length) {
				return (first_part + "..." + last_part + "." + extn);
			} else {
				return filename;
			}
		},
		get_decoded_string: function get_decoded_string(dataURI) {
			// decodes base64 to string
			var parts = dataURI.split(',');
			var encoded_data = parts[1];
			return decodeURIComponent(escape(atob(encoded_data)));
		}
	});

	// Array de duplicate
	if (!Array.prototype.uniqBy) {
		Object.defineProperty(Array.prototype, 'uniqBy', {
			value: function (key) {
				var seen = {};
				return this.filter(function (item) {
					var k = key(item);
					return seen.hasOwnProperty(k) ? false : (seen[k] = true);
				});
			}
		});
		Object.defineProperty(Array.prototype, 'move', {
			value: function(from, to) {
				this.splice(to, 0, this.splice(from, 1)[0]);
			}
		});
	}

	frappe.provide('frappe.utils');
	/**
	 * Simple EventEmitterMixin which uses jQuery's event system
	 */
	var EventEmitterMixin = {
		init: function init() {
			this.jq = jQuery({});
		},

		trigger: function trigger(evt, data) {
			!this.jq && this.init();
			this.jq.trigger(evt, data);
		},

		once: function once(evt, handler) {
			!this.jq && this.init();
			this.jq.one(evt, function (e, data) { return handler(data); });
		},

		on: function on(evt, handler) {
			!this.jq && this.init();
			this.jq.bind(evt, function (e, data) { return handler(data); });
		},

		off: function off(evt, handler) {
			!this.jq && this.init();
			this.jq.unbind(evt, function (e, data) { return handler(data); });
		}
	};

	frappe.utils.make_event_emitter = function(object) {
		Object.assign(object, EventEmitterMixin);
		return object;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// route urls to their virtual pages

	// re-route map (for rename)
	frappe.provide('frappe.views');
	frappe.re_route = {"#login": ""};
	frappe.route_titles = {};
	frappe.route_flags = {};
	frappe.route_history = [];
	frappe.view_factory = {};
	frappe.view_factories = [];
	frappe.route_options = null;

	frappe.route = function() {

		// Application is not yet initiated
		if (!frappe.app) { return; }

		if(frappe.re_route[window.location.hash] !== undefined) {
			// after saving a doc, for example,
			// "New DocType 1" and the renamed "TestDocType", both exist in history
			// now if we try to go back,
			// it doesn't allow us to go back to the one prior to "New DocType 1"
			// Hence if this check is true, instead of changing location hash,
			// we just do a back to go to the doc previous to the "New DocType 1"
			var re_route_val = frappe.get_route_str(frappe.re_route[window.location.hash]);
			var cur_route_val = frappe.get_route_str(frappe._cur_route);
			if (decodeURIComponent(re_route_val) === decodeURIComponent(cur_route_val)) {
				window.history.back();
				return;
			} else {
				window.location.hash = frappe.re_route[window.location.hash];
			}
		}

		frappe._cur_route = window.location.hash;

		var route = frappe.get_route();
		if (route === false) {
			return;
		}

		frappe.route_history.push(route);

		if(route[0]) {
			var title_cased_route = frappe.utils.to_title_case(route[0]);

			if(route[1] && frappe.views[title_cased_route + "Factory"]) {
				// has a view generator, generate!
				if(!frappe.view_factory[title_cased_route]) {
					frappe.view_factory[title_cased_route] = new frappe.views[title_cased_route + "Factory"]();
				}

				frappe.view_factory[title_cased_route].show();
			} else {
				// show page
				var route_name = frappe.utils.xss_sanitise(route[0]);
				if (frappe.views.pageview) {
					frappe.views.pageview.show(route_name);
				}
			}
		} else {
			// Show desk
			frappe.views.pageview.show('');
		}


		if(frappe.route_titles[window.location.hash]) {
			frappe.utils.set_title(frappe.route_titles[window.location.hash]);
		} else {
			setTimeout(function() {
				frappe.route_titles[frappe.get_route_str()] = frappe._original_title || document.title;
			}, 1000);
		}

		if(window.mixpanel) {
			window.mixpanel.track(route.slice(0, 2).join(' '));
		}
	};

	frappe.get_route = function(route) {
		// for app
		route = frappe.get_raw_route_str(route).split('/');
		route = $.map(route, frappe._decode_str);
		var parts = null;
		var doc_name = route[route.length - 1];
		// if the last part contains ? then check if it is valid query string
		if(doc_name.indexOf("?") < doc_name.indexOf("=")){
			parts = doc_name.split("?");
			route[route.length - 1] = parts[0];
		} else {
			parts = doc_name;
		}
		if (parts.length > 1) {
			var query_params = frappe.utils.get_query_params(parts[1]);
			frappe.route_options = $.extend(frappe.route_options || {}, query_params);
		}

		// backward compatibility
		if (route && route[0]==='Module') {
			frappe.set_route('modules', route[1]);
			return false;
		}

		return route;
	};

	frappe.get_prev_route = function() {
		if(frappe.route_history && frappe.route_history.length > 1) {
			return frappe.route_history[frappe.route_history.length - 2];
		} else {
			return [];
		}
	};

	frappe._decode_str = function(r) {
		try {
			return decodeURIComponent(r);
		} catch(e) {
			if (e instanceof URIError) {
				return r;
			} else {
				throw e;
			}
		}
	};

	frappe.get_raw_route_str = function(route) {
		if(!route)
			{ route = window.location.hash; }

		if(route.substr(0,1)=='#') { route = route.substr(1); }
		if(route.substr(0,1)=='!') { route = route.substr(1); }

		return route;
	};

	frappe.get_route_str = function(route) {
		var rawRoute = frappe.get_raw_route_str(route);
		route = $.map(rawRoute.split('/'), frappe._decode_str).join('/');

		return route;
	};

	frappe.set_route = function() {
		var arguments$1 = arguments;

		return new Promise(function (resolve) {
			var params = arguments$1;
			if(params.length===1 && $.isArray(params[0])) {
				params = params[0];
			}
			var route = $.map(params, function(a) {
				if($.isPlainObject(a)) {
					frappe.route_options = a;
					return null;
				} else {
					a = String(a);
					if (a && a.match(/[%'"]/)) {
						// if special chars, then encode
						a = encodeURIComponent(a);
					}
					return a;
				}
			}).join('/');

			window.location.hash = route;

			// Set favicon (app.js)
			frappe.provide('frappe.app');
			frappe.app.set_favicon && frappe.app.set_favicon();
			setTimeout(function () {
				frappe.after_ajax && frappe.after_ajax(function () {
					resolve();
				});
			}, 100);
		});
	};

	frappe.set_re_route = function() {
		var tmp = window.location.hash;
		frappe.set_route.apply(null, arguments);
		frappe.re_route[tmp] = window.location.hash;
	};


	frappe._cur_route = null;

	$(window).on('hashchange', function() {
		// save the title
		frappe.route_titles[frappe._cur_route] = frappe._original_title || document.title;

		if(window.location.hash==frappe._cur_route)
			{ return; }

		// hide open dialog
		if(window.cur_dialog && cur_dialog.hide_on_page_refresh) {
			if (!cur_dialog.minimizable) {
				cur_dialog.hide();
			} else if (!cur_dialog.is_minimized) {
				cur_dialog.toggle_minimize();
			}
		}

		frappe.route();

		frappe.route.trigger('change');
	});

	frappe.utils.make_event_emitter(frappe.route);

	frappe.provide('frappe.route');
	frappe.route_history_queue = [];
	var routes_to_skip = ['Form', 'social', 'setup-wizard'];

	var save_routes = frappe.utils.debounce(function () {
		var routes = frappe.route_history_queue;
		frappe.route_history_queue = [];
		frappe.xcall('frappe.deferred_insert.deferred_insert', {
			'doctype': 'Route History',
			'records': routes
		}).catch(function () {
			frappe.route_history_queue.concat(routes);
		});
	}, 10000);

	frappe.route.on('change', function () {
		var route = frappe.get_route();
		if (is_route_useful(route)) {
			frappe.route_history_queue.push({
				'user': frappe.session.user,
				'creation': frappe.datetime.now_datetime(),
				'route': frappe.get_route_str()
			});

			save_routes();
		}
	});

	function is_route_useful(route) {
		if (!route[1]) {
			return false;
		} else if ((route[0] === 'List' && !route[2]) || routes_to_skip.includes(route[0])) {

			return false;
		} else {
			return true;
		}
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.defaults = {
		get_user_default: function(key) {
			var defaults = frappe.boot.user.defaults;
			var d = defaults[key];
			if(!d && frappe.defaults.is_a_user_permission_key(key))
				{ d = defaults[frappe.model.scrub(key)]; }
			if($.isArray(d)) { d = d[0]; }

			if(!frappe.defaults.in_user_permission(key, d)) {
				return;
			}

			return d;
		},
		get_user_defaults: function(key) {
			var defaults = frappe.boot.user.defaults;
			var d = defaults[key];

			if (frappe.defaults.is_a_user_permission_key(key)) {
				if (d && $.isArray(d) && d.length===1) {
					// Use User Permission value when only when it has a single value
					d = d[0];
				} else {
					d = defaults[key] || defaults[frappe.model.scrub(key)];
				}
			}
			if(!$.isArray(d)) { d = [d]; }

			// filter out values which are not permitted to the user
			d.filter(function (item) {
				if(frappe.defaults.in_user_permission(key, item)) {
					return item;
				}
			});
			return d;
		},
		get_global_default: function(key) {
			var d = frappe.sys_defaults[key];
			if($.isArray(d)) { d = d[0]; }
			return d;
		},
		get_global_defaults: function(key) {
			var d = frappe.sys_defaults[key];
			if(!$.isArray(d)) { d = [d]; }
			return d;
		},
		set_default: function(key, value, callback) {
			if(typeof value!=="string")
				{ value = JSON.stringify(value); }

			frappe.boot.user.defaults[key] = value;
			return frappe.call({
				method: "frappe.client.set_default",
				args: {
					key: key,
					value: value
				},
				callback: callback || function(r) {}
			});
		},
		set_user_default_local: function(key, value) {
			frappe.boot.user.defaults[key] = value;
		},
		get_default: function(key) {
			var defaults = frappe.boot.user.defaults;
			var value = defaults[key];
			if (frappe.defaults.is_a_user_permission_key(key)) {
				if (value && $.isArray(value) && value.length===1) {
					value = value[0];
				} else {
					value = defaults[frappe.model.scrub(key)];
				}
			}

			if(!frappe.defaults.in_user_permission(key, value)) {
				return;
			}

			if(value) {
				try {
					return JSON.parse(value)
				} catch(e) {
					return value;
				}
			}
		},

		is_a_user_permission_key: function(key) {
			return key.indexOf(":")===-1 && key !== frappe.model.scrub(key);
		},

		in_user_permission: function(key, value) {
			var user_permission = this.get_user_permissions()[frappe.model.unscrub(key)];

			if (user_permission && user_permission.length) {

				var doc_found = user_permission.some(function (perm) {
					return perm.doc === value;
				});
				return doc_found;

			} else {
				// there is no user permission for this doctype
				// so we can allow this doc i.e., value
				return true;
			}

		},

		get_user_permissions: function() {
			return this._user_permissions || {};
		},

		update_user_permissions: function() {
			var this$1 = this;

			var method = 'frappe.core.doctype.user_permission.user_permission.get_user_permissions';
			frappe.call(method).then(function (r) {
				if (r.message) {
					this$1._user_permissions = Object.assign({}, r.message);
				}
			});
		}
	};

	frappe.RoleEditor = Class.extend({
		init: function(wrapper, frm, disable) {
			var me = this;
			this.frm = frm;
			this.wrapper = wrapper;
			this.disable = disable;
			$(wrapper).html('<div class="help">' + __("Loading") + '...</div>');
			frappe.call({
				method: 'frappe.core.doctype.user.user.get_all_roles',
				callback: function(r) {
					me.roles = r.message;
					me.show_roles();

					// refresh call could've already happened
					// when all role checkboxes weren't created
					if(me.frm.doc) {
						me.frm.roles_editor.show();
					}
				}
			});
		},
		show_roles: function() {
			var me = this;
			$(this.wrapper).empty();
			if(me.frm.doctype != 'User') {
				var role_toolbar = $('<p><button class="btn btn-default btn-add btn-sm" style="margin-right: 5px;"></button>\
				<button class="btn btn-sm btn-default btn-remove"></button></p>').appendTo($(this.wrapper));

				role_toolbar.find(".btn-add")
					.html(__('Add all roles'))
					.on("click", function() {
						$(me.wrapper).find('input[type="checkbox"]').each(function(i, check) {
							if (!$(check).is(":checked")) {
								check.checked = true;
							}
						});
					});

				role_toolbar.find(".btn-remove")
					.html(__('Clear all roles'))
					.on("click", function() {
						$(me.wrapper).find('input[type="checkbox"]').each(function(i, check) {
							if($(check).is(":checked")) {
								check.checked = false;
							}
						});
					});
			}

			$.each(this.roles, function(i, role) {
				$(me.wrapper).append(repl('<div class="user-role" \
				data-user-role="%(role_value)s">\
				<input type="checkbox" style="margin-top:0px;" class="box"> \
				<a href="#" class="grey role">%(role_display)s</a>\
			</div>', {role_value: role,role_display:__(role)}));
			});

			$(this.wrapper).find('input[type="checkbox"]').change(function() {
				me.set_roles_in_table();
				me.frm.dirty();
			});
			$(this.wrapper).find('.user-role a').click(function() {
				me.show_permissions($(this).parent().attr('data-user-role'));
				return false;
			});
		},
		show: function() {
			var me = this;
			$('.box').attr('disabled', this.disable);

			// uncheck all roles
			$(this.wrapper).find('input[type="checkbox"]')
				.each(function(i, checkbox) {
					checkbox.checked = false;
				});

			// set user roles as checked
			$.each((me.frm.doc.roles || []), function(i, user_role) {
				var checkbox = $(me.wrapper)
					.find('[data-user-role="'+user_role.role+'"] input[type="checkbox"]').get(0);
				if(checkbox) { checkbox.checked = true; }
			});

			this.set_enable_disable();
		},
		set_enable_disable: function() {
			$('.box').attr('disabled', this.disable ? true : false);
		},
		set_roles_in_table: function() {
			var opts = this.get_roles();
			var existing_roles_map = {};
			var existing_roles_list = [];
			var me = this;

			$.each((me.frm.doc.roles || []), function(i, user_role) {
				existing_roles_map[user_role.role] = user_role.name;
				existing_roles_list.push(user_role.role);
			});

			// remove unchecked roles
			$.each(opts.unchecked_roles, function(i, role) {
				if(existing_roles_list.indexOf(role)!=-1) {
					frappe.model.clear_doc("Has Role", existing_roles_map[role]);
				}
			});

			// add new roles that are checked
			$.each(opts.checked_roles, function(i, role) {
				if(existing_roles_list.indexOf(role)==-1) {
					var user_role = frappe.model.add_child(me.frm.doc, "Has Role", "roles");
					user_role.role = role;
				}
			});

			refresh_field("roles");
		},
		get_roles: function() {
			var checked_roles = [];
			var unchecked_roles = [];
			$(this.wrapper).find('[data-user-role]').each(function() {
				if($(this).find('input[type="checkbox"]:checked').length) {
					checked_roles.push($(this).attr('data-user-role'));
				} else {
					unchecked_roles.push($(this).attr('data-user-role'));
				}
			});

			return {
				checked_roles: checked_roles,
				unchecked_roles: unchecked_roles
			};
		},
		show_permissions: function(role) {
			// show permissions for a role
			var me = this;
			if(!this.perm_dialog)
				{ this.make_perm_dialog(); }
			$(this.perm_dialog.body).empty();
			return frappe.call({
				method: 'frappe.core.doctype.user.user.get_perm_info',
				args: {role: role},
				callback: function(r) {
					var $body = $(me.perm_dialog.body);
					// TODO fix the overflow issue and also display perms like report, import, etc.

					$body.append('<table class="user-perm"><thead><tr>'
						+ '<th style="text-align: left">' + __('Document Type') + '</th>'
						+ '<th>' + __('Level') + '</th>'
						+ '<th>' + __('Read') + '</th>'
						+ '<th>' + __('Write') + '</th>'
						+ '<th>' + __('Create') + '</th>'
						+ '<th>' + __('Delete') + '</th>'
						+ '<th>' + __('Submit') + '</th>'
						+ '<th>' + __('Cancel') + '</th>'
						+ '<th>' + __('Amend') + '</th>'
						+ '<th>' + __('Set User Permissions') + '</th>'
						+ '</tr></thead><tbody></tbody></table>');

					for(var i=0, l=r.message.length; i<l; i++) {
						var perm = r.message[i];

						// if permission -> icon
						for(var key in perm) {
							if(key!='parent' && key!='permlevel') {
								if(perm[key]) {
									perm[key] = '<i class="fa fa-check"></i>';
								} else {
									perm[key] = '';
								}
							}
						}

						$body.find('tbody').append(repl('<tr>\
						<td style="text-align: left">%(parent)s</td>\
						<td>%(permlevel)s</td>\
						<td>%(read)s</td>\
						<td>%(write)s</td>\
						<td>%(create)s</td>\
						<td>%(delete)s</td>\
						<td>%(submit)s</td>\
						<td>%(cancel)s</td>\
						<td>%(amend)s</td>\
						<td>%(set_user_permissions)s</td>\
						</tr>', perm));
					}
					me.perm_dialog.set_title(role);
					me.perm_dialog.show();
				}
			});

		},
		make_perm_dialog: function() {
			this.perm_dialog = new frappe.ui.Dialog({
				title: __('Role Permissions')
			});

			this.perm_dialog.$wrapper.find('.modal-dialog').css("width", "800px");
		}
	});

	// Simple JavaScript Templating
	// Adapted from John Resig - http://ejohn.org/ - MIT Licensed

	frappe.template = {compiled: {}, debug:{}};
	frappe.template.compile = function(str, name) {
		var key = name || str;

		if(!frappe.template.compiled[key]) {
			if(str.indexOf("'")!==-1) {
				str.replace(/'/g, "\\'");
				//console.warn("Warning: Single quotes (') may not work in templates");
			}

			// replace jinja style tags
			str = str.replace(/{{/g, "{%=").replace(/}}/g, "%}");

			// {% if not test %} --> {% if (!test) { %}
			str = str.replace(/{%\s?if\s?\s?not\s?([^\(][^%{]+)\s?%}/g, "{% if (! $1) { %}");

			// {% if test %} --> {% if (test) { %}
			str = str.replace(/{%\s?if\s?([^\(][^%{]+)\s?%}/g, "{% if ($1) { %}");

			// {% for item in list %}
			//       --> {% for (var i=0, len=list.length; i<len; i++) {  var item = list[i]; %}
			function replacer(match, p1, p2, offset, string) {
				var i = frappe.utils.get_random(3);
				var len = frappe.utils.get_random(3);
				return "{% for (var "+i+"=0, "+len+"="+p2+".length; "+i+"<"+len+"; "+i+"++) { var "
					+p1+" = "+p2+"["+i+"]; "+p1+"._index = "+i+"; %}";
			}
			str = str.replace(/{%\s?for\s([a-z._]+)\sin\s([a-z._]+)\s?%}/g, replacer);

			// {% endfor %} --> {% } %}
			str = str.replace(/{%\s?endif\s?%}/g, "{% }; %}");

			// {% else %} --> {% } else { %}
			str = str.replace(/{%\s?else\s?%}/g, "{% } else { %}");

			// {% endif %} --> {% } %}
			str = str.replace(/{%\s?endfor\s?%}/g, "{% }; %}");

			var fn_str = "var _p=[],print=function(){_p.push.apply(_p,arguments)};" +

		        // Introduce the data as local variables using with(){}
		        "with(obj){\n_p.push('" +

		        // Convert the template into pure JavaScript
		        str
		          .replace(/[\r\t\n]/g, " ")
		          .split("{%").join("\t")
		          .replace(/((^|%})[^\t]*)'/g, "$1\r")
		          .replace(/\t=(.*?)%}/g, "',$1,'")
		          .split("\t").join("');\n")
		          .split("%}").join("\n_p.push('")
		          .split("\r").join("\\'")
		      + "');}return _p.join('');";

			  frappe.template.debug[name] = fn_str;
			try {
				frappe.template.compiled[key] = new Function("obj", fn_str);
			} catch (e) {
				console.log("Error in Template:");
				console.log(fn_str);
				if(e.lineNumber) {
					console.log("Error in Line "+e.lineNumber+", Col "+e.columnNumber+":");
					console.log(fn_str.split("\n")[e.lineNumber - 1]);
				}
			}
	    }

		return frappe.template.compiled[key];
	};
	frappe.render = function(str, data, name) {
		return frappe.template.compile(str, name)(data);
	};
	frappe.render_template = function(name, data) {
		if(name.indexOf(' ')!==-1) {
			var template = name;
		} else {
			var template = frappe.templates[name];
		}
		if(data===undefined) {
			data = {};
		}
		return frappe.render(template, data, name);
	};
	frappe.render_grid = function(opts) {
		// build context
		if(opts.grid) {
			opts.columns = opts.grid.getColumns();
			opts.data = opts.grid.getData().getItems();
		}

		// show landscape view if columns more than 10
		if (opts.landscape == null) {
			if(opts.columns && opts.columns.length > 10) {
				opts.landscape = true;
			} else {
				opts.landscape = false;
			}
		}

		// render content
		if(!opts.content) {
			opts.content = frappe.render_template(opts.template || "print_grid", opts);
		}

		// render HTML wrapper page
		opts.base_url = frappe.urllib.get_base_url();
		opts.print_css = frappe.boot.print_css;
		var html = frappe.render_template("print_template", opts);

		var w = window.open();

		if(!w) {
			frappe.msgprint(__("Please enable pop-ups in your browser"));
		}

		w.document.write(html);
		w.document.close();
	},
	frappe.render_tree = function(opts) {
		opts.base_url = frappe.urllib.get_base_url();
		opts.landscape = false;
		opts.print_css = frappe.boot.print_css;
		var tree = frappe.render_template("print_tree", opts);
		var w = window.open();

		if(!w) {
			frappe.msgprint(__("Please enable pop-ups in your browser"));
		}

		w.document.write(tree);
		w.document.close();
	};
	frappe.render_pdf = function(html, opts) {
		if ( opts === void 0 ) opts = {};

		//Create a form to place the HTML content
		var formData = new FormData();

		//Push the HTML content into an element
		formData.append("html", html);
		if (opts.orientation) {
			formData.append("orientation", opts.orientation);
		}
		var blob = new Blob([], { type: "text/xml"});
		formData.append("blob", blob);

		var xhr = new XMLHttpRequest();
		xhr.open("POST", '/api/method/frappe.utils.print_format.report_to_pdf');
		xhr.setRequestHeader("X-Frappe-CSRF-Token", frappe.csrf_token);
		xhr.responseType = "arraybuffer";

		xhr.onload = function(success) {
			if (this.status === 200) {
				var blob = new Blob([success.currentTarget.response], {type: "application/pdf"});
				var objectUrl = URL.createObjectURL(blob);

				//Open report in a new window
				window.open(objectUrl);
			}
		};
		xhr.send(formData);
	};

	frappe.templates['page'] = '<div class="page-head flex align-center">  <div class="container">   <div class="row flex align-center">    <div class="col-md-7 col-sm-8 col-xs-6 page-title">          <h1 class="flex" style="margin: auto;">      <div class="title-image hide hidden-md hidden-lg">      </div>      <div class="ellipsis title-text"></div>      <span class="indicator whitespace-nowrap hide"></span>     </h1>    </div>    <div class="text-right col-md-5 col-sm-4 col-xs-6 page-actions">          <span class="checked-items-status text-ellipsis text-muted small hide hidden-xs hidden-sm" style="margin-right: 20px;">## items selected</span>     <h6 class="ellipsis sub-heading hide text-muted"></h6>     <span class="page-icon-group hide hidden-xs hidden-sm"></span>           <div class="btn-group menu-btn-group hide">      <button type="button" class="btn btn-default btn-sm dropdown-toggle" data-toggle="dropdown" aria-expanded="false">       <span class="hidden-xs">        <span class="menu-btn-group-label">{%= __("Menu") %}</span>        <span class="caret"></span>       </span>       <span class="visible-xs">        <i class="octicon octicon-triangle-down"></i>       </span>      </button>      <ul class="dropdown-menu" role="menu"></ul>     </div>     <button class="btn btn-secondary btn-default btn-sm hide"></button>     <div class="btn-group actions-btn-group hide">      <button type="button" class="btn btn-primary btn-sm dropdown-toggle" data-toggle="dropdown" aria-expanded="false">       <span class="hidden-xs">        {%= __("Actions") %}        <span class="caret"></span>       </span>       <span class="visible-xs octicon octicon-check"></span>      </button>      <ul class="dropdown-menu" role="menu">      </ul>     </div>     <button class="btn btn-primary btn-sm hide primary-action"></button>    </div>   </div>  </div> </div> <div class="container page-body">  <div class="page-toolbar hide">   <div class="container">   </div>  </div>  <div class="page-wrapper">   <div class="page-content">    <div class="workflow-button-area btn-group pull-right hide"></div>    <div class="clearfix"></div>   </div>  </div> </div>';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	/**
	 * Make a standard page layout with a toolbar and title
	 *
	 * @param {Object} opts
	 *
	 * @param {string} opts.parent [HTMLElement] Parent element
	 * @param {boolean} opts.single_column Whether to include sidebar
	 * @param {string} [opts.title] Page title
	 * @param {Object} [opts.make_page]
	 *
	 * @returns {frappe.ui.Page}
	 */

	/**
	 * @typedef {Object} frappe.ui.Page
	 */


	frappe.ui.make_app_page = function(opts) {
		opts.parent.page = new frappe.ui.Page(opts);
		return opts.parent.page;
	};

	frappe.ui.pages = {};

	frappe.ui.Page = Class.extend({
		init: function(opts) {
			$.extend(this, opts);

			this.set_document_title = true;
			this.buttons = {};
			this.fields_dict = {};
			this.views = {};

			this.make();
			frappe.ui.pages[frappe.get_route_str()] = this;
		},

		make: function() {
			this.wrapper = $(this.parent);
			this.add_main_section();
		},

		get_empty_state: function(title, message, primary_action) {
			var $empty_state = $(("<div class=\"page-card-container\">\n\t\t\t<div class=\"page-card\">\n\t\t\t\t<div class=\"page-card-head\">\n\t\t\t\t\t<span class=\"indicator blue\">\n\t\t\t\t\t\t" + title + "</span>\n\t\t\t\t</div>\n\t\t\t\t<p>" + message + "</p>\n\t\t\t\t<div>\n\t\t\t\t\t<button class=\"btn btn-primary btn-sm\">" + primary_action + "</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>"));

			return $empty_state;
		},

		load_lib: function(callback) {
			frappe.require(this.required_libs, callback);
		},

		add_main_section: function() {
			$(frappe.render_template("page", {})).appendTo(this.wrapper);
			if(this.single_column) {
				// nesting under col-sm-12 for consistency
				this.add_view("main", '<div class="row layout-main">\
					<div class="col-md-12 layout-main-section-wrapper">\
						<div class="layout-main-section"></div>\
						<div class="layout-footer hide"></div>\
					</div>\
				</div>');
			} else {
				this.add_view("main", '<div class="row layout-main">\
				<div class="col-md-2 layout-side-section"></div>\
				<div class="col-md-10 layout-main-section-wrapper">\
					<div class="layout-main-section"></div>\
					<div class="layout-footer hide"></div>\
				</div>\
			</div>');
			}

			this.setup_page();
		},

		setup_page: function() {
			this.$title_area = this.wrapper.find("h1");

			this.$sub_title_area = this.wrapper.find("h6");

			if(this.set_document_title!==undefined)
				{ this.set_document_title = this.set_document_title; }

			if(this.title)
				{ this.set_title(this.title); }

			if(this.icon)
				{ this.get_main_icon(this.icon); }

			this.body = this.main = this.wrapper.find(".layout-main-section");
			this.sidebar = this.wrapper.find(".layout-side-section");
			this.footer = this.wrapper.find(".layout-footer");
			this.indicator = this.wrapper.find(".indicator");

			this.page_actions = this.wrapper.find(".page-actions");

			this.btn_primary = this.page_actions.find(".primary-action");
			this.btn_secondary = this.page_actions.find(".btn-secondary");

			this.menu = this.page_actions.find(".menu-btn-group .dropdown-menu");
			this.menu_btn_group = this.page_actions.find(".menu-btn-group");

			this.actions = this.page_actions.find(".actions-btn-group .dropdown-menu");
			this.actions_btn_group = this.page_actions.find(".actions-btn-group");

			this.page_form = $('<div class="page-form row hide"></div>').prependTo(this.main);
			this.inner_toolbar = $('<div class="form-inner-toolbar hide"></div>').prependTo(this.main);
			this.icon_group = this.page_actions.find(".page-icon-group");

			if(this.make_page) {
				this.make_page();
			}
		},

		set_indicator: function(label, color) {
			this.clear_indicator().removeClass("hide").html(("<span class='hidden-xs'>" + label + "</span>")).addClass(color);
		},

		add_action_icon: function(icon, click) {
			return $('<a class="text-muted no-decoration"><i class="'+icon+'"></i></a>')
				.appendTo(this.icon_group.removeClass("hide"))
				.click(click);
		},

		clear_indicator: function() {
			return this.indicator.removeClass().addClass("indicator whitespace-nowrap hide");
		},

		get_icon_label: function(icon, label) {
			return '<i class="visible-xs ' + icon + '"></i><span class="hidden-xs">' + label + '</span>'
		},

		set_action: function(btn, opts) {
			var me = this;
			if (opts.icon) {
				opts.label = this.get_icon_label(opts.icon, opts.label);
			}

			this.clear_action_of(btn);

			btn.removeClass("hide")
				.prop("disabled", false)
				.html(opts.label)
				.on("click", function() {
					var response = opts.click.apply(this);
					me.btn_disable_enable(btn, response);
				});

			if (opts.working_label) {
				btn.attr("data-working-label", opts.working_label);
			}
		},

		set_primary_action: function(label, click, icon, working_label) {
			this.set_action(this.btn_primary, {
				label: label,
				click: click,
				icon: icon,
				working_label: working_label
			});

			return this.btn_primary;
		},

		set_secondary_action: function(label, click, icon, working_label) {
			this.set_action(this.btn_secondary, {
				label: label,
				click: click,
				icon: icon,
				working_label: working_label
			});

			return this.btn_secondary;
		},


		clear_action_of: function(btn) {
			btn.addClass("hide").unbind("click").removeAttr("data-working-label");
		},

		clear_primary_action: function() {
			this.clear_action_of(this.btn_primary);
		},

		clear_secondary_action: function() {
			this.clear_action_of(this.btn_secondary);
		},

		clear_actions: function() {
			this.clear_primary_action();
			this.clear_secondary_action();
		},

		clear_icons: function() {
			this.icon_group.addClass("hide").empty();
		},

		//--- Menu --//

		add_menu_item: function(label, click, standard) {
			return this.add_dropdown_item(label, click, standard, this.menu);
		},

		clear_menu: function() {
			this.clear_btn_group(this.menu);
		},

		show_menu: function() {
			this.menu_btn_group.removeClass("hide");
		},

		hide_menu: function() {
			this.menu_btn_group.addClass("hide");
		},

		show_icon_group: function() {
			this.icon_group.removeClass("hide");
		},

		hide_icon_group: function() {
			this.icon_group.addClass("hide");
		},

		//--- Actions Menu--//

		show_actions_menu: function() {
			this.actions_btn_group.removeClass("hide");
		},

		hide_actions_menu: function() {
			this.actions_btn_group.addClass("hide");
		},


		add_action_item: function(label, click, standard) {
			return this.add_dropdown_item(label, click, standard, this.actions);
		},

		add_actions_menu_item: function(label, click, standard) {
			return this.add_dropdown_item(label, click, standard, this.actions, false);
		},

		clear_actions_menu: function() {
			this.clear_btn_group(this.actions);
		},


		//-- Generic --//

		/*
		* Add label to given drop down menu. If label, is already contained in the drop
		* down menu, it will be ignored.
		* @param {string} label - Text for the drop down menu
		* @param {function} click - function to be called when `label` is clicked
		* @param {Boolean} standard
		* @param {object} parent - DOM object representing the parent of the drop down item lists
		* @param {Boolean} show_parent - Whether to show the dropdown button if dropdown item is added
		*/
		add_dropdown_item: function(label, click, standard, parent, show_parent) {
			if ( show_parent === void 0 ) show_parent=true;

			var item_selector = 'li > a.grey-link';
			if(show_parent) {
				parent.parent().removeClass("hide");
			}

			var $li = $('<li><a class="grey-link">'+ label +'</a><li>'),
				$link = $li.find("a").on("click", click);

			if (this.is_in_group_button_dropdown(parent, item_selector, label)) { return; }

			if(standard) {
				$li.appendTo(parent);
			} else {
				this.divider = parent.find(".divider");
				if(!this.divider.length) {
					this.divider = $('<li class="divider user-action"></li>').prependTo(parent);
				}
				$li.addClass("user-action").insertBefore(this.divider);
			}

			return $link;
		},

		/*
		* Check if there already exists a button with a specified label in a specified button group
		* @param {object} parent - This should be the `ul` of the button group.
		* @param {string} selector - CSS Selector of the button to be searched for. By default, it is `li`.
		* @param {string} label - Label of the button
		*/
		is_in_group_button_dropdown: function(parent, selector, label){
			if (!selector) { selector = 'li'; }

			if (!label || !parent) { return false; }

			var result = $(parent).find((selector + ":contains('" + label + "')"))
				.filter(function() {
					return $(this).text() === label;
				});
			return result.length > 0;
		},

		clear_btn_group: function(parent) {
			parent.empty();
			parent.parent().addClass("hide");
		},

		add_divider: function() {
			return $('<li class="divider"></li>').appendTo(this.menu);
		},

		get_or_add_inner_group_button: function(label) {
			var $group = this.inner_toolbar.find('.btn-group[data-label="'+encodeURIComponent(label)+'"]');
			if(!$group.length) {
				$group = $('<div class="btn-group" data-label="'+encodeURIComponent(label)+'" style="margin-left: 10px;">\
				<button type="button" class="btn btn-default dropdown-toggle btn-xs" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">\
				'+label+' <span class="caret"></span></button>\
				<ul class="dropdown-menu" style="margin-top: -8px;"></ul></div>').appendTo(this.inner_toolbar);
			}
			return $group;
		},

		get_inner_group_button: function(label) {
			return this.inner_toolbar.find('.btn-group[data-label="'+encodeURIComponent(label)+'"]');
		},

		set_inner_btn_group_as_primary: function(label) {
			this.get_or_add_inner_group_button(label).find("button").removeClass("btn-default").addClass("btn-primary");
		},

		btn_disable_enable: function(btn, response) {
			if (response && response.then) {
				btn.prop('disabled', true);
				response.then(function () {
					btn.prop('disabled', false);
				});
			} else if (response && response.always) {
				btn.prop('disabled', true);
				response.always(function () {
					btn.prop('disabled', false);
				});
			}
		},

		/*
		* Add button to button group. If there exists another button with the same label,
		* `add_inner_button` will not add the new button to the button group even if the callback
		* function is different.
		*
		* @param {string} label - Label of the button to be added to the group
		* @param {object} action - function to be called when button is clicked
		* @param {string} group - Label of the group button
		*/
		add_inner_button: function(label, action, group, type) {
			if ( type === void 0 ) type="default";

			var me = this;
			var _action = function() {
				var btn = $(this);
				var response = action();
				me.btn_disable_enable(btn, response);
			};
			if(group) {
				var $group = this.get_or_add_inner_group_button(group);
				$(this.inner_toolbar).removeClass("hide");

				if (!this.is_in_group_button_dropdown($group.find(".dropdown-menu"), 'li', label)) {
					return $('<li><a data-label="'+encodeURIComponent(label)+'">'+label+'</a></li>')
						.on('click', _action)
						.appendTo($group.find(".dropdown-menu"));
				}

			} else {
				var button = this.inner_toolbar.find('button[data-label="'+encodeURIComponent(label)+'"]');
				if( button.length == 0 ) {
					return $('<button data-label="'+encodeURIComponent(label)+"\" class=\"btn btn-" + type + " btn-xs\" style=\"margin-left: 10px;\">"+__(label)+'</btn>')
						.on("click", _action)
						.appendTo(this.inner_toolbar.removeClass("hide"));
				} else {
					return button;
				}
			}
		},

		remove_inner_button: function(label, group) {
			if (typeof label === 'string') {
				label = [label];
			}
			// translate
			label = label.map(function (l) { return __(l); });

			if (group) {
				var $group = this.get_inner_group_button(__(group));
				if($group.length) {
					$group.find('.dropdown-menu li a[data-label="'+encodeURIComponent(label)+'"]').remove();
				}
				if ($group.find('.dropdown-menu li a').length === 0) { $group.remove(); }
			} else {

				this.inner_toolbar.find('button[data-label="'+encodeURIComponent(label)+'"]').remove();
			}
		},

		add_inner_message: function(message) {
			var $message = $(("<span class='inner-page-message text-muted small'>" + message + "</div>"));
			this.inner_toolbar.find('.inner-page-message').remove();
			this.inner_toolbar.removeClass("hide").prepend($message);

			return $message;
		},

		clear_inner_toolbar: function() {
			this.inner_toolbar.empty().addClass("hide");
		},

		//-- Sidebar --//

		add_sidebar_item: function(label, action, insert_after, prepend) {
			var parent = this.sidebar.find(".sidebar-menu.standard-actions");
			var li = $('<li>');
			var link = $('<a>').html(label).on("click", action).appendTo(li);

			if (insert_after) {
				li.insertAfter(parent.find(insert_after));
			} else {
				if(prepend) {
					li.prependTo(parent);
				} else {
					li.appendTo(parent);
				}
			}
			return link;
		},

		//---//

		clear_user_actions: function() {
			this.menu.find(".user-action").remove();
		},

		// page::title
		get_title_area: function() {
			return this.$title_area;
		},

		set_title: function(txt, icon, stripHtml, tabTitle) {
			if ( icon === void 0 ) icon = '';
			if ( stripHtml === void 0 ) stripHtml = true;
			if ( tabTitle === void 0 ) tabTitle = '';

			if(!txt) { txt = ""; }

			if(stripHtml) {
				txt = strip_html(txt);
			}
			this.title = txt;

			frappe.utils.set_title(tabTitle || txt);
			if(icon) {
				txt = '<span class="'+ icon +' text-muted" style="font-size: inherit;"></span> ' + txt;
			}
			this.$title_area.find(".title-text").html(txt);
		},

		set_title_sub: function(txt) {
			// strip icon
			this.$sub_title_area.html(txt).toggleClass("hide", !!!txt);
		},

		get_main_icon: function(icon) {
			return this.$title_area.find(".title-icon")
				.html('<i class="'+icon+' fa-fw"></i> ')
				.toggle(true);
		},

		add_help_button: function(txt) {
			//
		},

		add_button: function(label, click, icon, is_title) {
			//
		},

		add_dropdown_button: function(parent, label, click, icon) {
			frappe.ui.toolbar.add_dropdown_button(parent, label, click, icon);
		},

		// page::form
		add_label: function(label) {
			this.show_form();
			return $("<label class='col-md-1 page-only-label'>"+label+" </label>")
				.appendTo(this.page_form);
		},
		add_select: function(label, options) {
			var field = this.add_field({label:label, fieldtype:"Select"});
			return field.$wrapper.find("select").empty().add_options(options);
		},
		add_data: function(label) {
			var field = this.add_field({label: label, fieldtype: "Data"});
			return field.$wrapper.find("input").attr("placeholder", label);
		},
		add_date: function(label, date) {
			var field = this.add_field({label: label, fieldtype: "Date", "default": date});
			return field.$wrapper.find("input").attr("placeholder", label);
		},
		add_check: function(label) {
			return $("<div class='checkbox'><label><input type='checkbox'>" + label + "</label></div>")
				.appendTo(this.page_form)
				.find("input");
		},
		add_break: function() {
			// add further fields in the next line
			this.page_form.append('<div class="clearfix invisible-xs"></div>');
		},
		add_field: function(df) {
			this.show_form();

			if (!df.placeholder) {
				df.placeholder = df.label;
			}

			var f = frappe.ui.form.make_control({
				df: df,
				parent: this.page_form,
				only_input: df.fieldtype=="Check" ? false : true,
			});
			f.refresh();
			$(f.wrapper)
				.addClass('col-md-2')
				.attr("title", __(df.label)).tooltip();

			// html fields in toolbar are only for display
			if (df.fieldtype=='HTML') {
				return;
			}

			// hidden fields dont have $input
			if (!f.$input) { f.make_input(); }

			f.$input.addClass("input-sm").attr("placeholder", __(df.label));

			if(df.fieldtype==="Check") {
				$(f.wrapper).find(":first-child")
					.removeClass("col-md-offset-4 col-md-8");
			}

			if(df.fieldtype=="Button") {
				$(f.wrapper).find(".page-control-label").html("&nbsp;");
				f.$input.addClass("btn-sm").css({"width": "100%", "margin-top": "-1px"});
			}

			if(df["default"])
				{ f.set_input(df["default"]); }
			this.fields_dict[df.fieldname || df.label] = f;
			return f;
		},
		clear_fields: function() {
			this.page_form.empty();
		},
		show_form: function() {
			this.page_form.removeClass("hide");
		},
		hide_form: function() {
			this.page_form.addClass("hide");
		},
		get_form_values: function() {
			var values = {};
			this.page_form.fields_dict.forEach(function(field, key) {
				values[key] = field.get_value();
			});
			return values;
		},
		add_view: function(name, html) {
			var element = html;
			if(typeof (html) === "string") {
				element = $(html);
			}
			this.views[name] = element.appendTo($(this.wrapper).find(".page-content"));
			if(!this.current_view) {
				this.current_view = this.views[name];
			} else {
				this.views[name].toggle(false);
			}
			return this.views[name];
		},
		set_view: function(name) {
			if(this.current_view_name===name)
				{ return; }
			this.current_view && this.current_view.toggle(false);
			this.current_view = this.views[name];

			this.previous_view_name = this.current_view_name;
			this.current_view_name = name;

			this.views[name].toggle(true);

			this.wrapper.trigger('view-change');
		},
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// License: GNU General Public License v3. See license.txt

	frappe.provide("frappe.ui");

	frappe.ui.Slide = class Slide {
		constructor(slide) {
		if ( slide === void 0 ) slide = null;

			$.extend(this, slide);
			this.setup();
		}

		setup() {
			this.$wrapper = $('<div class="slide-wrapper hidden"></div>')
				.attr({"data-slide-id": this.id, "data-slide-name": this.name})
				.appendTo(this.parent);
		}

		// Make has to be called manually, to account for on-demand use cases
		make() {
			if(this.before_load) { this.before_load(this); }

			this.$body = $(("<div class=\"slide-body\">\n\t\t\t<div class=\"content text-center\">\n\t\t\t\t<p class=\"title lead\">" + (this.title) + "</p>\n\t\t\t</div>\n\t\t\t<div class=\"form-wrapper\">\n\t\t\t\t<div class=\"form\"></div>\n\t\t\t\t<div class=\"add-more text-center\" style=\"margin-top: 5px;\">\n\t\t\t\t\t<a class=\"form-more-btn hide btn btn-default btn-xs\">" + (__("Add More")) + "</a>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>")).appendTo(this.$wrapper);

			this.$content = this.$body.find(".content");
			this.$form = this.$body.find(".form");
			this.$primary_btn = this.slides_footer.find('.primary');

			if(this.help) { this.$content.append($(("<p class=\"slide-help\">" + (this.help) + "</p>"))); }
			if(this.image_src) { this.$content.append(
				$(("<img src=\"" + (this.image_src) + "\" style=\"margin: 20px;\">"))); }

			this.reqd_fields = [];

			this.refresh();
			this.made = true;
		}

		refresh() {
			this.render_parent_dots();
			if(!this.done) {
				this.setup_form();
			} else {
				this.setup_done_state();
			}
		}

		setup_form() {
			this.form = new frappe.ui.FieldGroup({
				fields: this.get_atomic_fields(),
				body: this.$form[0],
				no_submit_on_enter: true
			});
			this.form.make();
			if(this.add_more) { this.bind_more_button(); }

			this.set_reqd_fields();

			if(this.onload) { this.onload(this); }
			this.set_reqd_fields();
		}

		// Form methods
		get_atomic_fields() {
			var this$1 = this;

			var fields = JSON.parse(JSON.stringify(this.fields));
			if(this.add_more) {
				this.count = 1;
				fields = fields.map(function (field, i) {
					if(field.fieldname) {
						field.fieldname += '_1';
					}
					if(i === 1 && this$1.mandatory_entry) {
						field.reqd = 1;
					}
					if(!field.static) {
						if(field.label) { field.label += ' 1'; }
					}
					return field;
				});
			}
			return fields;
		}

		set_reqd_fields() {
			var this$1 = this;

			var dict = this.form.fields_dict;
			this.reqd_fields = [];
			Object.keys(dict).map(function (key) {
				if(dict[key].df.reqd) {
					this$1.reqd_fields.push(dict[key]);
				}
			});
		}

		set_values() {
			this.values = this.form.get_values();
			if(this.values===null) {
				return false;
			}
			if(this.validate && !this.validate()) {
				return false;
			}
			return true;
		}

		bind_more_button() {
			var this$1 = this;

			this.$more = this.$body.find('.form-more-btn');
			this.$more.removeClass('hide')
				.on('click', function () {
					this$1.count++;
					var fields = JSON.parse(JSON.stringify(this$1.fields));
					this$1.form.add_fields(fields.map(function (field) {
						if(field.fieldname) { field.fieldname += '_' + this$1.count; }
						if(!field.static) {
							if(field.label) { field.label += ' ' + this$1.count; }
						}
						return field;
					}));
					if(this$1.count === this$1.max_count) {
						this$1.$more.addClass('hide');
					}
				});
		}

		// Primary button (outside of slide)
		resetup_primary_button() {
			this.unbind_primary_action();
			this.bind_fields_to_action_btn();
			this.reset_action_button_state();
			this.bind_primary_action();
		}

		bind_fields_to_action_btn() {
			var me = this;
			this.reqd_fields.map(function (field) {
				field.$wrapper.on('change input', function () {
					me.reset_action_button_state();
				});
			});
		}

		reset_action_button_state() {
			var empty_fields = this.reqd_fields.filter(function (field) {
				return !field.get_value();
			});
			if(empty_fields.length) {
				this.slides_footer.find('.action').addClass('disabled');
			} else {
				this.slides_footer.find('.action').removeClass('disabled');
			}
		}

		unbind_primary_action() {
			this.slides_footer.find(".primary").off();
		}

		bind_primary_action() {
			var this$1 = this;

			this.slides_footer.find(".primary").on('click', function () {
				this$1.primary_action();
			});
		}

		before_show() { }

		show_slide() {
			this.$wrapper.removeClass("hidden");
			this.before_show();
			this.resetup_primary_button();
			if(!this.done) {
				this.$body.find('.form-control').first().focus();
				this.$primary_btn.show();
			} else {
				this.$primary_btn.hide();
			}
		}

		hide_slide() {
			this.$wrapper.addClass("hidden");
		}

		get_input(fieldname) {
			return this.form.get_input(fieldname);
		}

		get_field(fieldname) {
			return this.form.get_field(fieldname);
		}

		get_value(fieldname) {
			return this.form.get_value(fieldname);
		}

		destroy() {
			this.$body.remove();
		}

		primary_action() { }
	};

	frappe.ui.Slides = class Slides {
		constructor(ref) {
		var parent = ref.parent; if ( parent === void 0 ) parent = null;
		var slides = ref.slides; if ( slides === void 0 ) slides = [];
		var slide_class = ref.slide_class; if ( slide_class === void 0 ) slide_class = null;
		var unidirectional = ref.unidirectional; if ( unidirectional === void 0 ) unidirectional = 0;
		var done_state = ref.done_state; if ( done_state === void 0 ) done_state = 0;
		var before_load = ref.before_load; if ( before_load === void 0 ) before_load = null;
		var on_update = ref.on_update; if ( on_update === void 0 ) on_update = null;

			this.parent = parent;
			this.slides = slides;
			this.slide_class = slide_class;
			this.unidirectional = unidirectional;
			this.done_state = done_state;
			this.before_load = before_load;
			this.on_update = on_update;

			this.slide_dict = {};

			//In case of refreshing
			this.made_slide_ids = [];
			this.values = {};
			this.make();
		}

		make() {
			this.container = $('<div>').addClass("slides-wrapper").attr({"tabindex": -1})
				.appendTo(this.parent);
			this.$slide_progress = $("<div>").addClass("slides-progress text-center text-extra-muted")
				.appendTo(this.container);
			this.$body = $("<div>").addClass("slide-container")
				.appendTo(this.container);
			this.$footer = $("<div>").addClass("slide-footer")
				.appendTo(this.container);

			this.render_progress_dots();
			this.make_prev_next_buttons();
			if(this.before_load) { this.before_load(this.$footer); }

			// can be on demand
			this.setup();

			// can be on demand
			this.show_slide(0);
		}

		setup() {
			var this$1 = this;

			this.slides.map(function (slide, id) {
				if(!this$1.slide_dict[id]) {
					this$1.slide_dict[id] = new (this$1.slide_class)(
						$.extend(this$1.slides[id], {
							parent: this$1.$body,
							slides_footer: this$1.$footer,
							render_parent_dots: this$1.render_progress_dots.bind(this$1),
							id: id,
						})
					);
					if(!this$1.unidirectional) {
						this$1.slide_dict[id].make();
					}
				} else {
					if(this$1.made_slide_ids.includes(id+"")) {
						this$1.slide_dict[id].destroy();
						this$1.slide_dict[id].make();
					}
				}
			});
		}

		refresh(id) {
			this.render_progress_dots();
			this.show_hide_prev_next(id);
			this.$body.find('.form-control').first().focus();
		}

		render_progress_dots() {
			var this$1 = this;

			// Depends on this.unidirectional and this.done_state
			// Can be called by a slide to update states
			this.$slide_progress.empty();

			this.slides.map(function (slide, id) {
				var $dot = $("<i class=\"fa fa-fw fa-circle\"> </i> ")
					.attr({'data-step-id': id});

				if(this$1.done_state && (this$1.slide_dict[id] &&
					this$1.slide_dict[id].done || slide.done)) {
					$dot.addClass('text-success');
				}
				if((this$1.unidirectional && id <= this$1.current_id) ||
					id === this$1.current_id) {
					$dot.addClass('active');
				}
				// Add pointer event for non-unidirectional
				this$1.$slide_progress.append($dot);
			});

			this.completed = 0;
			this.slides.map(function (slide, i) {
				if(this$1.slide_dict[i]) {
					if(this$1.slide_dict[i].done) { this$1.completed++; }
				} else {
					if(slide.done) { this$1.completed++; }
				}
			});
			if(this.on_update) {this.on_update(this.completed, this.slides.length);}

			if(!this.unidirectional) { this.bind_progress_dots(); }
		}

		make_prev_next_buttons() {
			var this$1 = this;

			$(("<div class=\"row\">\n\t\t\t<div class=\"col-sm-4\">\n\t\t\t\t<a class=\"prev-btn btn btn-default btn-sm\" tabindex=\"0\">" + (__("Previous")) + "</a>\n\t\t\t</div>\n\t\t\t<div class=\"col-sm-8 text-right\">\n\t\t\t\t<a class=\"next-btn btn btn-default btn-sm\" tabindex=\"0\">" + (__("Next")) + "</a>\n\t\t\t</div>\n\t\t</div>")).appendTo(this.$footer);

			this.$prev_btn = this.$footer.find('.prev-btn').attr('tabIndex', 0)
				.on('click', function () { this$1.show_slide(this$1.current_id - 1); });

			this.$next_btn = this.$footer.find('.next-btn').attr('tabIndex', 0)
				.on('click', function () {
					if (!this$1.unidirectional || (this$1.unidirectional && this$1.current_slide.set_values())) {
						this$1.show_slide(this$1.current_id + 1);
					}
				});
		}

		bind_progress_dots() {
			var me = this;
			this.$slide_progress.find('.fa-circle').addClass('link').on('click', function() {
				var id = $(this).attr('data-step-id');
				me.show_slide(id);
			});
		}

		before_show_slide() {
			return true;
		}

		show_slide(id) {
			id = cint(id);
			if(!this.before_show_slide() ||
				(this.current_slide && this.current_id===id)) {
				return;
			}

			this.update_values();

			if(this.current_slide) { this.current_slide.hide_slide(); }
			if(this.unidirectional && !this.slide_dict[id].made) {
				this.slide_dict[id].make();
			}
			this.current_id = id;
			this.current_slide = this.slide_dict[id];
			this.current_slide.show_slide();
			this.refresh(id);
		}

		destroy_slide(id) {
			if(this.slide_dict[id]) { this.slide_dict[id].destroy(); }
			this.slide_dict[id] = null;
		}

		on_update(completed, total) {}

		show_hide_prev_next(id) {
			(id === 0) ?
				this.$prev_btn.hide() : this.$prev_btn.show();
			(id + 1 === this.slides.length) ?
				this.$next_btn.hide() : this.$next_btn.show();
		}

		get_values() {
			var values = {};
			$.each(this.slide_dict, function(id, slide) {
				if(slide.values) {
					$.extend(values, slide.values);
				}
			});
			return values;
		}

		update_values() {
			this.values = $.extend(this.values, this.get_values());
		}
	};

	frappe.find = {
		page_primary_action: function () {
			return $('.page-actions:visible .btn-primary');
		},
		field: function (fieldname, value) {
			return new Promise(function (resolve) {
				var input = $(("[data-fieldname=\"" + fieldname + "\"] :input"));
				if(value) {
					input.val(value).trigger('change');
					frappe.after_ajax(function () { resolve(input); });
				} else {
					resolve(input);
				}
			});
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.ui.IconBar = Class.extend({
		init: function(parent, n_groups) {
			this.parent = parent;
			this.buttons = {};
			this.make(n_groups);
		},
		make: function(n_groups) {
			this.$wrapper = $('<div class="iconbar-wrapper hide"></div>').appendTo(this.parent);
			for(var i=0; i<n_groups; i++) {
				this.get_group(i+1);
			}
		},
		get_group: function(group) {
			var $ul = this.$wrapper.find(".iconbar-"+group+" ul");
			
			if(!$ul.length)
				{ $ul = $('<div class="iconbar iconbar-'+group+' hide"><ul></ul></div>')
					.appendTo(this.$wrapper).find("ul"); }
			
			return $ul;
		},
		add_btn: function(group, icon, label, click) {
			var $ul = this.get_group(group);
			var $li = $('<li><i class="'+icon+'"></i></li>')
				.appendTo($ul)
				.on("click", function() {
					click.apply(this);
					return false;
				});
				
			$li.find("i").attr("title", label).tooltip();

				
			this.$wrapper.find(".iconbar-" + group).removeClass("hide");
			this.show();
			return $li;
		},
		hide: function(group) {
			if(group) {
				this.$wrapper.find(".iconbar-" + group).addClass("hide");
				this.check_if_all_hidden();
			} else {
				this.$wrapper.addClass("hide").trigger("hidden");
			}
		},
		show: function(group) {
			if(group) {
				this.$wrapper.find(".iconbar-" + group).removeClass("hide");
				this.show();
			} else {
				if(this.$wrapper.hasClass("hide"))
					{ this.$wrapper.removeClass("hide").trigger("shown"); }
			}
		},
		clear: function(group) {
			this.$wrapper.find(".iconbar-" + group).addClass("hide").find("ul").empty();
			this.check_if_all_hidden();
		},
		check_if_all_hidden: function() {
			if(!this.$wrapper.find(".iconbar:visible").length) {
				this.hide();
			}
		}
	});

	// Copyright (c) 2018, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.ui.form.LinkSelector = Class.extend({
		init: function (opts) {
			/* help: Options: doctype, get_query, target */
			$.extend(this, opts);

			var me = this;
			if (this.doctype != "[Select]") {
				frappe.model.with_doctype(this.doctype, function (r) {
					me.make();
				});
			} else {
				this.make();
			}
		},
		make: function () {
			var me = this;

			this.start = 0;
			this.dialog = new frappe.ui.Dialog({
				title: __("Select {0}", [(this.doctype == '[Select]') ? __("value") : __(this.doctype)]),
				fields: [
					{
						fieldtype: "Data", fieldname: "txt", label: __("Beginning with"),
						description: __("You can use wildcard %"),
					},
					{
						fieldtype: "HTML", fieldname: "results"
					},
					{
						fieldtype: "Button", fieldname: "more", label: __("More"), click: function () {
							me.start += 20;
							me.search();
						}
					}
				],
				primary_action_label: __("Search"),
				primary_action: function () {
					me.start = 0;
					me.search();
				}
			});

			if (this.txt)
				{ this.dialog.fields_dict.txt.set_input(this.txt); }

			this.dialog.get_input("txt").on("keypress", function (e) {
				if (e.which === 13) {
					me.start = 0;
					me.search();
				}
			});
			this.dialog.show();
			this.search();
		},
		search: function () {
			var args = {
				txt: this.dialog.fields_dict.txt.get_value(),
				searchfield: "name",
				start: this.start
			};
			var me = this;

			if (this.target.set_custom_query) {
				this.target.set_custom_query(args);
			}

			// load custom query from grid
			if (this.target.is_grid && this.target.fieldinfo[this.fieldname]
				&& this.target.fieldinfo[this.fieldname].get_query) {
				$.extend(args,
					this.target.fieldinfo[this.fieldname].get_query(cur_frm.doc));
			}

			frappe.link_search(this.doctype, args, function (r) {
				var parent = me.dialog.fields_dict.results.$wrapper;
				if (args.start === 0) {
					parent.empty();
				}

				if (r.values.length) {
					$.each(r.values, function (i, v) {
						var row = $(repl('<div class="row link-select-row">\
						<div class="col-xs-4">\
							<b><a href="#">%(name)s</a></b></div>\
						<div class="col-xs-8">\
							<span class="text-muted">%(values)s</span></div>\
						</div>', {
								name: v[0],
								values: v.splice(1).join(", ")
							})).appendTo(parent);

						row.find("a")
							.attr('data-value', v[0])
							.click(function () {
								var value = $(this).attr("data-value");
								if (me.target.is_grid) {
									// set in grid
									me.set_in_grid(value);
								} else {
									if (me.target.doctype)
										{ me.target.parse_validate_and_set_in_model(value); }
									else {
										me.target.set_input(value);
										me.target.$input.trigger("change");
									}
									me.dialog.hide();
								}
								return false;
							});
					});
				} else {
					$('<p><br><span class="text-muted">' + __("No Results") + '</span>'
						+ (frappe.model.can_create(me.doctype) ?
							('<br><br><a class="new-doc btn btn-default btn-sm">'
								+ __('Create a new {0}', [__(me.doctype)]) + "</a>") : '')
						+ '</p>').appendTo(parent).find(".new-doc").click(function () {
							frappe.new_doc(me.doctype);
						});
				}

				if (r.values.length < 20) {
					var more_btn = me.dialog.fields_dict.more.$wrapper;
					more_btn.hide();
				}

			}, this.dialog.get_primary_btn());

		},
		set_in_grid: function (value) {
			var me = this, updated = false;
			var d = null;
			if (this.qty_fieldname) {
				frappe.prompt({
					fieldname: "qty", fieldtype: "Float", label: "Qty",
					"default": 1, reqd: 1
				}, function (data) {
					$.each(me.target.frm.doc[me.target.df.fieldname] || [], function (i, d) {
						if (d[me.fieldname] === value) {
							frappe.model.set_value(d.doctype, d.name, me.qty_fieldname, data.qty);
							frappe.show_alert(__("Added {0} ({1})", [value, d[me.qty_fieldname]]));
							updated = true;
							return false;
						}
					});
					if (!updated) {
						frappe.run_serially([
							function () {
								d = me.target.add_new_row();
							},
							function () { return frappe.timeout(0.1); },
							function () { return frappe.model.set_value(d.doctype, d.name, me.fieldname, value); },
							function () { return frappe.timeout(0.5); },
							function () { return frappe.model.set_value(d.doctype, d.name, me.qty_fieldname, data.qty); },
							function () { return frappe.show_alert(__("Added {0} ({1})", [value, data.qty])); }
						]);
					}
				}, __("Set Quantity"), __("Set"));
			} else if (me.dynamic_link_field) {
				var d = me.target.add_new_row();
				frappe.model.set_value(d.doctype, d.name, me.dynamic_link_field, me.dynamic_link_reference);
				frappe.model.set_value(d.doctype, d.name, me.fieldname, value);
				frappe.show_alert(__("{0} {1} added", [me.dynamic_link_reference, value]));
			} else {
				var d = me.target.add_new_row();
				frappe.model.set_value(d.doctype, d.name, me.fieldname, value);
				frappe.show_alert(__("{0} added", [value]));
			}
		}
	});

	frappe.link_search = function (doctype, args, callback, btn) {
		if (!args) {
			args = {
				txt: ''
			};
		}
		args.doctype = doctype;
		if (!args.searchfield) {
			args.searchfield = 'name';
		}

		frappe.call({
			method: "frappe.desk.search.search_widget",
			type: "GET",
			args: args,
			callback: function (r) {
				callback && callback(r);
			},
			btn: btn
		});
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.ui.form.MultiSelectDialog = Class.extend({
		init: function(opts) {
			/* Options: doctype, target, setters, get_query, action */
			$.extend(this, opts);

			var me = this;
			if(this.doctype!="[Select]") {
				frappe.model.with_doctype(this.doctype, function(r) {
					me.make();
				});
			} else {
				this.make();
			}
		},
		make: function() {
			var me = this;

			this.page_length = 20;
			this.start = 0;

			var fields = [
				{
					fieldtype: "Data",
					label: __("Search Term"),
					fieldname: "search_term"
				},
				{
					fieldtype: "Column Break"
				}
			];
			var count = 0;
			if(!this.date_field) {
				this.date_field = "transaction_date";
			}
			Object.keys(this.setters).forEach(function(setter) {
				fields.push({
					fieldtype: me.target.fields_dict[setter].df.fieldtype,
					label: me.target.fields_dict[setter].df.label,
					fieldname: setter,
					options: me.target.fields_dict[setter].df.options,
					default: me.setters[setter]
				});
				if (count++ < Object.keys(me.setters).length) {
					fields.push({fieldtype: "Column Break"});
				}
			});

			fields = fields.concat([
				{
					"fieldname":"date_range",
					"label": __("Date Range"),
					"fieldtype": "DateRange",
				},
				{ fieldtype: "Section Break" },
				{ fieldtype: "HTML", fieldname: "results_area" },
				{ fieldtype: "Button", fieldname: "more_btn", label: __("More"),
					click: function(){
						me.start += 20;
						frappe.flags.auto_scroll = true;
						me.get_results();
					}
				}
			]);

			var doctype_plural = !this.doctype.endsWith('y') ? this.doctype + 's'
				: this.doctype.slice(0, -1) + 'ies';

			this.dialog = new frappe.ui.Dialog({
				title: __("Select {0}", [(this.doctype=='[Select]') ? __("value") : __(doctype_plural)]),
				fields: fields,
				primary_action_label: __("Get Items"),
				secondary_action_label: __("Make {0}", [me.doctype]),
				primary_action: function() {
					me.action(me.get_checked_values(), me.args);
				},
				secondary_action: function(e) {
					// If user wants to close the modal
					if (e) {
						frappe.route_options = {};

						Object.keys(me.setters).forEach(function(setter) {
							frappe.route_options[setter] = me.dialog.fields_dict[setter].get_value() || undefined;
						});

						frappe.new_doc(me.doctype, true);
					}
				}
			});

			this.$parent = $(this.dialog.body);
			this.$wrapper = this.dialog.fields_dict.results_area.$wrapper.append("<div class=\"results\"\n\t\t\tstyle=\"border: 1px solid #d1d8dd; border-radius: 3px; height: 300px; overflow: auto;\"></div>");

			this.$results = this.$wrapper.find('.results');
			this.$results.append(this.make_list_row());

			this.args = {};

			this.bind_events();
			this.get_results();
			this.dialog.show();
		},

		bind_events: function() {
			var this$1 = this;

			var me = this;

			this.$results.on('click', '.list-item-container', function (e) {
				if (!$(e.target).is(':checkbox') && !$(e.target).is('a')) {
					$(this).find(':checkbox').trigger('click');
				}
			});
			this.$results.on('click', '.list-item--head :checkbox', function (e) {
				this$1.$results.find('.list-item-container .list-row-check')
					.prop("checked", ($(e.target).is(':checked')));
			});

			this.$parent.find('.input-with-feedback').on('change', function (e) {
				frappe.flags.auto_scroll = false;
				this$1.get_results();
			});

			this.$parent.find('[data-fieldname="date_range"]').on('blur', function (e) {
				frappe.flags.auto_scroll = false;
				this$1.get_results();
			});

			this.$parent.find('[data-fieldname="search_term"]').on('input', function (e) {
				var $this = $(this$1);
				clearTimeout($this.data('timeout'));
				$this.data('timeout', setTimeout(function() {
					frappe.flags.auto_scroll = false;
					me.get_results();
				}, 300));
			});
		},

		get_checked_values: function() {
			return this.$results.find('.list-item-container').map(function() {
				if ($(this).find('.list-row-check:checkbox:checked').length > 0 ) {
					return $(this).attr('data-item-name');
				}
			}).get();
		},

		make_list_row: function(result) {
			if ( result === void 0 ) result={};

			var me = this;
			// Make a head row by default (if result not passed)
			var head = Object.keys(result).length === 0;

			var contents = "";
			var columns = (["name"].concat(Object.keys(this.setters))).concat("Date");
			columns.forEach(function(column) {
				contents += "<div class=\"list-item__content ellipsis\">\n\t\t\t\t" + (head ? ("<span class=\"ellipsis\">" + (__(frappe.model.unscrub(column))) + "</span>")

						: (column !== "name" ? ("<span class=\"ellipsis\">" + (__(result[column])) + "</span>")
							: ("<a href=\"" + ("#Form/"+ me.doctype + "/" + result[column]) + "\" class=\"list-id ellipsis\">\n\t\t\t\t\t\t\t" + (__(result[column])) + "</a>"))) + "\n\t\t\t</div>";
			});

			var $row = $(("<div class=\"list-item\">\n\t\t\t<div class=\"list-item__content\" style=\"flex: 0 0 10px;\">\n\t\t\t\t<input type=\"checkbox\" class=\"list-row-check\" " + (result.checked ? 'checked' : '') + ">\n\t\t\t</div>\n\t\t\t" + contents + "\n\t\t</div>"));

			head ? $row.addClass('list-item--head')
				: $row = $(("<div class=\"list-item-container\" data-item-name=\"" + (result.name) + "\"></div>")).append($row);
			return $row;
		},

		render_result_list: function(results, more) {
			if ( more === void 0 ) more = 0;

			var me = this;

			var more_btn = me.dialog.fields_dict.more_btn.$wrapper;

			// Make empty result set if filter is set
			if (!frappe.flags.auto_scroll) {
				this.$results.empty();
			}

			if(results.length === 0) {
				this.$results.empty();
				more_btn.hide();
				return;
			} else if(more) {
				more_btn.show();
			}

			results.forEach(function (result) {
				me.$results.append(me.make_list_row(result));
			});

			if (frappe.flags.auto_scroll) {
				this.$results.animate({scrollTop: me.$results.prop('scrollHeight')}, 500);
			}
		},

		get_results: function() {
			var me = this;

			var filters = this.get_query ? this.get_query().filters : {};
			Object.keys(this.setters).forEach(function(setter) {
				filters[setter] = me.dialog.fields_dict[setter].get_value() || undefined;
				me.args[setter] = filters[setter];
			});

			var date_val = this.dialog.fields_dict["date_range"].get_value();
			if(date_val) {
				filters[this.date_field] = ['between', date_val];
			}

			var args = {
				doctype: me.doctype,
				txt: me.dialog.fields_dict["search_term"].get_value(),
				filters: filters,
				filter_fields: Object.keys(me.setters).concat([me.date_field]),
				start: this.start,
				page_length: this.page_length + 1,
				query: this.get_query ? this.get_query().query : '',
				as_dict: 1
			};
			frappe.call({
				type: "GET",
				method:'frappe.desk.search.search_widget',
				no_spinner: true,
				args: args,
				callback: function(r) {
					var results = [], more = 0;
					if (r.values.length) {
						if (r.values.length > me.page_length) {
							r.values.pop();
							more = 1;
						}
						r.values.forEach(function(result) {
							if(me.date_field in result) {
								result["Date"] = result[me.date_field];
							}
							result.checked = 0;
							result.parsed_date = Date.parse(result["Date"]);
							results.push(result);
						});
						results.map( function (result) {
							result["Date"] = frappe.format(result["Date"], {"fieldtype":"Date"});
						});

						results.sort(function (a, b) {
							return a.parsed_date - b.parsed_date;
						});

						// Preselect oldest entry
						if (me.start < 1) {
							results[0].checked = 1;
						}
					}
					me.render_result_list(results, more);
				}
			});
		},

	});

	// frappe.ui.Capture
	// Author - Achilles Rasquinha <achilles@frappe.io>

	/**
	 * @description Converts a canvas, image or a video to a data URL string.
	 * 
	 * @param 	{HTMLElement} element - canvas, img or video.
	 * @returns {string} 			  - The data URL string.
	 * 
	 * @example
	 * frappe._.get_data_uri(video)
	 * // returns "data:image/pngbase64,..."
	 */
	frappe._.get_data_uri = function (element) {
		var $element = $(element);
		var width    = $element.width();
		var height   = $element.height();

		var $canvas     = $('<canvas/>');
		$canvas[0].width  = width;
		$canvas[0].height = height;

		var context     = $canvas[0].getContext('2d');
		context.drawImage($element[0], 0, 0, width, height);
		
		var data_uri = $canvas[0].toDataURL('image/png');

		return data_uri
	};

	/**
	 * @description Frappe's Capture object.
	 * 
	 * @example
	 * const capture = frappe.ui.Capture()
	 * capture.show()
	 * 
	 * capture.click((data_uri) => {
	 * 	// do stuff
	 * })
	 * 
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Taking_still_photos
	 */
	frappe.ui.Capture = class
	{
		constructor (options)
		{
		if ( options === void 0 ) options = { };

			this.options = frappe.ui.Capture.OPTIONS;
			this.set_options(options);
		}
		
		set_options (options)
		{
			this.options = Object.assign({}, frappe.ui.Capture.OPTIONS, options);
			
			return this
		}
		
		render ( )
		{
			var this$1 = this;

			return navigator.mediaDevices.getUserMedia({ video: true }).then(function (stream) {
				this$1.dialog 	 = new frappe.ui.Dialog({
					  title: this$1.options.title,
					animate: this$1.options.animate,
					 action:
					{
						secondary:
						{
							label: "<b>&times</b>"
						}
					}
				});
		
				var $e 		 = $(frappe.ui.Capture.TEMPLATE);
				
				var video      = $e.find('video')[0];
				video.srcObject  = stream;
				video.play();
				
				var $container = $(this$1.dialog.body);
				$container.html($e);
				
				$e.find('.fc-btf').hide();

				$e.find('.fc-bcp').click(function () {
					var data_url = frappe._.get_data_uri(video);
					$e.find('.fc-p').attr('src', data_url);

					$e.find('.fc-s').hide();
					$e.find('.fc-p').show();

					$e.find('.fc-btu').hide();
					$e.find('.fc-btf').show();
				});

				$e.find('.fc-br').click(function () {
					$e.find('.fc-p').hide();
					$e.find('.fc-s').show();

					$e.find('.fc-btf').hide();
					$e.find('.fc-btu').show();
				});

				$e.find('.fc-bs').click(function () {
					var data_url = frappe._.get_data_uri(video);
					this$1.hide();
					
					if (this$1.callback)
						{ this$1.callback(data_url); }
				});
			})
		}

		show ( )
		{
			var this$1 = this;

			this.render().then(function () {
				this$1.dialog.show();
			}).catch(function (err) {
				if ( this$1.options.error )
				{
					var alert = "<span class=\"indicator red\"/> " + (frappe.ui.Capture.ERR_MESSAGE);
					frappe.show_alert(alert, 3);
				}

				throw err
			});
		}

		hide ( )
		{
			if ( this.dialog )
				{ this.dialog.hide(); }
		}

		submit (fn)
		{
			this.callback = fn;
		}
	};
	frappe.ui.Capture.OPTIONS =
	{
		  title: __("Camera"),
		animate: false,
		  error: false,
	};
	frappe.ui.Capture.ERR_MESSAGE = __("Unable to load camera.");
	frappe.ui.Capture.TEMPLATE 	  =
	"\n<div class=\"frappe-capture\">\n\t<div class=\"panel panel-default\">\n\t\t<img class=\"fc-p img-responsive\"/>\n\t\t<div class=\"fc-s  embed-responsive embed-responsive-16by9\">\n\t\t\t<video class=\"embed-responsive-item\">" + (frappe.ui.Capture.ERR_MESSAGE) + "</video>\n\t\t</div>\n\t</div>\n\t<div>\n\t\t<div class=\"fc-btf\">\n\t\t\t<div class=\"row\">\n\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t<div class=\"pull-left\">\n\t\t\t\t\t\t<button class=\"btn btn-default fc-br\">\n\t\t\t\t\t\t\t<small>" + (__('Retake')) + "</small>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t<div class=\"pull-right\">\n\t\t\t\t\t\t<button class=\"btn btn-primary fc-bs\">\n\t\t\t\t\t\t\t<small>" + (__('Submit')) + "</small>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"fc-btu\">\n\t\t\t<div class=\"row\">\n\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t" + ('') + "\n\t\t\t\t</div>\n\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t<div class=\"pull-right\">\n\t\t\t\t\t\t<button class=\"btn btn-default fc-bcp\">\n\t\t\t\t\t\t\t<small>" + (__('Take Photo')) + "</small>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n";

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt


	frappe.provide("frappe.ui");
	frappe.ui.app_icon = {
		get_html: function(module, small) {
			var icon = module.icon;
			var color = module.color;
			if (icon
				&& icon.match(/([\uE000-\uF8FF]|\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF])/g)) {
				module.emoji = module.icon;
			}
			var icon_style = "";
			if(module.reverse) {
				icon_style = "color: #36414C;";
			}

			if(!color) {
				color = '#4aa3df';
			}

			// first letter
			if(!icon || module.emoji) {
				icon = '<span class="inner" ' +
					(module.reverse ? ('style="' + icon_style + '"') : '')
					+ '>' + (module.emoji || module._label[0].toUpperCase()) + '</span>';
			} else if(icon.split(".").slice(-1)[0]==="svg") {
				$.ajax({
					url: frappe.urllib.get_full_url(icon),
					dataType: "text",
					async: false,
					success: function(data) {
						icon = data;
					}
				});
				icon = '<object class="app-icon-svg">'+ icon+'</object>';
			} else {
				icon = '<i class="'+ icon+'" title="' + module._label + '" style="'+ icon_style + '"></i>';
			}

			return '<div class="app-icon'+ (small ? " app-icon-small" : "")
				+'" style="background-color: '+ color +'" title="'+ module._label +'">'+icon+'</div>';
		}
	};

	// DropZone
	frappe.ui.DropZone = class 
	{
		constructor (selector, options) {
			this.options    = Object.assign({ }, frappe.ui.DropZone.OPTIONS, options);
			this.$container = $(selector);
			this.$wrapper   = $(frappe.ui.DropZone.TEMPLATE);

			this.make();
		}

		make ( ) {
			var me        = this;
			var $dropzone = this.$wrapper.find('.panel-body');
			var $title    = $dropzone.find('.dropzone-title');
			$title.html(this.options.title);

			$dropzone.on('dragover', function (e) {
				e.preventDefault();

				$title.html('Drop');
			});
			$dropzone.on('dragleave', function (e) {
				e.preventDefault();

				$title.html(me.options.title);
			});
			$dropzone.on('drop', function (e) {
				e.preventDefault();

				var files = e.originalEvent.dataTransfer.files;
				me.options.drop(files);

				$title.html(me.options.title);
			});

			this.$container.html(this.$wrapper);
		}
	};
	frappe.ui.DropZone.TEMPLATE =
	"\n<div class=\"panel panel-default\"\n\tstyle=\"\n\t\tborder: none !important;\n\t\tbox-shadow: none !important;\n\t\tmargin-bottom: 0 !important\n\t\">\n\t<div class=\"panel-body\">\n\t\t<div class=\"dropzone-title text-muted text-center\">\n\t\t</div>\n\t</div>\n</div>\n";
	frappe.ui.DropZone.OPTIONS  = 
	{
		title: 'Drop Here'
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.model');

	$.extend(frappe.model, {
		no_value_type: ['Section Break', 'Column Break', 'HTML', 'Table', 'Table MultiSelect',
			'Button', 'Image', 'Fold', 'Heading'],

		layout_fields: ['Section Break', 'Column Break', 'Fold'],

		std_fields_list: ['name', 'owner', 'creation', 'modified', 'modified_by',
			'_user_tags', '_comments', '_assign', '_liked_by', 'docstatus',
			'parent', 'parenttype', 'parentfield', 'idx'],

		core_doctypes_list: ['DocType', 'DocField', 'DocPerm', 'User', 'Role', 'Has Role',
			'Page', 'Module Def', 'Print Format', 'Report', 'Customize Form',
			'Customize Form Field', 'Property Setter', 'Custom Field', 'Custom Script'],

		std_fields: [
			{fieldname:'name', fieldtype:'Link', label:__('ID')},
			{fieldname:'owner', fieldtype:'Link', label:__('Created By'), options: 'User'},
			{fieldname:'idx', fieldtype:'Int', label:__('Index')},
			{fieldname:'creation', fieldtype:'Date', label:__('Created On')},
			{fieldname:'modified', fieldtype:'Date', label:__('Last Updated On')},
			{fieldname:'modified_by', fieldtype:'Data', label:__('Last Updated By')},
			{fieldname:'_user_tags', fieldtype:'Data', label:__('Tags')},
			{fieldname:'_liked_by', fieldtype:'Data', label:__('Liked By')},
			{fieldname:'_comments', fieldtype:'Text', label:__('Comments')},
			{fieldname:'_assign', fieldtype:'Text', label:__('Assigned To')},
			{fieldname:'docstatus', fieldtype:'Int', label:__('Document Status')} ],

		numeric_fieldtypes: ["Int", "Float", "Currency", "Percent"],

		std_fields_table: [
			{fieldname:'parent', fieldtype:'Data', label:__('Parent')} ],

		table_fields: ['Table', 'Table MultiSelect'],

		new_names: {},
		events: {},
		user_settings: {},

		init: function() {
			// setup refresh if the document is updated somewhere else
			frappe.realtime.on("doc_update", function(data) {
				// set list dirty
				frappe.views.ListView.trigger_list_update(data);
				var doc = locals[data.doctype] && locals[data.doctype][data.name];

				if(doc) {
					// current document is dirty, show message if its not me
					if(frappe.get_route()[0]==="Form" && cur_frm.doc.doctype===doc.doctype && cur_frm.doc.name===doc.name) {
						if(!frappe.ui.form.is_saving && data.modified!=cur_frm.doc.modified) {
							doc.__needs_refresh = true;
							cur_frm.check_doctype_conflict();
						}
					} else {
						if(!doc.__unsaved) {
							// no local changes, remove from locals
							frappe.model.remove_from_locals(doc.doctype, doc.name);
						} else {
							// show message when user navigates back
							doc.__needs_refresh = true;
						}
					}
				}
			});

			frappe.realtime.on("list_update", function(data) {
				frappe.views.ListView.trigger_list_update(data);
			});

		},

		is_value_type: function(fieldtype) {
			if (typeof fieldtype == 'object') {
				fieldtype = fieldtype.fieldtype;
			}
			// not in no-value type
			return frappe.model.no_value_type.indexOf(fieldtype)===-1;
		},

		is_non_std_field: function(fieldname) {
			return !frappe.model.std_fields_list.includes(fieldname);
		},

		get_std_field: function(fieldname, ignore) {
			if ( ignore === void 0 ) ignore=false;

			var docfield = $.map([].concat(frappe.model.std_fields).concat(frappe.model.std_fields_table),
				function(d) {
					if(d.fieldname==fieldname) { return d; }
				});
			if (!docfield.length) {
				//Standard fields are ignored in case of adding columns as a result of groupby
				if (ignore) {
					return {fieldname: fieldname};
				} else {
					frappe.msgprint(__("Unknown Column: {0}", [fieldname]));
				}
			}
			return docfield[0];
		},

		with_doctype: function(doctype, callback, async) {
			if(locals.DocType[doctype]) {
				callback && callback();
			} else {
				var cached_timestamp = null;
				var cached_doc = null;

				if(localStorage["_doctype:" + doctype]) {
					var cached_docs = JSON.parse(localStorage["_doctype:" + doctype]);
					cached_doc = cached_docs.filter(function (doc) { return doc.name === doctype; })[0];
					if(cached_doc) {
						cached_timestamp = cached_doc.modified;
					}
				}
				return frappe.call({
					method:'frappe.desk.form.load.getdoctype',
					type: "GET",
					args: {
						doctype: doctype,
						with_parent: 1,
						cached_timestamp: cached_timestamp
					},
					async: async,
					callback: function(r) {
						if(r.exc) {
							frappe.msgprint(__("Unable to load: {0}", [__(doctype)]));
							throw "No doctype";
						}
						if(r.message=="use_cache") {
							frappe.model.sync(cached_doc);
						} else {
							localStorage["_doctype:" + doctype] = JSON.stringify(r.docs);
						}
						frappe.model.init_doctype(doctype);

						if(r.user_settings) {
							// remember filters and other settings from last view
							frappe.model.user_settings[doctype] = JSON.parse(r.user_settings);
							frappe.model.user_settings[doctype].updated_on = moment().toString();
						}
						callback && callback(r);
					}
				});
			}
		},

		init_doctype: function(doctype) {
			var meta = locals.DocType[doctype];
			if(meta.__list_js) {
				eval(meta.__list_js);
			}
			if(meta.__calendar_js) {
				eval(meta.__calendar_js);
			}
			if(meta.__map_js) {
				eval(meta.__map_js);
			}
			if(meta.__tree_js) {
				eval(meta.__tree_js);
			}
			if(meta.__templates) {
				$.extend(frappe.templates, meta.__templates);
			}
		},

		with_doc: function(doctype, name, callback) {
			return new Promise(function (resolve) {
				if(!name) { name = doctype; } // single type
				if(locals[doctype] && locals[doctype][name] && frappe.model.get_docinfo(doctype, name)) {
					callback && callback(name);
					resolve(frappe.get_doc(doctype, name));
				} else {
					return frappe.call({
						method: 'frappe.desk.form.load.getdoc',
						type: "GET",
						args: {
							doctype: doctype,
							name: name
						},
						callback: function(r) {
							callback && callback(name, r);
							resolve(frappe.get_doc(doctype, name));
						}
					});
				}
			});
		},

		get_docinfo: function(doctype, name) {
			return frappe.model.docinfo[doctype] && frappe.model.docinfo[doctype][name] || null;
		},

		set_docinfo: function(doctype, name, key, value) {
			if (frappe.model.docinfo[doctype] && frappe.model.docinfo[doctype][name]) {
				frappe.model.docinfo[doctype][name][key] = value;
			}
		},

		get_shared: function(doctype, name) {
			return frappe.model.get_docinfo(doctype, name).shared;
		},

		get_server_module_name: function(doctype) {
			var dt = frappe.model.scrub(doctype);
			var module = frappe.model.scrub(locals.DocType[doctype].module);
			var app = frappe.boot.module_app[module];
			return app + "." + module + '.doctype.' + dt + '.' + dt;
		},

		scrub: function(txt) {
			return txt.replace(/ /g, "_").toLowerCase();  // use to slugify or create a slug, a "code-friendly" string
		},

		unscrub: function(txt) {
			return __(txt || '').replace(/-|_/g, " ").replace(/\w*/g,
	            function(keywords){return keywords.charAt(0).toUpperCase() + keywords.substr(1).toLowerCase();});
		},

		can_create: function(doctype) {
			return frappe.boot.user.can_create.indexOf(doctype)!==-1;
		},

		can_read: function(doctype) {
			return frappe.boot.user.can_read.indexOf(doctype)!==-1;
		},

		can_write: function(doctype) {
			return frappe.boot.user.can_write.indexOf(doctype)!==-1;
		},

		can_get_report: function(doctype) {
			return frappe.boot.user.can_get_report.indexOf(doctype)!==-1;
		},

		can_delete: function(doctype) {
			if(!doctype) { return false; }
			return frappe.boot.user.can_delete.indexOf(doctype)!==-1;
		},

		can_cancel: function(doctype) {
			if(!doctype) { return false; }
			return frappe.boot.user.can_cancel.indexOf(doctype)!==-1;
		},

		has_workflow: function(doctype) {
			return frappe.get_list('Workflow', {'document_type': doctype,
				'is_active': 1}).length;
		},

		is_submittable: function(doctype) {
			if(!doctype) { return false; }
			return locals.DocType[doctype]
				&& locals.DocType[doctype].is_submittable;
		},

		is_table: function(doctype) {
			if(!doctype) { return false; }
			return locals.DocType[doctype] && locals.DocType[doctype].istable;
		},

		is_single: function(doctype) {
			if(!doctype) { return false; }
			return frappe.boot.single_types.indexOf(doctype) != -1;
		},

		can_import: function(doctype, frm) {
			// system manager can always import
			if(frappe.user_roles.includes("System Manager")) { return true; }

			if(frm) { return frm.perm[0].import===1; }
			return frappe.boot.user.can_import.indexOf(doctype)!==-1;
		},

		can_export: function(doctype, frm) {
			// system manager can always export
			if(frappe.user_roles.includes("System Manager")) { return true; }

			if(frm) { return frm.perm[0].export===1; }
			return frappe.boot.user.can_export.indexOf(doctype)!==-1;
		},

		can_print: function(doctype, frm) {
			if(frm) { return frm.perm[0].print===1; }
			return frappe.boot.user.can_print.indexOf(doctype)!==-1;
		},

		can_email: function(doctype, frm) {
			if(frm) { return frm.perm[0].email===1; }
			return frappe.boot.user.can_email.indexOf(doctype)!==-1;
		},

		can_share: function(doctype, frm) {
			if(frm) {
				return frm.perm[0].share===1;
			}
			return frappe.boot.user.can_share.indexOf(doctype)!==-1;
		},

		can_set_user_permissions: function(doctype, frm) {
			// system manager can always set user permissions
			if(frappe.user_roles.includes("System Manager")) { return true; }

			if(frm) { return frm.perm[0].set_user_permissions===1; }
			return frappe.boot.user.can_set_user_permissions.indexOf(doctype)!==-1;
		},

		has_value: function(dt, dn, fn) {
			// return true if property has value
			var val = locals[dt] && locals[dt][dn] && locals[dt][dn][fn];
			var df = frappe.meta.get_docfield(dt, fn, dn);

			if(frappe.model.table_fields.includes(df.fieldtype)) {
				var ret = false;
				$.each(locals[df.options] || {}, function(k,d) {
					if(d.parent==dn && d.parenttype==dt && d.parentfield==df.fieldname) {
						ret = true;
						return false;
					}
				});
			} else {
				var ret = !is_null(val);
			}
			return ret ? true : false;
		},

		get_list: function(doctype, filters) {
			var docsdict = locals[doctype] || locals[":" + doctype] || {};
			if($.isEmptyObject(docsdict))
				{ return []; }
			return frappe.utils.filter_dict(docsdict, filters);
		},

		get_value: function(doctype, filters, fieldname, callback) {
			if(callback) {
				frappe.call({
					method:"frappe.client.get_value",
					args: {
						doctype: doctype,
						fieldname: fieldname,
						filters: filters
					},
					callback: function(r) {
						if(!r.exc) {
							callback(r.message);
						}
					}
				});
			} else {
				if(typeof filters==="string" && locals[doctype] && locals[doctype][filters]) {
					return locals[doctype][filters][fieldname];
				} else {
					var l = frappe.get_list(doctype, filters);
					return (l.length && l[0]) ? l[0][fieldname] : null;
				}
			}
		},

		set_value: function(doctype, docname, fieldname, value, fieldtype) {
			/* help: Set a value locally (if changed) and execute triggers */

			var doc;
			if ($.isPlainObject(doctype)) {
				// first parameter is the doc, shift parameters to the left
				doc = doctype; fieldname = docname; value = fieldname;
			} else {
				doc = locals[doctype] && locals[doctype][docname];
			}

			var to_update = fieldname;
			var tasks = [];
			if(!$.isPlainObject(to_update)) {
				to_update = {};
				to_update[fieldname] = value;
			}

			$.each(to_update, function (key, value) {
				if (doc && doc[key] !== value) {
					if(doc.__unedited && !(!doc[key] && !value)) {
						// unset unedited flag for virgin rows
						doc.__unedited = false;
					}

					doc[key] = value;
					tasks.push(function () { return frappe.model.trigger(key, value, doc); });
				} else {
					// execute link triggers (want to reselect to execute triggers)
					if(fieldtype=="Link" && doc) {
						tasks.push(function () { return frappe.model.trigger(key, value, doc); });
					}
				}
			});

			return frappe.run_serially(tasks);
		},

		on: function(doctype, fieldname, fn) {
			/* help: Attach a trigger on change of a particular field.
			To trigger on any change in a particular doctype, use fieldname as "*"
			*/
			/* example: frappe.model.on("Customer", "age", function(fieldname, value, doc) {
			  if(doc.age < 16) {
			   	frappe.msgprint("Warning, Customer must atleast be 16 years old.");
			    raise "CustomerAgeError";
			  }
			}) */
			frappe.provide("frappe.model.events." + doctype);
			if(!frappe.model.events[doctype][fieldname]) {
				frappe.model.events[doctype][fieldname] = [];
			}
			frappe.model.events[doctype][fieldname].push(fn);
		},

		trigger: function(fieldname, value, doc) {
			var tasks = [];
			var runner = function(events, event_doc) {
				$.each(events || [], function(i, fn) {
					if(fn) {
						var _promise = fn(fieldname, value, event_doc || doc);

						// if the trigger returns a promise, return it,
						// or use the default promise frappe.after_ajax
						if (_promise && _promise.then) {
							return _promise;
						} else {
							return frappe.after_server_call();
						}
					}
				});
			};

			if(frappe.model.events[doc.doctype]) {
				tasks.push(function () {
					return runner(frappe.model.events[doc.doctype][fieldname]);
				});

				tasks.push(function () {
					return runner(frappe.model.events[doc.doctype]['*']);
				});
			}

			return frappe.run_serially(tasks);
		},

		get_doc: function(doctype, name) {
			if(!name) { name = doctype; }
			if($.isPlainObject(name)) {
				var doc = frappe.get_list(doctype, name);
				return doc && doc.length ? doc[0] : null;
			}
			return locals[doctype] ? locals[doctype][name] : null;
		},

		get_children: function(doctype, parent, parentfield, filters) {
			if($.isPlainObject(doctype)) {
				var doc = doctype;
				var filters = parentfield;
				var parentfield = parent;
			} else {
				var doc = frappe.get_doc(doctype, parent);
			}

			var children = doc[parentfield] || [];
			if(filters) {
				return frappe.utils.filter_dict(children, filters);
			} else {
				return children;
			}
		},

		clear_table: function(doc, parentfield) {
			for (var i=0, l=(doc[parentfield] || []).length; i<l; i++) {
				var d = doc[parentfield][i];
				delete locals[d.doctype][d.name];
			}
			doc[parentfield] = [];
		},

		remove_from_locals: function(doctype, name) {
			this.clear_doc(doctype, name);
			if(frappe.views.formview[doctype]) {
				delete frappe.views.formview[doctype].frm.opendocs[name];
			}
		},

		clear_doc: function(doctype, name) {
			var doc = locals[doctype] && locals[doctype][name];
			if(!doc) { return; }

			var parent = null;
			if(doc.parenttype) {
				var parent = doc.parent,
					parenttype = doc.parenttype,
					parentfield = doc.parentfield;
			}
			delete locals[doctype][name];
			if(parent) {
				var parent_doc = locals[parenttype][parent];
				var newlist = [], idx = 1;
				$.each(parent_doc[parentfield], function(i, d) {
					if(d.name!=name) {
						newlist.push(d);
						d.idx = idx;
						idx++;
					}
					parent_doc[parentfield] = newlist;
				});
			}
		},

		get_no_copy_list: function(doctype) {
			var no_copy_list = ['name','amended_from','amendment_date','cancel_reason'];

			var docfields = frappe.get_doc("DocType", doctype).fields || [];
			for(var i=0, j=docfields.length; i<j; i++) {
				var df = docfields[i];
				if(cint(df.no_copy)) { no_copy_list.push(df.fieldname); }
			}

			return no_copy_list;
		},

		delete_doc: function(doctype, docname, callback) {
			frappe.confirm(__("Permanently delete {0}?", [docname]), function() {
				return frappe.call({
					method: 'frappe.client.delete',
					args: {
						doctype: doctype,
						name: docname
					},
					callback: function(r, rt) {
						if(!r.exc) {
							frappe.utils.play_sound("delete");
							frappe.model.clear_doc(doctype, docname);
							if(callback) { callback(r,rt); }
						}
					}
				})
			});
		},

		rename_doc: function(doctype, docname, callback) {
			var d = new frappe.ui.Dialog({
				title: __("Rename {0}", [__(docname)]),
				fields: [
					{label:__("New Name"), fieldname: "new_name", fieldtype:"Data", reqd:1, "default": docname},
					{label:__("Merge with existing"), fieldtype:"Check", fieldname:"merge"} ]
			});
			d.set_primary_action(__("Rename"), function() {
				var args = d.get_values();
				if(!args) { return; }
				return frappe.call({
					method:"frappe.model.rename_doc.rename_doc",
					args: {
						doctype: doctype,
						old: docname,
						"new": args.new_name,
						"merge": args.merge
					},
					btn: d.get_primary_btn(),
					callback: function(r,rt) {
						if(!r.exc) {
							$(document).trigger('rename', [doctype, docname,
								r.message || args.new_name]);
							if(locals[doctype] && locals[doctype][docname])
								{ delete locals[doctype][docname]; }
							d.hide();
							if(callback)
								{ callback(r.message); }
						}
					}
				});
			});
			d.show();
		},

		round_floats_in: function(doc, fieldnames) {
			if(!fieldnames) {
				fieldnames = frappe.meta.get_fieldnames(doc.doctype, doc.parent,
					{"fieldtype": ["in", ["Currency", "Float"]]});
			}
			for(var i=0, j=fieldnames.length; i < j; i++) {
				var fieldname = fieldnames[i];
				doc[fieldname] = flt(doc[fieldname], precision(fieldname, doc));
			}
		},

		validate_missing: function(doc, fieldname) {
			if(!doc[fieldname]) {
				frappe.throw(__("Please specify") + ": " +
					__(frappe.meta.get_label(doc.doctype, fieldname, doc.parent || doc.name)));
			}
		},

		get_all_docs: function(doc) {
			var all = [doc];
			for(var key in doc) {
				if($.isArray(doc[key])) {
					var children = doc[key];
					for (var i=0, l=children.length; i < l; i++) {
						all.push(children[i]);
					}
				}
			}
			return all;
		},

		get_full_column_name: function(fieldname, doctype) {
			if (fieldname.includes('`tab')) { return fieldname; }
			return '`tab' + doctype + '`.`' + fieldname + '`';
		},

		is_numeric_field: function(fieldtype) {
			if (!fieldtype) { return; }
			if (typeof fieldtype === 'object') {
				fieldtype = fieldtype.fieldtype;
			}
			return frappe.model.numeric_fieldtypes.includes(fieldtype);
		}
	});

	// legacy
	frappe.get_doc = frappe.model.get_doc;
	frappe.get_children = frappe.model.get_children;
	frappe.get_list = frappe.model.get_list;

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.db = {
		get_list: function(doctype, args) {
			if (!args) {
				args = {};
			}
			args.doctype = doctype;
			if (!args.fields) {
				args.fields = ['name'];
			}
			if (!args.limit) {
				args.limit = 20;
			}
			return new Promise (function (resolve) {
				frappe.call({
					method: 'frappe.model.db_query.get_list',
					args: args,
					type: 'GET',
					callback: function(r) {
						resolve(r.message);
					}
				});
			});
		},
		exists: function(doctype, name) {
			return new Promise (function (resolve) {
				frappe.db.get_value(doctype, {name: name}, 'name').then(function (r) {
					(r.message && r.message.name) ? resolve(true) : resolve(false);
				});
			});
		},
		get_value: function(doctype, filters, fieldname, callback, parent_doc) {
			return frappe.call({
				method: "frappe.client.get_value",
				type: 'GET',
				args: {
					doctype: doctype,
					fieldname: fieldname,
					filters: filters,
					parent: parent_doc
				},
				callback: function(r) {
					callback && callback(r.message);
				}
			});
		},
		get_single_value: function (doctype, field) {
			return new Promise(function (resolve) {
				frappe.call({
					method: 'frappe.client.get_single_value',
					args: { doctype: doctype, field: field },
					type: 'GET',
				}).then(function (r) { return resolve(r ? r.message : null); });
			});
		},
		set_value: function(doctype, docname, fieldname, value, callback) {
			return frappe.call({
				method: "frappe.client.set_value",
				args: {
					doctype: doctype,
					name: docname,
					fieldname: fieldname,
					value: value
				},
				callback: function(r) {
					callback && callback(r.message);
				}
			});
		},
		get_doc: function(doctype, name, filters) {
			if ( filters === void 0 ) filters = null;

			return new Promise(function (resolve, reject) {
				frappe.call({
					method: "frappe.client.get",
					type: 'GET',
					args: { doctype: doctype, name: name, filters: filters },
					callback: function (r) {
						frappe.model.sync(r.message);
						resolve(r.message);
					}
				}).fail(reject);
			});
		},
		insert: function(doc) {
			return frappe.xcall('frappe.client.insert', { doc: doc });
		},
		delete_doc: function(doctype, name) {
			return new Promise(function (resolve) {
				frappe.call('frappe.client.delete', { doctype: doctype, name: name }, function (r) { return resolve(r.message); });
			});
		},
		count: function(doctype, args) {
			if ( args === void 0 ) args={};

			return new Promise(function (resolve) {
				frappe.call({
					method: 'frappe.client.get_count',
					type: 'GET',
					args: Object.assign(args, { doctype: doctype })
				}).then(function (r) { return resolve(r.message); });
			});
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.meta.docfield_map');
	frappe.provide('frappe.meta.docfield_copy');
	frappe.provide('frappe.meta.docfield_list');
	frappe.provide('frappe.meta.doctypes');
	frappe.provide("frappe.meta.precision_map");

	frappe.get_meta = function(doctype) {
		return locals["DocType"][doctype];
	};

	$.extend(frappe.meta, {
		sync: function(doc) {
			$.each(doc.fields, function(i, df) {
				frappe.meta.add_field(df);
			});
			frappe.meta.sync_messages(doc);
			if(doc.__print_formats) { frappe.model.sync(doc.__print_formats); }
			if(doc.__workflow_docs) { frappe.model.sync(doc.__workflow_docs); }
		},

		// build docfield_map and docfield_list
		add_field: function(df) {
			frappe.provide('frappe.meta.docfield_map.' + df.parent);
			frappe.meta.docfield_map[df.parent][df.fieldname || df.label] = df;

			if(!frappe.meta.docfield_list[df.parent])
				{ frappe.meta.docfield_list[df.parent] = []; }

			// check for repeat
			for(var i in frappe.meta.docfield_list[df.parent]) {
				var d = frappe.meta.docfield_list[df.parent][i];
				if(df.fieldname==d.fieldname)
					{ return; } // no repeat
			}
			frappe.meta.docfield_list[df.parent].push(df);
		},

		make_docfield_copy_for: function(doctype, docname) {
			var c = frappe.meta.docfield_copy;
			if(!c[doctype])
				{ c[doctype] = {}; }
			if(!c[doctype][docname])
				{ c[doctype][docname] = {}; }

			var docfield_list = frappe.meta.docfield_list[doctype] || [];
			for(var i=0, j=docfield_list.length; i<j; i++) {
				var df = docfield_list[i];
				c[doctype][docname][df.fieldname || df.label] = copy_dict(df);
			}
		},

		get_field: function(doctype, fieldname, name) {
			var out = frappe.meta.get_docfield(doctype, fieldname, name);

			// search in standard fields
			if (!out) {
				frappe.model.std_fields.every(function(d) {
					if(d.fieldname===fieldname) {
						out = d;
						return false;
					} else {
						return true;
					}
				});
			}
			return out;
		},

		get_docfield: function(doctype, fieldname, name) {
			var fields_dict = frappe.meta.get_docfield_copy(doctype, name);
			return fields_dict ? fields_dict[fieldname] : null;
		},

		set_formatter: function(doctype, fieldname, name, formatter) {
			frappe.meta.get_docfield(doctype, fieldname, name).formatter = formatter;
		},

		set_indicator_formatter: function(doctype, fieldname, name, get_text, get_color) {
			frappe.meta.get_docfield(doctype, fieldname, name).formatter =
				function(value, df, options, doc) {
					return repl('<span class="indicator %(color)s">%(name)s</span>', {
						color: get_color(),
						name: get_text()
					});
				};
		},

		get_docfields: function(doctype, name, filters) {
			var docfield_map = frappe.meta.get_docfield_copy(doctype, name);

			var docfields = frappe.meta.sort_docfields(docfield_map);

			if(filters) {
				docfields = frappe.utils.filter_dict(docfields, filters);
			}

			return docfields;
		},

		get_linked_fields: function(doctype) {
			return $.map(frappe.get_meta(doctype).fields,
				function(d) { return d.fieldtype=="Link" ? d.options : null; });
		},

		get_fields_to_check_permissions: function(doctype) {
			var fields = $.map(frappe.meta.get_docfields(doctype, name), function(df) {
				return (df.fieldtype==="Link" && df.ignore_user_permissions!==1) ? df : null;
			});
			fields = fields.concat({label: "Name", fieldname: name, options: doctype});
			return fields;
		},

		sort_docfields: function(docs) {
			return $.map(docs, function(d) { return d; }).sort(function(a, b) { return a.idx - b.idx });
		},

		get_docfield_copy: function(doctype, name) {
			if(!name) { return frappe.meta.docfield_map[doctype]; }

			if(!(frappe.meta.docfield_copy[doctype] && frappe.meta.docfield_copy[doctype][name])) {
				frappe.meta.make_docfield_copy_for(doctype, name);
			}

			return frappe.meta.docfield_copy[doctype][name];
		},

		get_fieldnames: function(doctype, name, filters) {
			return $.map(frappe.utils.filter_dict(frappe.meta.docfield_map[doctype], filters),
				function(df) { return df.fieldname; });
		},

		has_field: function(dt, fn) {
			var docfield_map = frappe.meta.docfield_map[dt];
			return docfield_map && docfield_map[fn];
		},

		get_table_fields: function(dt) {
			return $.map(frappe.meta.docfield_list[dt], function(d) {
				return frappe.model.table_fields.includes(d.fieldtype) ? d : null});
		},

		get_doctype_for_field: function(doctype, key) {
			var out = null;
			if(in_list(frappe.model.std_fields_list, key)) {
				// standard
				out = doctype;
			} else if(frappe.meta.has_field(doctype, key)) {
				// found in parent
				out = doctype;
			} else {
				frappe.meta.get_table_fields(doctype).every(function(d) {
					if(frappe.meta.has_field(d.options, key)) {
						out = d.options;
						return false;
					}
					return true;
				});

				if(!out) {
					// eslint-disable-next-line
					console.log(__('Warning: Unable to find {0} in any table related to {1}', [
						key, __(doctype)]));
				}
			}
			return out;
		},

		get_parentfield: function(parent_dt, child_dt) {
			var df = (frappe.get_doc("DocType", parent_dt).fields || [])
				.filter(function (df) { return frappe.model.table_fields.includes(df.fieldtype) && df.options===child_dt; });
			if(!df.length)
				{ throw "parentfield not found for " + parent_dt + ", " + child_dt; }
			return df[0].fieldname;
		},

		get_label: function(dt, fn, dn) {
			var standard = {
				'owner': __('Owner'),
				'creation': __('Created On'),
				'modified': __('Last Modified On'),
				'idx': __('Idx'),
				'name': __('Name'),
				'modified_by': __('Last Modified By')
			};
			if(standard[fn]) {
				return standard[fn];
			} else {
				var df = this.get_docfield(dt, fn, dn);
				return (df ? df.label : "") || fn;
			}
		},

		get_print_formats: function(doctype) {
			var print_format_list = ["Standard"];
			var default_print_format = locals.DocType[doctype].default_print_format;
			var enable_raw_printing = frappe.model.get_doc(":Print Settings", "Print Settings").enable_raw_printing;
			var print_formats = frappe.get_list("Print Format", {doc_type: doctype})
				.sort(function(a, b) { return (a > b) ? 1 : -1; });
			$.each(print_formats, function(i, d) {
				if (
					!in_list(print_format_list, d.name)
					&& d.print_format_type !== 'JS'
					&& (cint(enable_raw_printing) || !d.raw_printing)
				) {
					print_format_list.push(d.name);
				}
			});

			if(default_print_format && default_print_format != "Standard") {
				var index = print_format_list.indexOf(default_print_format);
				print_format_list.splice(index, 1).sort();
				print_format_list.unshift(default_print_format);
			}

			return print_format_list;
		},

		sync_messages: function(doc) {
			if(doc.__messages) {
				$.extend(frappe._messages, doc.__messages);
			}
		},

		get_field_currency: function(df, doc) {
			var currency = frappe.boot.sysdefaults.currency;
			if(!doc && cur_frm)
				{ doc = cur_frm.doc; }

			if(df && df.options) {
				if(doc && df.options.indexOf(":")!=-1) {
					var options = df.options.split(":");
					if(options.length==3) {
						// get reference record e.g. Company
						var docname = doc[options[1]];
						if(!docname && cur_frm) {
							docname = cur_frm.doc[options[1]];
						}
						currency = frappe.model.get_value(options[0], docname, options[2]) ||
							frappe.model.get_value(":" + options[0], docname, options[2]) ||
							currency;
					}
				} else if(doc && doc[df.options]) {
					currency = doc[df.options];
				} else if(cur_frm && cur_frm.doc[df.options]) {
					currency = cur_frm.doc[df.options];
				}
			}
			return currency;
		},

		get_field_precision: function(df, doc) {
			var precision = null;
			if (df && cint(df.precision)) {
				precision = cint(df.precision);
			} else if(df && df.fieldtype === "Currency") {
				precision = cint(frappe.defaults.get_default("currency_precision"));
				if(!precision) {
					var number_format = get_number_format();
					var number_format_info = get_number_format_info(number_format);
					precision = number_format_info.precision;
				}
			} else {
				precision = cint(frappe.defaults.get_default("float_precision")) || 3;
			}
			return precision;
		},
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	$.extend(frappe.model, {
		docinfo: {},
		sync: function(r) {
			/* docs:
				extract docs, docinfo (attachments, comments, assignments)
				from incoming request and set in `locals` and `frappe.model.docinfo`
			*/
			var isPlain;
			if(!r.docs && !r.docinfo) { r = {docs:r}; }

			isPlain = $.isPlainObject(r.docs);
			if(isPlain) { r.docs = [r.docs]; }

			if(r.docs) {

				for(var i=0, l=r.docs.length; i<l; i++) {
					var d = r.docs[i];

					if (locals[d.doctype] && locals[d.doctype][d.name]) {
						// update values
						frappe.model.update_in_locals(d);
					} else {
						frappe.model.add_to_locals(d);
					}

					d.__last_sync_on = new Date();

					if(d.doctype==="DocType") {
						frappe.meta.sync(d);
					}

					if(d.localname) {
						frappe.model.new_names[d.localname] = d.name;
						$(document).trigger('rename', [d.doctype, d.localname, d.name]);
						delete locals[d.doctype][d.localname];

						// update docinfo to new dict keys
						if(i===0) {
							frappe.model.docinfo[d.doctype][d.name] = frappe.model.docinfo[d.doctype][d.localname];
							frappe.model.docinfo[d.doctype][d.localname] = undefined;
						}
					}
				}



			}

			// set docinfo (comments, assign, attachments)
			if(r.docinfo) {
				var doc;
				if(r.docs) {
					doc = r.docs[0];
				} else {
					if(cur_frm) { doc = cur_frm.doc; }
				}
				if(doc) {
					if(!frappe.model.docinfo[doc.doctype])
						{ frappe.model.docinfo[doc.doctype] = {}; }
					frappe.model.docinfo[doc.doctype][doc.name] = r.docinfo;
				}
			}

			return r.docs;
		},
		add_to_locals: function(doc) {
			if(!locals[doc.doctype])
				{ locals[doc.doctype] = {}; }

			if(!doc.name && doc.__islocal) { // get name (local if required)
				if(!doc.parentfield) { frappe.model.clear_doc(doc); }

				doc.name = frappe.model.get_new_name(doc.doctype);

				if(!doc.parentfield) { frappe.provide("frappe.model.docinfo." + doc.doctype + "." + doc.name); }
			}

			locals[doc.doctype][doc.name] = doc;

			// add child docs to locals
			if(!doc.parentfield) {
				for(var i in doc) {
					var value = doc[i];

					if($.isArray(value)) {
						for (var x=0, y=value.length; x < y; x++) {
							var d = value[x];

							if(typeof d=='object' && !d.parent)
								{ d.parent = doc.name; }

							frappe.model.add_to_locals(d);
						}
					}
				}
			}
		},
		update_in_locals: function(doc) {
			// update values in the existing local doc instead of replacing
			var local_doc = locals[doc.doctype][doc.name];
			var clear_keys = function(source, target) {
				Object.keys(target).map(function (key) {
					if (source[key] == undefined) { delete target[key]; }
				});
			};

			for (var fieldname in doc) {
				var df = frappe.meta.get_field(doc.doctype, fieldname);
				if (df && frappe.model.table_fields.includes(df.fieldtype)) {
					// table
					if (!(doc[fieldname] instanceof Array)) {
						doc[fieldname] = [];
					}

					if (!(local_doc[fieldname] instanceof Array)) {
						local_doc[fieldname] = [];
					}

					// child table, override each row and append new rows if required
					for (var i=0; i < doc[fieldname].length; i++ ) {
						var d = doc[fieldname][i];
						var local_d = local_doc[fieldname][i];
						if (local_d) {
							// deleted and added again
							if (!locals[d.doctype]) { locals[d.doctype] = {}; }

							if (!d.name) {
								// incoming row is new, find a new name
								d.name = frappe.model.get_new_name(doc.doctype);
							}

							// if incoming row is not registered, register it
							if (!locals[d.doctype][d.name]) {
								// detach old key
								delete locals[d.doctype][local_d.name];

								// re-attach with new name
								locals[d.doctype][d.name] = local_d;
							}

							// row exists, just copy the values
							Object.assign(local_d, d);
							clear_keys(d, local_d);

						} else {
							local_doc[fieldname].push(d);
							if (!d.parent) { d.parent = doc.name; }
							frappe.model.add_to_locals(d);
						}
					}

					// remove extra rows
					if (local_doc[fieldname].length > doc[fieldname].length) {
						for (var i$1 = doc[fieldname].length; i$1 < local_doc[fieldname].length; i$1++) {

							// clear from local
							var d$1 = local_doc[fieldname][i$1];
							if (locals[d$1.doctype] && locals[d$1.doctype][d$1.name]) {
								delete locals[d$1.doctype][d$1.name];
							}
						}
						local_doc[fieldname].length = doc[fieldname].length;

					}
				} else {
					// literal
					local_doc[fieldname] = doc[fieldname];
				}
			}

			// clear keys on parent
			clear_keys(doc, local_doc);
		}

	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.model");

	$.extend(frappe.model, {
		new_names: {},
		new_name_count: {},

		get_new_doc: function(doctype, parent_doc, parentfield, with_mandatory_children) {
			frappe.provide("locals." + doctype);
			var doc = {
				docstatus: 0,
				doctype: doctype,
				name: frappe.model.get_new_name(doctype),
				__islocal: 1,
				__unsaved: 1,
				owner: frappe.session.user
			};
			frappe.model.set_default_values(doc, parent_doc);

			if(parent_doc) {
				$.extend(doc, {
					parent: parent_doc.name,
					parentfield: parentfield,
					parenttype: parent_doc.doctype,
				});
				if(!parent_doc[parentfield]) { parent_doc[parentfield] = []; }
				doc.idx = parent_doc[parentfield].length + 1;
				parent_doc[parentfield].push(doc);
			} else {
				frappe.provide("frappe.model.docinfo." + doctype + "." + doc.name);
			}

			frappe.model.add_to_locals(doc);

			if(with_mandatory_children) {
				frappe.model.create_mandatory_children(doc);
			}

			if (!parent_doc) {
				doc.__run_link_triggers = 1;
			}

			// set the name if called from a link field
			if(frappe.route_options && frappe.route_options.name_field) {

				var meta = frappe.get_meta(doctype);
				// set title field / name as name
				if(meta.autoname && meta.autoname.indexOf("field:")!==-1) {
					doc[meta.autoname.substr(6)] = frappe.route_options.name_field;
				} else if(meta.title_field) {
					doc[meta.title_field] = frappe.route_options.name_field;
				}


				delete frappe.route_options.name_field;
			}

			// set route options
			if(frappe.route_options && !doc.parent) {
				$.each(frappe.route_options, function(fieldname, value) {
					var df = frappe.meta.has_field(doctype, fieldname);
					if(df && in_list(['Link', 'Data', 'Select', 'Dynamic Link'], df.fieldtype) && !df.no_copy) {
						doc[fieldname]=value;
					}
				});
				frappe.route_options = null;
			}

			return doc;
		},

		make_new_doc_and_get_name: function(doctype, with_mandatory_children) {
			return frappe.model.get_new_doc(doctype, null, null, with_mandatory_children).name;
		},

		get_new_name: function(doctype) {
			var cnt = frappe.model.new_name_count;
			if(!cnt[doctype])
				{ cnt[doctype] = 0; }
			cnt[doctype]++;
			return __('New') + ' '+ __(doctype) + ' ' + cnt[doctype];
		},

		set_default_values: function(doc, parent_doc) {
			var doctype = doc.doctype;
			var docfields = frappe.meta.get_docfields(doctype);
			var updated = [];
			for(var fid=0;fid<docfields.length;fid++) {
				var f = docfields[fid];
				if(!in_list(frappe.model.no_value_type, f.fieldtype) && doc[f.fieldname]==null) {
					var v = !f.depends_on || doc[f.depends_on] ? frappe.model.get_default_value(f, doc, parent_doc) : null;
					if(v) {
						if(in_list(["Int", "Check"], f.fieldtype))
							{ v = cint(v); }
						else if(in_list(["Currency", "Float"], f.fieldtype))
							{ v = flt(v); }

						doc[f.fieldname] = v;
						updated.push(f.fieldname);
					} else if(f.fieldtype == "Select" && f.options && typeof f.options === 'string'
						&& !in_list(["[Select]", "Loading..."], f.options)) {

						doc[f.fieldname] = f.options.split("\n")[0];
					}
				}
			}
			return updated;
		},

		create_mandatory_children: function(doc) {
			var meta = frappe.get_meta(doc.doctype);
			if(meta && meta.istable) { return; }

			// create empty rows for mandatory table fields
			frappe.meta.get_docfields(doc.doctype).forEach(function(df) {
				if(df.fieldtype==='Table' && df.reqd) {
					frappe.model.add_child(doc, df.fieldname);
				}
			});
		},

		get_default_value: function(df, doc, parent_doc) {
			var assign;

			var user_default = "";
			var user_permissions = frappe.defaults.get_user_permissions();
			var allowed_records = [];
			var default_doc = null;
			if(user_permissions) {
				((assign = frappe.perm.filter_allowed_docs_for_doctype(user_permissions[df.options], doc.doctype), allowed_records = assign.allowed_records, default_doc = assign.default_doc));
			}
			var meta = frappe.get_meta(doc.doctype);
			var has_user_permissions = (df.fieldtype==="Link"
				&& !$.isEmptyObject(user_permissions)
				&& df.ignore_user_permissions != 1
				&& allowed_records.length);

			// don't set defaults for "User" link field using User Permissions!
			if (df.fieldtype==="Link" && df.options!=="User") {
				// 1 - look in user permissions for document_type=="Setup".
				// We don't want to include permissions of transactions to be used for defaults.
				if (df.linked_document_type==="Setup"
					&& has_user_permissions && default_doc) {
					return default_doc;
				}

				if(!df.ignore_user_permissions) {
					// 2 - look in user defaults
					var user_defaults = frappe.defaults.get_user_defaults(df.options);
					if (user_defaults && user_defaults.length===1) {
						// Use User Permission value when only when it has a single value
						user_default = user_defaults[0];
					}
				}

				if (!user_default) {
					user_default = frappe.defaults.get_user_default(df.fieldname);
				}

				if(!user_default && df.remember_last_selected_value && frappe.boot.user.last_selected_values) {
					user_default = frappe.boot.user.last_selected_values[df.options];
				}

				var is_allowed_user_default = user_default &&
					(!has_user_permissions || allowed_records.includes(user_default));

				// is this user default also allowed as per user permissions?
				if (is_allowed_user_default) {
					return user_default;
				}
			}

			// 3 - look in default of docfield
			if (df['default']) {

				if (df["default"] == "__user" || df["default"].toLowerCase() == "user") {
					return frappe.session.user;

				} else if (df["default"] == "user_fullname") {
					return frappe.session.user_fullname;

				} else if (df["default"] == "Today") {
					return frappe.datetime.get_today();

				} else if ((df["default"] || "").toLowerCase() === "now") {
					return frappe.datetime.now_datetime();

				} else if (df["default"][0]===":") {
					var boot_doc = frappe.model.get_default_from_boot_docs(df, doc, parent_doc);
					var is_allowed_boot_doc = !has_user_permissions || allowed_records.includes(boot_doc);

					if (is_allowed_boot_doc) {
						return boot_doc;
					}
				} else if (df.fieldname===meta.title_field) {
					// ignore defaults for title field
					return "";
				}

				// is this default value is also allowed as per user permissions?
				var is_allowed_default = !has_user_permissions || allowed_records.includes(df.default);
				if (df.fieldtype!=="Link" || df.options==="User" || is_allowed_default) {
					return df["default"];
				}

			} else if (df.fieldtype=="Time") {
				return frappe.datetime.now_time();
			}
		},

		get_default_from_boot_docs: function(df, doc, parent_doc) {
			// set default from partial docs passed during boot like ":User"
			if(frappe.get_list(df["default"]).length > 0) {
				var ref_fieldname = df["default"].slice(1).toLowerCase().replace(" ", "_");
				var ref_value = parent_doc ?
					parent_doc[ref_fieldname] :
					frappe.defaults.get_user_default(ref_fieldname);
				var ref_doc = ref_value ? frappe.get_doc(df["default"], ref_value) : null;

				if(ref_doc && ref_doc[df.fieldname]) {
					return ref_doc[df.fieldname];
				}
			}
		},

		add_child: function(parent_doc, doctype, parentfield, idx) {
			// if given doc, fieldname only
			if(arguments.length===2) {
				parentfield = doctype;
				doctype = frappe.meta.get_field(parent_doc.doctype, parentfield).options;
			}

			// create row doc
			idx = idx ? idx - 0.1 : (parent_doc[parentfield] || []).length + 1;

			var child = frappe.model.get_new_doc(doctype, parent_doc, parentfield);
			child.idx = idx;

			// renum for fraction
			if(idx !== cint(idx)) {
				var sorted = parent_doc[parentfield].sort(function(a, b) { return a.idx - b.idx; });
				for(var i=0, j=sorted.length; i<j; i++) {
					var d = sorted[i];
					d.idx = i + 1;
				}
			}

			if (cur_frm && cur_frm.doc == parent_doc) { cur_frm.dirty(); }

			return child;
		},

		copy_doc: function(doc, from_amend, parent_doc, parentfield) {
			var no_copy_list = ['name','amended_from','amendment_date','cancel_reason'];
			var newdoc = frappe.model.get_new_doc(doc.doctype, parent_doc, parentfield);

			for(var key in doc) {
				// dont copy name and blank fields
				var df = frappe.meta.get_docfield(doc.doctype, key);

				if (df && key.substr(0, 2) != '__'
					&& !in_list(no_copy_list, key)
					&& !(df && (!from_amend && cint(df.no_copy) == 1))) {

					var value = doc[key] || [];
					if (frappe.model.table_fields.includes(df.fieldtype)) {
						for (var i = 0, j = value.length; i < j; i++) {
							var d = value[i];
							frappe.model.copy_doc(d, from_amend, newdoc, df.fieldname);
						}
					} else {
						newdoc[key] = doc[key];
					}
				}
			}

			var user = frappe.session.user;

			newdoc.__islocal = 1;
			newdoc.docstatus = 0;
			newdoc.owner = user;
			newdoc.creation = '';
			newdoc.modified_by = user;
			newdoc.modified = '';

			return newdoc;
		},

		open_mapped_doc: function(opts) {
			if (opts.frm && opts.frm.doc.__unsaved) {
				frappe.throw(__("You have unsaved changes in this form. Please save before you continue."));

			} else if (!opts.source_name && opts.frm) {
				opts.source_name = opts.frm.doc.name;

			// Allow opening a mapped doc without a source document name
			} else if (!opts.frm) {
				opts.source_name = null;
			}

			return frappe.call({
				type: "POST",
				method: 'frappe.model.mapper.make_mapped_doc',
				args: {
					method: opts.method,
					source_name: opts.source_name,
					args: opts.args || null,
					selected_children: opts.frm ? opts.frm.get_selected() : null
				},
				freeze: true,
				callback: function(r) {
					if(!r.exc) {
						frappe.model.sync(r.message);
						if(opts.run_link_triggers) {
							frappe.get_doc(r.message.doctype, r.message.name).__run_link_triggers = true;
						}
						frappe.set_route("Form", r.message.doctype, r.message.name);
					}
				}
			})
		}
	});

	frappe.create_routes = {};
	frappe.new_doc = function (doctype, opts, init_callback) {
		return new Promise(function (resolve) {
			if(opts && $.isPlainObject(opts)) {
				frappe.route_options = opts;
			}
			frappe.model.with_doctype(doctype, function() {
				if(frappe.create_routes[doctype]) {
					frappe.set_route(frappe.create_routes[doctype])
						.then(function () { return resolve(); });
				} else {
					frappe.ui.form.make_quick_entry(doctype, null, init_callback)
						.then(function () { return resolve(); });
				}
			});

		});
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.perm");

	// backward compatibilty
	Object.assign(window, {
		READ: "read",
		WRITE: "write",
		CREATE: "create",
		DELETE: "delete",
		SUBMIT: "submit",
		CANCEL: "cancel",
		AMEND: "amend",
	});

	$.extend(frappe.perm, {
		rights: ["read", "write", "create", "delete", "submit", "cancel", "amend",
			"report", "import", "export", "print", "email", "share", "set_user_permissions"],

		doctype_perm: {},

		has_perm: function (doctype, permlevel, ptype, doc) {
			if (!permlevel) { permlevel = 0; }
			if (!frappe.perm.doctype_perm[doctype]) {
				frappe.perm.doctype_perm[doctype] = frappe.perm.get_perm(doctype);
			}

			var perms = frappe.perm.doctype_perm[doctype];

			if (!perms || !perms[permlevel]) { return false; }

			var perm = !!perms[permlevel][ptype];

			if (permlevel === 0 && perm && doc) {
				var docinfo = frappe.model.get_docinfo(doctype, doc.name);
				if (docinfo && !docinfo.permissions[ptype])
					{ perm = false; }
			}

			return perm;
		},

		get_perm: function (doctype, doc) {
			var perm = [{ read: 0 }];

			var meta = frappe.get_doc("DocType", doctype);
			var user  = frappe.session.user;

			if (user === "Administrator" || frappe.user_roles.includes("Administrator")) {
				perm[0].read = 1;
			}

			if (!meta) { return perm; }

			frappe.perm.build_role_permissions(perm, meta);

			if (doc) {
				// apply user permissions via docinfo (which is processed server-side)
				var docinfo = frappe.model.get_docinfo(doctype, doc.name);
				if (docinfo && docinfo.permissions) {
					Object.keys(docinfo.permissions).forEach(function (ptype) {
						perm[0][ptype] = docinfo.permissions[ptype];
					});
				}

				// if owner
				if (!$.isEmptyObject(perm[0].if_owner)) {
					if (doc.owner === user) {
						$.extend(perm[0], perm[0].if_owner);
					} else {
						// not owner, remove permissions
						$.each(perm[0].if_owner, function (ptype) {
							if (perm[0].if_owner[ptype]) {
								perm[0][ptype] = 0;
							}
						});
					}
				}

				// apply permissions from shared
				if (docinfo && docinfo.shared) {
					for (var i = 0; i < docinfo.shared.length; i++) {
						var s = docinfo.shared[i];
						if (s.user === user) {
							perm[0]["read"] = perm[0]["read"] || s.read;
							perm[0]["write"] = perm[0]["write"] || s.write;
							perm[0]["share"] = perm[0]["share"] || s.share;

							if (s.read) {
								// also give print, email permissions if read
								// and these permissions exist at level [0]
								perm[0].email = frappe.boot.user.can_email.indexOf(doctype) !== -1 ? 1 : 0;
								perm[0].print = frappe.boot.user.can_print.indexOf(doctype) !== -1 ? 1 : 0;
							}
						}
					}
				}

			}

			if (frappe.model.can_read(doctype) && !perm[0].read) {
				// read via sharing
				perm[0].read = 1;
			}

			return perm;
		},

		build_role_permissions: function (perm, meta) {
			// Returns a `dict` of evaluated Role Permissions
			$.each(meta.permissions || [], function (i, p) {
				// if user has this role
				if (frappe.user_roles.includes(p.role)) {
					var permlevel = cint(p.permlevel);
					if (!perm[permlevel]) {
						perm[permlevel] = {};
						perm[permlevel]["permlevel"] = permlevel;
					}

					$.each(frappe.perm.rights, function (i, key) {
						perm[permlevel][key] = perm[permlevel][key] || (p[key] || 0);
					});
				}
			});

			// remove values with 0
			$.each(perm[0], function (key, val) {
				if (!val) {
					delete perm[0][key];
				}
			});

			$.each(perm, function (i, v) {
				if (v === undefined) {
					perm[i] = {};
				}
			});
		},

		get_match_rules: function (doctype, ptype) {
			var match_rules = [];

			if (!ptype) { ptype = "read"; }

			var perm = frappe.perm.get_perm(doctype);

			var user_permissions = frappe.defaults.get_user_permissions();

			if (user_permissions && !$.isEmptyObject(user_permissions)) {
				var rules = {};
				var fields_to_check = frappe.meta.get_fields_to_check_permissions(doctype);
				$.each(fields_to_check, function (i, df) {
					var user_permissions_for_doctype = user_permissions[df.options] || [];
					var allowed_records = frappe.perm.get_allowed_docs_for_doctype(user_permissions_for_doctype, doctype);
					if (allowed_records.length) {
						rules[df.label] = allowed_records;
					}
				});
				if (!$.isEmptyObject(rules)) {
					match_rules.push(rules);
				}
			}

			if (perm[0].if_owner && perm[0].read) {
				match_rules.push({ "Owner": frappe.session.user });
			}
			return match_rules;
		},

		get_field_display_status: function (df, doc, perm, explain) {
			// returns the display status of a particular field
			// returns one of "Read", "Write" or "None"
			if (!perm && doc) {
				perm = frappe.perm.get_perm(doc.doctype, doc);
			}

			if (!perm) {
				return (df && (cint(df.hidden) || cint(df.hidden_due_to_dependency))) ? "None" : "Write";
			}

			if (!df.permlevel) { df.permlevel = 0; }
			var p = perm[df.permlevel];
			var status = "None";

			// permission
			if (p) {
				if (p.write && !df.disabled) {
					status = "Write";
				} else if (p.read) {
					status = "Read";
				}
			}
			if (explain) { console.log("By Permission:" + status); }

			// hidden
			if (cint(df.hidden)) { status = "None"; }
			if (explain) { console.log("By Hidden:" + status); }

			// hidden due to dependency
			if (cint(df.hidden_due_to_dependency)) { status = "None"; }
			if (explain) { console.log("By Hidden Due To Dependency:" + status); }

			if (!doc) {
				return status;
			}

			// submit
			if (status === "Write" && cint(doc.docstatus) > 0) { status = "Read"; }
			if (explain) { console.log("By Submit:" + status); }

			// allow on submit
			// let allow_on_submit = df.fieldtype==="Table" ? 0 : cint(df.allow_on_submit);
			var allow_on_submit = cint(df.allow_on_submit);
			if (status === "Read" && allow_on_submit && cint(doc.docstatus) === 1 && p.write) {
				status = "Write";
			}
			if (explain) { console.log("By Allow on Submit:" + status); }

			// workflow state
			if (status === "Read" && cur_frm && cur_frm.state_fieldname) {
				// fields updated by workflow must be read-only
				if (cint(cur_frm.read_only) ||
					in_list(cur_frm.states.update_fields, df.fieldname) ||
					df.fieldname == cur_frm.state_fieldname) {
					status = "Read";
				}
			}
			if (explain) { console.log("By Workflow:" + status); }

			// read only field is checked
			if (status === "Write" && cint(df.read_only)) {
				status = "Read";
			}
			if (explain) { console.log("By Read Only:" + status); }

			if (status === "Write" && df.set_only_once && !doc.__islocal) {
				status = "Read";
			}
			if (explain) { console.log("By Set Only Once:" + status); }

			return status;
		},

		is_visible: function (df, doc, perm) {
			if (typeof df === 'string') {
				// df is fieldname
				df = frappe.meta.get_docfield(doc.doctype, df, doc.parent || doc.name);
			}

			var status = frappe.perm.get_field_display_status(df, doc, perm);

			return status === "None" ? false : true;
		},

		get_allowed_docs_for_doctype: function (user_permissions, doctype) {
			// returns docs from the list of user permissions that are allowed under provided doctype
			return frappe.perm.filter_allowed_docs_for_doctype(user_permissions, doctype, false);
		},

		filter_allowed_docs_for_doctype: function (user_permissions, doctype, with_default_doc) {
			if ( with_default_doc === void 0 ) with_default_doc=true;

			// returns docs from the list of user permissions that are allowed under provided doctype
			// also returns default doc when with_default_doc is set
			var filtered_perms = (user_permissions || []).filter(function (perm) {
				return (perm.applicable_for === doctype || !perm.applicable_for);
			});

			var allowed_docs = (filtered_perms).map(function (perm) { return perm.doc; });

			if (with_default_doc) {
				var default_doc = allowed_docs.length === 1 ? allowed_docs : filtered_perms
					.filter(function (perm) { return perm.is_default; })
					.map(function (record) { return record.doc; });

				return {
					allowed_records: allowed_docs,
					default_doc: default_doc[0]
				};
			} else {
				return allowed_docs;
			}
		}
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.workflow");

	frappe.workflow = {
		state_fields: {},
		workflows: {},
		setup: function(doctype) {
			var wf = frappe.get_list("Workflow", {document_type: doctype});
			if(wf.length) {
				frappe.workflow.workflows[doctype] = wf[0];
				frappe.workflow.state_fields[doctype] = wf[0].workflow_state_field;
			} else {
				frappe.workflow.state_fields[doctype] = null;
			}
		},
		get_state_fieldname: function(doctype) {
			if(frappe.workflow.state_fields[doctype]===undefined) {
				frappe.workflow.setup(doctype);
			}
			return frappe.workflow.state_fields[doctype];
		},
		get_default_state: function(doctype, docstatus) {
			frappe.workflow.setup(doctype);
			var value = null;
			$.each(frappe.workflow.workflows[doctype].states, function(i, workflow_state) {
				if(cint(workflow_state.doc_status)===cint(docstatus)) {
					value = workflow_state.state;
					return false;
				}
			});
			return value;
		},
		get_transitions: function(doc) {
			frappe.workflow.setup(doc.doctype);
			return frappe.xcall('frappe.model.workflow.get_transitions', {doc: doc});
		},
		get_document_state: function(doctype, state) {
			frappe.workflow.setup(doctype);
			return frappe.get_children(frappe.workflow.workflows[doctype], "states", {state:state})[0];
		},
		is_self_approval_enabled: function(doctype) {
			return frappe.workflow.workflows[doctype].allow_self_approval;
		},
		is_read_only: function(doctype, name) {
			var state_fieldname = frappe.workflow.get_state_fieldname(doctype);
			if(state_fieldname) {
				var doc = locals[doctype][name];
				if(!doc)
					{ return false; }
				if(doc.__islocal)
					{ return false; }

				var state = doc[state_fieldname] ||
					frappe.workflow.get_default_state(doctype, doc.docstatus);

				var allow_edit = state ? frappe.workflow.get_document_state(doctype, state) && frappe.workflow.get_document_state(doctype, state).allow_edit : null;

				if(!frappe.user_roles.includes(allow_edit)) {
					return true;
				}
			}
			return false;
		},
		get_update_fields: function(doctype) {
			var update_fields = $.unique($.map(frappe.workflow.workflows[doctype].states || [],
				function(d) {
					return d.update_field;
				}));
			return update_fields;
		},
		get_state: function get_state(doc) {
			var state_field = this.get_state_fieldname(doc.doctype);
			var state = doc[state_field];
			if (!state) {
				state = this.get_default_state(doc.doctype, doc.docstatus);
			}
			return state;
		},
		get_all_transitions: function get_all_transitions(doctype) {
			return frappe.workflow.workflows[doctype].transitions || [];
		},
		get_all_transition_actions: function get_all_transition_actions(doctype) {
			var transitions = this.get_all_transitions(doctype);
			return transitions.map(function (transition) {
				return transition.action;
			});
		},
	};

	frappe.provide('frappe.model.user_settings');

	$.extend(frappe.model.user_settings, {
		get: function(doctype) {
			return frappe.call('frappe.model.utils.user_settings.get', { doctype: doctype })
				.then(function (r) { return JSON.parse(r.message || '{}'); });
		},
		save: function(doctype, key, value) {
			var old_user_settings = frappe.model.user_settings[doctype] || {};
			var new_user_settings = $.extend(true, {}, old_user_settings); // deep copy

			if ($.isPlainObject(value)) {
				new_user_settings[key] = new_user_settings[key] || {};
				$.extend(new_user_settings[key], value);
			} else {
				new_user_settings[key] = value;
			}

			var a = JSON.stringify(old_user_settings);
			var b = JSON.stringify(new_user_settings);
			if (a !== b) {
				// update if changed
				return this.update(doctype, new_user_settings);
			}
			return Promise.resolve();
		},
		remove: function(doctype, key) {
			var user_settings = frappe.model.user_settings[doctype] || {};
			delete user_settings[key];

			return this.update(doctype, user_settings);
		},
		update: function(doctype, user_settings) {
			return frappe.call({
				method: 'frappe.model.utils.user_settings.save',
				args: {
					doctype: doctype,
					user_settings: user_settings
				},
				callback: function(r) {
					frappe.model.user_settings[doctype] = r.message;
				}
			});
		}
	});

	frappe.get_user_settings = function(doctype, key) {
		var settings = frappe.model.user_settings[doctype] || {};
		if(key) {
			settings = settings[key] || {};
		}
		return settings;
	};

	!function(a){function b(a,b){var c=(65535&a)+(65535&b),d=(a>>16)+(b>>16)+(c>>16);return d<<16|65535&c}function c(a,b){return a<<b|a>>>32-b}function d(a,d,e,f,g,h){return b(c(b(b(d,a),b(f,h)),g),e)}function e(a,b,c,e,f,g,h){return d(b&c|~b&e,a,b,f,g,h)}function f(a,b,c,e,f,g,h){return d(b&e|c&~e,a,b,f,g,h)}function g(a,b,c,e,f,g,h){return d(b^c^e,a,b,f,g,h)}function h(a,b,c,e,f,g,h){return d(c^(b|~e),a,b,f,g,h)}function i(a,c){a[c>>5]|=128<<c%32,a[(c+64>>>9<<4)+14]=c;var d,i,j,k,l,m=1732584193,n=-271733879,o=-1732584194,p=271733878;for(d=0;d<a.length;d+=16){ i=m,j=n,k=o,l=p,m=e(m,n,o,p,a[d],7,-680876936),p=e(p,m,n,o,a[d+1],12,-389564586),o=e(o,p,m,n,a[d+2],17,606105819),n=e(n,o,p,m,a[d+3],22,-1044525330),m=e(m,n,o,p,a[d+4],7,-176418897),p=e(p,m,n,o,a[d+5],12,1200080426),o=e(o,p,m,n,a[d+6],17,-1473231341),n=e(n,o,p,m,a[d+7],22,-45705983),m=e(m,n,o,p,a[d+8],7,1770035416),p=e(p,m,n,o,a[d+9],12,-1958414417),o=e(o,p,m,n,a[d+10],17,-42063),n=e(n,o,p,m,a[d+11],22,-1990404162),m=e(m,n,o,p,a[d+12],7,1804603682),p=e(p,m,n,o,a[d+13],12,-40341101),o=e(o,p,m,n,a[d+14],17,-1502002290),n=e(n,o,p,m,a[d+15],22,1236535329),m=f(m,n,o,p,a[d+1],5,-165796510),p=f(p,m,n,o,a[d+6],9,-1069501632),o=f(o,p,m,n,a[d+11],14,643717713),n=f(n,o,p,m,a[d],20,-373897302),m=f(m,n,o,p,a[d+5],5,-701558691),p=f(p,m,n,o,a[d+10],9,38016083),o=f(o,p,m,n,a[d+15],14,-660478335),n=f(n,o,p,m,a[d+4],20,-405537848),m=f(m,n,o,p,a[d+9],5,568446438),p=f(p,m,n,o,a[d+14],9,-1019803690),o=f(o,p,m,n,a[d+3],14,-187363961),n=f(n,o,p,m,a[d+8],20,1163531501),m=f(m,n,o,p,a[d+13],5,-1444681467),p=f(p,m,n,o,a[d+2],9,-51403784),o=f(o,p,m,n,a[d+7],14,1735328473),n=f(n,o,p,m,a[d+12],20,-1926607734),m=g(m,n,o,p,a[d+5],4,-378558),p=g(p,m,n,o,a[d+8],11,-2022574463),o=g(o,p,m,n,a[d+11],16,1839030562),n=g(n,o,p,m,a[d+14],23,-35309556),m=g(m,n,o,p,a[d+1],4,-1530992060),p=g(p,m,n,o,a[d+4],11,1272893353),o=g(o,p,m,n,a[d+7],16,-155497632),n=g(n,o,p,m,a[d+10],23,-1094730640),m=g(m,n,o,p,a[d+13],4,681279174),p=g(p,m,n,o,a[d],11,-358537222),o=g(o,p,m,n,a[d+3],16,-722521979),n=g(n,o,p,m,a[d+6],23,76029189),m=g(m,n,o,p,a[d+9],4,-640364487),p=g(p,m,n,o,a[d+12],11,-421815835),o=g(o,p,m,n,a[d+15],16,530742520),n=g(n,o,p,m,a[d+2],23,-995338651),m=h(m,n,o,p,a[d],6,-198630844),p=h(p,m,n,o,a[d+7],10,1126891415),o=h(o,p,m,n,a[d+14],15,-1416354905),n=h(n,o,p,m,a[d+5],21,-57434055),m=h(m,n,o,p,a[d+12],6,1700485571),p=h(p,m,n,o,a[d+3],10,-1894986606),o=h(o,p,m,n,a[d+10],15,-1051523),n=h(n,o,p,m,a[d+1],21,-2054922799),m=h(m,n,o,p,a[d+8],6,1873313359),p=h(p,m,n,o,a[d+15],10,-30611744),o=h(o,p,m,n,a[d+6],15,-1560198380),n=h(n,o,p,m,a[d+13],21,1309151649),m=h(m,n,o,p,a[d+4],6,-145523070),p=h(p,m,n,o,a[d+11],10,-1120210379),o=h(o,p,m,n,a[d+2],15,718787259),n=h(n,o,p,m,a[d+9],21,-343485551),m=b(m,i),n=b(n,j),o=b(o,k),p=b(p,l); }return [m,n,o,p]}function j(a){var b,c="";for(b=0;b<32*a.length;b+=8){ c+=String.fromCharCode(a[b>>5]>>>b%32&255); }return c}function k(a){var b,c=[];for(c[(a.length>>2)-1]=void 0,b=0;b<c.length;b+=1){ c[b]=0; }for(b=0;b<8*a.length;b+=8){ c[b>>5]|=(255&a.charCodeAt(b/8))<<b%32; }return c}function l(a){return j(i(k(a),8*a.length))}function m(a,b){var c,d,e=k(a),f=[],g=[];for(f[15]=g[15]=void 0,e.length>16&&(e=i(e,8*a.length)),c=0;16>c;c+=1){ f[c]=909522486^e[c],g[c]=1549556828^e[c]; }return d=i(f.concat(k(b)),512+8*b.length),j(i(g.concat(d),640))}function n(a){var b,c,d="0123456789abcdef",e="";for(c=0;c<a.length;c+=1){ b=a.charCodeAt(c),e+=d.charAt(b>>>4&15)+d.charAt(15&b); }return e}function o(a){return unescape(encodeURIComponent(a))}function p(a){return l(o(a))}function q(a){return n(p(a))}function r(a,b){return m(o(a),o(b))}function s(a,b){return n(r(a,b))}function t(a,b,c){return b?c?r(b,a):s(b,a):c?p(a):q(a)}"function"==typeof define&&define.amd?define(function(){return t}):a.md5=t;}(window);

	frappe.user_info = function(uid) {
		if(!uid)
			{ uid = frappe.session.user; }

		if(uid.toLowerCase()==="bot") {
			return {
				fullname: __("Bot"),
				image: "/assets/frappe/images/ui/bot.png",
				abbr: "B"
			};
		}

		if(!(frappe.boot.user_info && frappe.boot.user_info[uid])) {
			var user_info = {
				fullname: frappe.utils.capitalize(uid.split("@")[0]) || "Unknown"
			};
		} else {
			var user_info = frappe.boot.user_info[uid];
		}

		user_info.abbr = frappe.get_abbr(user_info.fullname);
		user_info.color = frappe.get_palette(user_info.fullname);

		return user_info;
	};

	frappe.ui.set_user_background = function(src, selector, style) {
		if(!selector) { selector = "#page-desktop"; }
		if(!style) { style = "Fill Screen"; }
		if(src) {
			if (window.cordova && src.indexOf("http") === -1) {
				src = frappe.base_url + src;
			}
			var background = repl('background: url("%(src)s") center center;', {src: src});
		} else {
			var background = "background-color: #4B4C9D;";
		}

		frappe.dom.set_style(repl('%(selector)s { \
		%(background)s \
		background-attachment: fixed; \
		%(style)s \
	}', {
			selector:selector,
			background:background,
			style: style==="Fill Screen" ? "background-size: cover;" : ""
		}));
	};

	frappe.provide('frappe.user');

	$.extend(frappe.user, {
		name: 'Guest',
		full_name: function(uid) {
			return uid === frappe.session.user ?
				__("You") :
				frappe.user_info(uid).fullname;
		},
		image: function(uid) {
			return frappe.user_info(uid).image;
		},
		abbr: function(uid) {
			return frappe.user_info(uid).abbr;
		},
		has_role: function(rl) {
			if(typeof rl=='string')
				{ rl = [rl]; }
			for(var i in rl) {
				if((frappe.boot ? frappe.boot.user.roles : ['Guest']).indexOf(rl[i])!=-1)
					{ return true; }
			}
		},
		get_desktop_items: function() {
			// hide based on permission
			var modules_list = $.map(frappe.boot.allowed_modules, function(icon) {
				var m = icon.module_name;
				var type = frappe.modules[m] && frappe.modules[m].type;

				if(frappe.boot.user.allow_modules.indexOf(m) === -1) { return null; }

				var ret = null;
				if (type === "module") {
					if(frappe.boot.user.allow_modules.indexOf(m)!=-1 || frappe.modules[m].is_help)
						{ ret = m; }
				} else if (type === "page") {
					if(frappe.boot.allowed_pages.indexOf(frappe.modules[m].link)!=-1)
						{ ret = m; }
				} else if (type === "list") {
					if(frappe.model.can_read(frappe.modules[m]._doctype))
						{ ret = m; }
				} else if (type === "view") {
					ret = m;
				} else if (type === "setup") {
					if(frappe.user.has_role("System Manager") || frappe.user.has_role("Administrator"))
						{ ret = m; }
				} else {
					ret = m;
				}

				return ret;
			});

			return modules_list;
		},

		is_report_manager: function() {
			return frappe.user.has_role(['Administrator', 'System Manager', 'Report Manager']);
		},

		get_formatted_email: function(email) {
			var fullname = frappe.user.full_name(email);

			if (!fullname) {
				return email;
			} else {
				// to quote or to not
				var quote = '';

				// only if these special characters are found
				// why? To make the output same as that in python!
				if (fullname.search(/[\[\]\\()<>@,:;".]/) !== -1) {
					quote = '"';
				}

				return repl('%(quote)s%(fullname)s%(quote)s <%(email)s>', {
					fullname: fullname,
					email: email,
					quote: quote
				});
			}
		},

		get_emails: function ( ) {
			return Object.keys(frappe.boot.user_info).map(function (key) { return frappe.boot.user_info[key].email; });
		},

		/* Normally frappe.user is an object
		 * having properties and methods.
		 * But in the following case
		 *
		 * if (frappe.user === 'Administrator')
		 *
		 * frappe.user will cast to a string
		 * returning frappe.user.name
		 */
		toString: function() {
			return this.name;
		}
	});

	frappe.session_alive = true;
	$(document).bind('mousemove', function() {
		if(frappe.session_alive===false) {
			$(document).trigger("session_alive");
		}
		frappe.session_alive = true;
		if(frappe.session_alive_timeout)
			{ clearTimeout(frappe.session_alive_timeout); }
		frappe.session_alive_timeout = setTimeout('frappe.session_alive=false;', 30000);
	});

	// common file between desk and website

	frappe.avatar = function (user, css_class, title, image_url) {
		if ( image_url === void 0 ) image_url = null;

		if (user) {
			// desk
			var user_info = frappe.user_info(user);
		} else {
			// website
			user_info = {
				image: frappe.get_cookie("user_image"),
				fullname: frappe.get_cookie("full_name"),
				abbr: frappe.get_abbr(frappe.get_cookie("full_name")),
				color: frappe.get_palette(frappe.get_cookie("full_name"))
			};
		}

		if (!title) {
			title = user_info.fullname;
		}

		if (!css_class) {
			css_class = "avatar-small";
		}

		if (user_info.image || image_url) {
			image_url = image_url || user_info.image;

			var image = (window.cordova && image_url.indexOf('http') === -1) ? frappe.base_url + image_url : image_url;

			return ("<span class=\"avatar " + css_class + "\" title=\"" + title + "\">\n\t\t\t\t<span class=\"avatar-frame\" style='background-image: url(\"" + image + "\")'\n\t\t\t\t\ttitle=\"" + title + "\"></span>\n\t\t\t</span>");
		} else {
			var abbr = user_info.abbr;
			if (css_class === 'avatar-small' || css_class == 'avatar-xs') {
				abbr = abbr.substr(0, 1);
			}
			return ("<span class=\"avatar " + css_class + "\" title=\"" + title + "\">\n\t\t\t<div class=\"standard-image\" style=\"background-color: " + (user_info.color) + ";\">\n\t\t\t\t" + abbr + "</div>\n\t\t</span>");
		}
	};

	frappe.ui.scroll = function(element, animate, additional_offset) {
		var header_offset = $(".navbar").height() + $(".page-head").height();
		var top = $(element).offset().top - header_offset - cint(additional_offset);
		if (animate) {
			$("html, body").animate({ scrollTop: top });
		} else {
			$(window).scrollTop(top);
		}
	};

	frappe.get_palette = function(txt) {
		return '#fafbfc';
		// //return '#8D99A6';
		// if(txt==='Administrator') return '#36414C';
		// // get color palette selection from md5 hash
		// var idx = cint((parseInt(md5(txt).substr(4,2), 16) + 1) / 5.33);
		// if(idx > 47) idx = 47;
		// return frappe.palette[idx][0]
	};

	frappe.get_abbr = function(txt, max_length) {
		if (!txt) { return ""; }
		var abbr = "";
		$.each(txt.split(" "), function(i, w) {
			if (abbr.length >= (max_length || 2)) {
				// break
				return false;

			} else if (!w.trim().length) {
				// continue
				return true;
			}
			abbr += w.trim()[0];
		});

		return abbr || "?";
	};

	frappe.gravatars = {};
	frappe.get_gravatar = function(email_id, size) {
		if ( size === void 0 ) size = 0;

		var param = size ? ('s=' + size) : 'd=retro';
		if(!frappe.gravatars[email_id]) {
			// TODO: check if gravatar exists
			frappe.gravatars[email_id] = "https://secure.gravatar.com/avatar/" + md5(email_id) + "?" + param;
		}
		return frappe.gravatars[email_id];
	};

	// string commons

	window.repl =function repl(s, dict) {
		if(s==null){ return ''; }
		for(var key in dict) {
			s = s.split("%("+key+")s").join(dict[key]);
		}
		return s;
	};

	window.replace_all = function(s, t1, t2) {
		return s.split(t1).join(t2);
	};

	window.strip_html = function(txt) {
		return txt.replace(/<[^>]*>/g, "");
	};

	window.strip = function(s, chars) {
		if (s) {
			var s= lstrip(s, chars);
			s = rstrip(s, chars);
			return s;
		}
	};

	window.lstrip = function lstrip(s, chars) {
		if(!chars) { chars = ['\n', '\t', ' ']; }
		// strip left
		var first_char = s.substr(0,1);
		while(in_list(chars, first_char)) {
			var s = s.substr(1);
			first_char = s.substr(0,1);
		}
		return s;
	};

	window.rstrip = function(s, chars) {
		if(!chars) { chars = ['\n', '\t', ' ']; }
		var last_char = s.substr(s.length-1);
		while(in_list(chars, last_char)) {
			var s = s.substr(0, s.length-1);
			last_char = s.substr(s.length-1);
		}
		return s;
	};

	frappe.get_cookie = function getCookie(name) {
		return frappe.get_cookies()[name];
	};

	frappe.get_cookies = function getCookies() {
		var c = document.cookie, v = 0, cookies = {};
		if (document.cookie.match(/^\s*\$Version=(?:"1"|1);\s*(.*)/)) {
			c = RegExp.$1;
			v = 1;
		}
		if (v === 0) {
			c.split(/[,;]/).map(function(cookie) {
				var parts = cookie.split(/=/, 2),
					name = decodeURIComponent(parts[0].trimLeft()),
					value = parts.length > 1 ? decodeURIComponent(parts[1].trimRight()) : null;
				if(value && value.charAt(0)==='"') {
					value = value.substr(1, value.length-2);
				}
				cookies[name] = value;
			});
		} else {
			c.match(/(?:^|\s+)([!#$%&'*+\-.0-9A-Z^`a-z|~]+)=([!#$%&'*+\-.0-9A-Z^`a-z|~]*|"(?:[\x20-\x7E\x80\xFF]|\\[\x00-\x7F])*")(?=\s*[,;]|$)/g).map(function($0, $1) {
				var name = $0,
					value = $1.charAt(0) === '"'
							? $1.substr(1, -1).replace(/\\(.)/g, "$1")
							: $1;
				cookies[name] = value;
			});
		}
		return cookies;
	};

	frappe.palette = [
		['#FFC4C4', 0],
		['#FFE8CD', 0],
		['#FFD2C2', 0],
		['#FF8989', 0],
		['#FFD19C', 0],
		['#FFA685', 0],
		['#FF4D4D', 1],
		['#FFB868', 0],
		['#FF7846', 1],
		['#A83333', 1],
		['#A87945', 1],
		['#A84F2E', 1],
		['#D2D2FF', 0],
		['#F8D4F8', 0],
		['#DAC7FF', 0],
		['#A3A3FF', 0],
		['#F3AAF0', 0],
		['#B592FF', 0],
		['#7575FF', 0],
		['#EC7DEA', 0],
		['#8E58FF', 1],
		['#4D4DA8', 1],
		['#934F92', 1],
		['#5E3AA8', 1],
		['#EBF8CC', 0],
		['#FFD7D7', 0],
		['#D2F8ED', 0],
		['#D9F399', 0],
		['#FFB1B1', 0],
		['#A4F3DD', 0],
		['#C5EC63', 0],
		['#FF8989', 1],
		['#77ECCA', 0],
		['#7B933D', 1],
		['#A85B5B', 1],
		['#49937E', 1],
		['#FFFACD', 0],
		['#D2F1FF', 0],
		['#CEF6D1', 0],
		['#FFF69C', 0],
		['#A6E4FF', 0],
		['#9DECA2', 0],
		['#FFF168', 0],
		['#78D6FF', 0],
		['#6BE273', 0],
		['#A89F45', 1],
		['#4F8EA8', 1],
		['#428B46', 1]
	];

	frappe.is_mobile = function() {
		return $(document).width() < 768;
	};

	frappe.utils.xss_sanitise = function (string, options) {
		// Reference - https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet
		var sanitised = string; // un-sanitised string.
		var DEFAULT_OPTIONS = {
			strategies: ['html', 'js'] // use all strategies.
		};
		var HTML_ESCAPE_MAP = {
			'<': '&lt',
			'>': '&gt',
			'"': '&quot',
			"'": '&#x27',
			'/': '&#x2F'
		};
		var REGEX_SCRIPT     = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi; // used in jQuery 1.7.2 src/ajax.js Line 14
		options          	   = Object.assign({ }, DEFAULT_OPTIONS, options); // don't deep copy, immutable beauty.

		// Rule 1
		if ( options.strategies.includes('html') ) {
			for (var char in HTML_ESCAPE_MAP) {
				var escape = HTML_ESCAPE_MAP[char];
				var regex = new RegExp(char, "g");
				sanitised = sanitised.replace(regex, escape);
			}
		}

		// Rule 3 - TODO: Check event handlers?
		if ( options.strategies.includes('js') ) {
			sanitised = sanitised.replace(REGEX_SCRIPT, "");
		}

		return sanitised;
	};

	frappe.urllib = {
		// get argument from url
		get_arg: function(name) {
			name = name.replace(/[[]/, "\\[").replace(/[\]]/,"\\]");
			var regexS = "[\\?&]"+name+"=([^&#]*)";
			var regex = new RegExp( regexS );
			var results = regex.exec( window.location.href );
			if( results == null )
				{ return ""; }
			else
				{ return decodeURIComponent(results[1]); }
		},

		// returns url dictionary
		get_dict: function() {
			var d = {};
			var t = window.location.href.split('?')[1];
			if(!t) { return d; }

			if(t.indexOf('#')!=-1) { t = t.split('#')[0]; }
			if(!t) { return d; }

			t = t.split('&');
			for(var i=0; i<t.length; i++) {
				var a = t[i].split('=');
				d[decodeURIComponent(a[0])] = decodeURIComponent(a[1]);
			}
			return d;
		},

		// returns the base url with http + domain + path (-index.cgi or # or ?)
		get_base_url: function() {
			// var url= (frappe.base_url || window.location.href).split('#')[0].split('?')[0].split('desk')[0];
			var url = (frappe.base_url || window.location.origin);
			if(url.substr(url.length-1, 1)=='/') { url = url.substr(0, url.length-1); }
			return url;
		},

		// returns absolute url
		get_full_url: function(url) {
			if(url.indexOf("http://")===0 || url.indexOf("https://")===0) {
				return url;
			}
			return url.substr(0,1)==="/" ?
				(frappe.urllib.get_base_url() + url) :
				(frappe.urllib.get_base_url() + "/" + url);
		}
	};

	window.open_url_post = function open_url_post(URL, PARAMS, new_window) {
		if (window.cordova) {
			var url = URL + 'api/method/' + PARAMS.cmd + frappe.utils.make_query_string(PARAMS, false);
			window.location.href = url;
		} else {
			// call a url as POST
			var temp=document.createElement("form");
			temp.action=URL;
			temp.method="POST";
			temp.style.display="none";
			if(new_window){
				temp.target = '_blank';
			}
			PARAMS["csrf_token"] = frappe.csrf_token;
			for(var x in PARAMS) {
				var opt=document.createElement("textarea");
				opt.name=x;
				var val = PARAMS[x];
				if(typeof val!='string')
					{ val = JSON.stringify(val); }
				opt.value=val;
				temp.appendChild(opt);
			}
			document.body.appendChild(temp);
			temp.submit();
			return temp;
		}
	};

	window.get_url_arg = frappe.urllib.get_arg;
	window.get_url_dict = frappe.urllib.get_dict;

	// moment strings for translation

	function prettyDate(time, mini) {
		if (!time) {
			time = new Date();
		}
		if ('moment' in window) { // use frappe.ImportError ;)
			var ret;
			if (frappe.sys_defaults && frappe.sys_defaults.time_zone) {
				ret = moment.tz(time, frappe.sys_defaults.time_zone).locale(frappe.boot.lang).fromNow(mini);
			} else {
				ret = moment(time).locale(frappe.boot.lang).fromNow(mini);
			}
			if (mini) {
				if (ret === moment().locale(frappe.boot.lang).fromNow(mini)) {
					ret = __("now");
				} else {
					var parts = ret.split(" ");
					if (parts.length > 1) {
						if (parts[0] === "a" || parts[0] === "an") {
							parts[0] = 1;
						}
						if (parts[1].substr(0, 2) === "mo") {
							ret = parts[0] + " M";
						} else {
							ret = parts[0] + " " + parts[1].substr(0, 1);
						}
					}
				}
				ret = ret.substr(0, 5);
			}
			return ret;
		} else {
			if (!time) { return ''; }
			var date = time;
			if (typeof (time) == "string")
				{ date = new Date((time || "").replace(/-/g, "/").replace(/[TZ]/g, " ").replace(/\.[0-9]*/, "")); }

			var diff = (((new Date()).getTime() - date.getTime()) / 1000),
				day_diff = Math.floor(diff / 86400);

			if (isNaN(day_diff) || day_diff < 0)
				{ return ''; }

			var when = day_diff == 0 && (
				diff < 60 && __("just now") ||
				diff < 120 && __("1 minute ago") ||
				diff < 3600 && __("{0} minutes ago", [Math.floor(diff / 60)]) ||
				diff < 7200 && __("1 hour ago") ||
				diff < 86400 && ([Math.floor(diff / 3600)])) ||
				day_diff == 1 && __("Yesterday") ||
				day_diff < 7 && __("{0} days ago", day_diff) ||
				day_diff < 31 && __("{0} weeks ago", [Math.ceil(day_diff / 7)]) ||
				day_diff < 365 && __("{0} months ago", [Math.ceil(day_diff / 30)]) ||
				__("> {0} year(s) ago", [Math.floor(day_diff / 365)]);

			return when;
		}
	}


	frappe.provide("frappe.datetime");
	window.comment_when = function(datetime, mini) {
		var timestamp = frappe.datetime.str_to_user ?
			frappe.datetime.str_to_user(datetime) : datetime;
		return '<span class="frappe-timestamp '
			+ (mini ? " mini" : "") + '" data-timestamp="' + datetime
			+ '" title="' + timestamp + '">'
			+ prettyDate(datetime, mini) + '</span>';
	};
	frappe.datetime.comment_when = comment_when;

	frappe.datetime.refresh_when = function() {
		if (jQuery) {
			$(".frappe-timestamp").each(function() {
				$(this).html(prettyDate($(this).attr("data-timestamp"), $(this).hasClass("mini")));
			});
		}
	};

	setInterval(function() {
		frappe.datetime.refresh_when();
	}, 60000); // refresh every minute

	// for testing
	frappe.click_button = function(text, idx) {
		var container = '';
		if(typeof idx === 'string') {
			container = idx + ' ';
			idx = 0;
		}
		var element = $((container + ".btn:contains(\"" + text + "\"):visible"));
		if(!element.length) {
			throw ("did not find any button containing " + text);
		}
		element.get(idx || 0).click();
		return frappe.timeout(0.5);
	};

	frappe.click_link = function(text, idx) {
		var element = $(("a:contains(\"" + text + "\"):visible"));
		if(!element.length) {
			throw ("did not find any link containing " + text);
		}
		element.get(idx || 0).click();
		return frappe.timeout(0.5);
	};

	frappe.click_element = function(selector, idx) {
		// Selector by class name like $(`.cart-items`)
		var element = $(("" + selector));
		if(!element.length) {
			throw ("did not find any link containing " + selector);
		}
		element.get(idx || 0).click();
		return frappe.timeout(0.5);
	};

	frappe.set_control= function(fieldname, value) {
		var control = $((".form-control[data-fieldname=\"" + fieldname + "\"]:visible"));
		if(!control.length) {
			throw ("did not find any control with fieldname " + fieldname);
		}
		control.val(value).trigger('change');
		return frappe.timeout(0.5);
	};

	frappe.click_check = function(label, idx) {
		var check = $((".checkbox:contains(\"" + label + "\") input"));
		if(!check.length) {
			throw ("did not find any checkbox with label " + label);
		}
		check.get(idx || 0).click();
		return frappe.timeout(0.5);
	};

	var showdown = createCommonjsModule(function (module) {
	(function(){
	/**
	 * Created by Tivie on 13-07-2015.
	 */

	function getDefaultOpts (simple) {

	  var defaultOptions = {
	    omitExtraWLInCodeBlocks: {
	      defaultValue: false,
	      describe: 'Omit the default extra whiteline added to code blocks',
	      type: 'boolean'
	    },
	    noHeaderId: {
	      defaultValue: false,
	      describe: 'Turn on/off generated header id',
	      type: 'boolean'
	    },
	    prefixHeaderId: {
	      defaultValue: false,
	      describe: 'Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic \'section-\' prefix',
	      type: 'string'
	    },
	    rawPrefixHeaderId: {
	      defaultValue: false,
	      describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
	      type: 'boolean'
	    },
	    ghCompatibleHeaderId: {
	      defaultValue: false,
	      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',
	      type: 'boolean'
	    },
	    rawHeaderId: {
	      defaultValue: false,
	      describe: 'Remove only spaces, \' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids',
	      type: 'boolean'
	    },
	    headerLevelStart: {
	      defaultValue: false,
	      describe: 'The header blocks level start',
	      type: 'integer'
	    },
	    parseImgDimensions: {
	      defaultValue: false,
	      describe: 'Turn on/off image dimension parsing',
	      type: 'boolean'
	    },
	    simplifiedAutoLink: {
	      defaultValue: false,
	      describe: 'Turn on/off GFM autolink style',
	      type: 'boolean'
	    },
	    excludeTrailingPunctuationFromURLs: {
	      defaultValue: false,
	      describe: 'Excludes trailing punctuation from links generated with autoLinking',
	      type: 'boolean'
	    },
	    literalMidWordUnderscores: {
	      defaultValue: false,
	      describe: 'Parse midword underscores as literal underscores',
	      type: 'boolean'
	    },
	    literalMidWordAsterisks: {
	      defaultValue: false,
	      describe: 'Parse midword asterisks as literal asterisks',
	      type: 'boolean'
	    },
	    strikethrough: {
	      defaultValue: false,
	      describe: 'Turn on/off strikethrough support',
	      type: 'boolean'
	    },
	    tables: {
	      defaultValue: false,
	      describe: 'Turn on/off tables support',
	      type: 'boolean'
	    },
	    tablesHeaderId: {
	      defaultValue: false,
	      describe: 'Add an id to table headers',
	      type: 'boolean'
	    },
	    ghCodeBlocks: {
	      defaultValue: true,
	      describe: 'Turn on/off GFM fenced code blocks support',
	      type: 'boolean'
	    },
	    tasklists: {
	      defaultValue: false,
	      describe: 'Turn on/off GFM tasklist support',
	      type: 'boolean'
	    },
	    smoothLivePreview: {
	      defaultValue: false,
	      describe: 'Prevents weird effects in live previews due to incomplete input',
	      type: 'boolean'
	    },
	    smartIndentationFix: {
	      defaultValue: false,
	      description: 'Tries to smartly fix indentation in es6 strings',
	      type: 'boolean'
	    },
	    disableForced4SpacesIndentedSublists: {
	      defaultValue: false,
	      description: 'Disables the requirement of indenting nested sublists by 4 spaces',
	      type: 'boolean'
	    },
	    simpleLineBreaks: {
	      defaultValue: false,
	      description: 'Parses simple line breaks as <br> (GFM Style)',
	      type: 'boolean'
	    },
	    requireSpaceBeforeHeadingText: {
	      defaultValue: false,
	      description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',
	      type: 'boolean'
	    },
	    ghMentions: {
	      defaultValue: false,
	      description: 'Enables github @mentions',
	      type: 'boolean'
	    },
	    ghMentionsLink: {
	      defaultValue: 'https://github.com/{u}',
	      description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',
	      type: 'string'
	    },
	    encodeEmails: {
	      defaultValue: true,
	      description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',
	      type: 'boolean'
	    },
	    openLinksInNewWindow: {
	      defaultValue: false,
	      description: 'Open all links in new windows',
	      type: 'boolean'
	    },
	    backslashEscapesHTMLTags: {
	      defaultValue: false,
	      description: 'Support for HTML Tag escaping. ex: \<div>foo\</div>',
	      type: 'boolean'
	    },
	    emoji: {
	      defaultValue: false,
	      description: 'Enable emoji support. Ex: `this is a :smile: emoji`',
	      type: 'boolean'
	    },
	    underline: {
	      defaultValue: false,
	      description: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`',
	      type: 'boolean'
	    },
	    completeHTMLDocument: {
	      defaultValue: false,
	      description: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags',
	      type: 'boolean'
	    },
	    metadata: {
	      defaultValue: false,
	      description: 'Enable support for document metadata (defined at the top of the document between `` and `` or between `---` and `---`).',
	      type: 'boolean'
	    },
	    splitAdjacentBlockquotes: {
	      defaultValue: false,
	      description: 'Split adjacent blockquote blocks',
	      type: 'boolean'
	    }
	  };
	  if (simple === false) {
	    return JSON.parse(JSON.stringify(defaultOptions));
	  }
	  var ret = {};
	  for (var opt in defaultOptions) {
	    if (defaultOptions.hasOwnProperty(opt)) {
	      ret[opt] = defaultOptions[opt].defaultValue;
	    }
	  }
	  return ret;
	}

	function allOptionsOn () {
	  var options = getDefaultOpts(true),
	      ret = {};
	  for (var opt in options) {
	    if (options.hasOwnProperty(opt)) {
	      ret[opt] = true;
	    }
	  }
	  return ret;
	}

	/**
	 * Created by Tivie on 06-01-2015.
	 */

	// Private properties
	var showdown = {},
	    parsers = {},
	    extensions = {},
	    globalOptions = getDefaultOpts(true),
	    setFlavor = 'vanilla',
	    flavor = {
	      github: {
	        omitExtraWLInCodeBlocks:              true,
	        simplifiedAutoLink:                   true,
	        excludeTrailingPunctuationFromURLs:   true,
	        literalMidWordUnderscores:            true,
	        strikethrough:                        true,
	        tables:                               true,
	        tablesHeaderId:                       true,
	        ghCodeBlocks:                         true,
	        tasklists:                            true,
	        disableForced4SpacesIndentedSublists: true,
	        simpleLineBreaks:                     true,
	        requireSpaceBeforeHeadingText:        true,
	        ghCompatibleHeaderId:                 true,
	        ghMentions:                           true,
	        backslashEscapesHTMLTags:             true,
	        emoji:                                true,
	        splitAdjacentBlockquotes:             true
	      },
	      original: {
	        noHeaderId:                           true,
	        ghCodeBlocks:                         false
	      },
	      ghost: {
	        omitExtraWLInCodeBlocks:              true,
	        parseImgDimensions:                   true,
	        simplifiedAutoLink:                   true,
	        excludeTrailingPunctuationFromURLs:   true,
	        literalMidWordUnderscores:            true,
	        strikethrough:                        true,
	        tables:                               true,
	        tablesHeaderId:                       true,
	        ghCodeBlocks:                         true,
	        tasklists:                            true,
	        smoothLivePreview:                    true,
	        simpleLineBreaks:                     true,
	        requireSpaceBeforeHeadingText:        true,
	        ghMentions:                           false,
	        encodeEmails:                         true
	      },
	      vanilla: getDefaultOpts(true),
	      allOn: allOptionsOn()
	    };

	/**
	 * helper namespace
	 * @type {{}}
	 */
	showdown.helper = {};

	/**
	 * TODO LEGACY SUPPORT CODE
	 * @type {{}}
	 */
	showdown.extensions = {};

	/**
	 * Set a global option
	 * @static
	 * @param {string} key
	 * @param {*} value
	 * @returns {showdown}
	 */
	showdown.setOption = function (key, value) {
	  globalOptions[key] = value;
	  return this;
	};

	/**
	 * Get a global option
	 * @static
	 * @param {string} key
	 * @returns {*}
	 */
	showdown.getOption = function (key) {
	  return globalOptions[key];
	};

	/**
	 * Get the global options
	 * @static
	 * @returns {{}}
	 */
	showdown.getOptions = function () {
	  return globalOptions;
	};

	/**
	 * Reset global options to the default values
	 * @static
	 */
	showdown.resetOptions = function () {
	  globalOptions = getDefaultOpts(true);
	};

	/**
	 * Set the flavor showdown should use as default
	 * @param {string} name
	 */
	showdown.setFlavor = function (name) {
	  if (!flavor.hasOwnProperty(name)) {
	    throw Error(name + ' flavor was not found');
	  }
	  showdown.resetOptions();
	  var preset = flavor[name];
	  setFlavor = name;
	  for (var option in preset) {
	    if (preset.hasOwnProperty(option)) {
	      globalOptions[option] = preset[option];
	    }
	  }
	};

	/**
	 * Get the currently set flavor
	 * @returns {string}
	 */
	showdown.getFlavor = function () {
	  return setFlavor;
	};

	/**
	 * Get the options of a specified flavor. Returns undefined if the flavor was not found
	 * @param {string} name Name of the flavor
	 * @returns {{}|undefined}
	 */
	showdown.getFlavorOptions = function (name) {
	  if (flavor.hasOwnProperty(name)) {
	    return flavor[name];
	  }
	};

	/**
	 * Get the default options
	 * @static
	 * @param {boolean} [simple=true]
	 * @returns {{}}
	 */
	showdown.getDefaultOptions = function (simple) {
	  return getDefaultOpts(simple);
	};

	/**
	 * Get or set a subParser
	 *
	 * subParser(name)       - Get a registered subParser
	 * subParser(name, func) - Register a subParser
	 * @static
	 * @param {string} name
	 * @param {function} [func]
	 * @returns {*}
	 */
	showdown.subParser = function (name, func) {
	  if (showdown.helper.isString(name)) {
	    if (typeof func !== 'undefined') {
	      parsers[name] = func;
	    } else {
	      if (parsers.hasOwnProperty(name)) {
	        return parsers[name];
	      } else {
	        throw Error('SubParser named ' + name + ' not registered!');
	      }
	    }
	  }
	};

	/**
	 * Gets or registers an extension
	 * @static
	 * @param {string} name
	 * @param {object|function=} ext
	 * @returns {*}
	 */
	showdown.extension = function (name, ext) {

	  if (!showdown.helper.isString(name)) {
	    throw Error('Extension \'name\' must be a string');
	  }

	  name = showdown.helper.stdExtName(name);

	  // Getter
	  if (showdown.helper.isUndefined(ext)) {
	    if (!extensions.hasOwnProperty(name)) {
	      throw Error('Extension named ' + name + ' is not registered!');
	    }
	    return extensions[name];

	    // Setter
	  } else {
	    // Expand extension if it's wrapped in a function
	    if (typeof ext === 'function') {
	      ext = ext();
	    }

	    // Ensure extension is an array
	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }

	    var validExtension = validate(ext, name);

	    if (validExtension.valid) {
	      extensions[name] = ext;
	    } else {
	      throw Error(validExtension.error);
	    }
	  }
	};

	/**
	 * Gets all extensions registered
	 * @returns {{}}
	 */
	showdown.getAllExtensions = function () {
	  return extensions;
	};

	/**
	 * Remove an extension
	 * @param {string} name
	 */
	showdown.removeExtension = function (name) {
	  delete extensions[name];
	};

	/**
	 * Removes all extensions
	 */
	showdown.resetExtensions = function () {
	  extensions = {};
	};

	/**
	 * Validate extension
	 * @param {array} extension
	 * @param {string} name
	 * @returns {{valid: boolean, error: string}}
	 */
	function validate (extension, name) {

	  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',
	      ret = {
	        valid: true,
	        error: ''
	      };

	  if (!showdown.helper.isArray(extension)) {
	    extension = [extension];
	  }

	  for (var i = 0; i < extension.length; ++i) {
	    var baseMsg = errMsg + ' sub-extension ' + i + ': ',
	        ext = extension[i];
	    if (typeof ext !== 'object') {
	      ret.valid = false;
	      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';
	      return ret;
	    }

	    if (!showdown.helper.isString(ext.type)) {
	      ret.valid = false;
	      ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + ' given';
	      return ret;
	    }

	    var type = ext.type = ext.type.toLowerCase();

	    // normalize extension type
	    if (type === 'language') {
	      type = ext.type = 'lang';
	    }

	    if (type === 'html') {
	      type = ext.type = 'output';
	    }

	    if (type !== 'lang' && type !== 'output' && type !== 'listener') {
	      ret.valid = false;
	      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
	      return ret;
	    }

	    if (type === 'listener') {
	      if (showdown.helper.isUndefined(ext.listeners)) {
	        ret.valid = false;
	        ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
	        return ret;
	      }
	    } else {
	      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {
	        ret.valid = false;
	        ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
	        return ret;
	      }
	    }

	    if (ext.listeners) {
	      if (typeof ext.listeners !== 'object') {
	        ret.valid = false;
	        ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + ' given';
	        return ret;
	      }
	      for (var ln in ext.listeners) {
	        if (ext.listeners.hasOwnProperty(ln)) {
	          if (typeof ext.listeners[ln] !== 'function') {
	            ret.valid = false;
	            ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln +
	              ' must be a function but ' + typeof ext.listeners[ln] + ' given';
	            return ret;
	          }
	        }
	      }
	    }

	    if (ext.filter) {
	      if (typeof ext.filter !== 'function') {
	        ret.valid = false;
	        ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + ' given';
	        return ret;
	      }
	    } else if (ext.regex) {
	      if (showdown.helper.isString(ext.regex)) {
	        ext.regex = new RegExp(ext.regex, 'g');
	      }
	      if (!(ext.regex instanceof RegExp)) {
	        ret.valid = false;
	        ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';
	        return ret;
	      }
	      if (showdown.helper.isUndefined(ext.replace)) {
	        ret.valid = false;
	        ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
	        return ret;
	      }
	    }
	  }
	  return ret;
	}

	/**
	 * Validate extension
	 * @param {object} ext
	 * @returns {boolean}
	 */
	showdown.validateExtension = function (ext) {

	  var validateExtension = validate(ext, null);
	  if (!validateExtension.valid) {
	    console.warn(validateExtension.error);
	    return false;
	  }
	  return true;
	};

	/**
	 * showdownjs helper functions
	 */

	if (!showdown.hasOwnProperty('helper')) {
	  showdown.helper = {};
	}

	/**
	 * Check if var is string
	 * @static
	 * @param {string} a
	 * @returns {boolean}
	 */
	showdown.helper.isString = function (a) {
	  return (typeof a === 'string' || a instanceof String);
	};

	/**
	 * Check if var is a function
	 * @static
	 * @param {*} a
	 * @returns {boolean}
	 */
	showdown.helper.isFunction = function (a) {
	  var getType = {};
	  return a && getType.toString.call(a) === '[object Function]';
	};

	/**
	 * isArray helper function
	 * @static
	 * @param {*} a
	 * @returns {boolean}
	 */
	showdown.helper.isArray = function (a) {
	  return Array.isArray(a);
	};

	/**
	 * Check if value is undefined
	 * @static
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	 */
	showdown.helper.isUndefined = function (value) {
	  return typeof value === 'undefined';
	};

	/**
	 * ForEach helper function
	 * Iterates over Arrays and Objects (own properties only)
	 * @static
	 * @param {*} obj
	 * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object
	 */
	showdown.helper.forEach = function (obj, callback) {
	  // check if obj is defined
	  if (showdown.helper.isUndefined(obj)) {
	    throw new Error('obj param is required');
	  }

	  if (showdown.helper.isUndefined(callback)) {
	    throw new Error('callback param is required');
	  }

	  if (!showdown.helper.isFunction(callback)) {
	    throw new Error('callback param must be a function/closure');
	  }

	  if (typeof obj.forEach === 'function') {
	    obj.forEach(callback);
	  } else if (showdown.helper.isArray(obj)) {
	    for (var i = 0; i < obj.length; i++) {
	      callback(obj[i], i, obj);
	    }
	  } else if (typeof (obj) === 'object') {
	    for (var prop in obj) {
	      if (obj.hasOwnProperty(prop)) {
	        callback(obj[prop], prop, obj);
	      }
	    }
	  } else {
	    throw new Error('obj does not seem to be an array or an iterable object');
	  }
	};

	/**
	 * Standardidize extension name
	 * @static
	 * @param {string} s extension name
	 * @returns {string}
	 */
	showdown.helper.stdExtName = function (s) {
	  return s.replace(/[_?*+\/\\.^-]/g, '').replace(/\s/g, '').toLowerCase();
	};

	function escapeCharactersCallback (wholeMatch, m1) {
	  var charCodeToEscape = m1.charCodeAt(0);
	  return 'E' + charCodeToEscape + 'E';
	}

	/**
	 * Callback used to escape characters when passing through String.replace
	 * @static
	 * @param {string} wholeMatch
	 * @param {string} m1
	 * @returns {string}
	 */
	showdown.helper.escapeCharactersCallback = escapeCharactersCallback;

	/**
	 * Escape characters in a string
	 * @static
	 * @param {string} text
	 * @param {string} charsToEscape
	 * @param {boolean} afterBackslash
	 * @returns {XML|string|void|*}
	 */
	showdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {
	  // First we have to escape the escape characters so that
	  // we can build a character class out of them
	  var regexString = '([' + charsToEscape.replace(/([\[\]\\])/g, '\\$1') + '])';

	  if (afterBackslash) {
	    regexString = '\\\\' + regexString;
	  }

	  var regex = new RegExp(regexString, 'g');
	  text = text.replace(regex, escapeCharactersCallback);

	  return text;
	};

	/**
	 * Unescape HTML entities
	 * @param txt
	 * @returns {string}
	 */
	showdown.helper.unescapeHTMLEntities = function (txt) {

	  return txt
	    .replace(/&quot;/g, '"')
	    .replace(/&lt;/g, '<')
	    .replace(/&gt;/g, '>')
	    .replace(/&amp;/g, '&');
	};

	var rgxFindMatchPos = function (str, left, right, flags) {
	  var f = flags || '',
	      g = f.indexOf('g') > -1,
	      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),
	      l = new RegExp(left, f.replace(/g/g, '')),
	      pos = [],
	      t, s, m, start, end;

	  do {
	    t = 0;
	    while ((m = x.exec(str))) {
	      if (l.test(m[0])) {
	        if (!(t++)) {
	          s = x.lastIndex;
	          start = s - m[0].length;
	        }
	      } else if (t) {
	        if (!--t) {
	          end = m.index + m[0].length;
	          var obj = {
	            left: {start: start, end: s},
	            match: {start: s, end: m.index},
	            right: {start: m.index, end: end},
	            wholeMatch: {start: start, end: end}
	          };
	          pos.push(obj);
	          if (!g) {
	            return pos;
	          }
	        }
	      }
	    }
	  } while (t && (x.lastIndex = s));

	  return pos;
	};

	/**
	 * matchRecursiveRegExp
	 *
	 * (c) 2007 Steven Levithan <stevenlevithan.com>
	 * MIT License
	 *
	 * Accepts a string to search, a left and right format delimiter
	 * as regex patterns, and optional regex flags. Returns an array
	 * of matches, allowing nested instances of left/right delimiters.
	 * Use the "g" flag to return all matches, otherwise only the
	 * first is returned. Be careful to ensure that the left and
	 * right format delimiters produce mutually exclusive matches.
	 * Backreferences are not supported within the right delimiter
	 * due to how it is internally combined with the left delimiter.
	 * When matching strings whose format delimiters are unbalanced
	 * to the left or right, the output is intentionally as a
	 * conventional regex library with recursion support would
	 * produce, e.g. "<<x>" and "<x>>" both produce ["x"] when using
	 * "<" and ">" as the delimiters (both strings contain a single,
	 * balanced instance of "<x>").
	 *
	 * examples:
	 * matchRecursiveRegExp("test", "\\(", "\\)")
	 * returns: []
	 * matchRecursiveRegExp("<t<<e>><s>>t<>", "<", ">", "g")
	 * returns: ["t<<e>><s>", ""]
	 * matchRecursiveRegExp("<div id=\"x\">test</div>", "<div\\b[^>]*>", "</div>", "gi")
	 * returns: ["test"]
	 */
	showdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {

	  var matchPos = rgxFindMatchPos (str, left, right, flags),
	      results = [];

	  for (var i = 0; i < matchPos.length; ++i) {
	    results.push([
	      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
	      str.slice(matchPos[i].match.start, matchPos[i].match.end),
	      str.slice(matchPos[i].left.start, matchPos[i].left.end),
	      str.slice(matchPos[i].right.start, matchPos[i].right.end)
	    ]);
	  }
	  return results;
	};

	/**
	 *
	 * @param {string} str
	 * @param {string|function} replacement
	 * @param {string} left
	 * @param {string} right
	 * @param {string} flags
	 * @returns {string}
	 */
	showdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {

	  if (!showdown.helper.isFunction(replacement)) {
	    var repStr = replacement;
	    replacement = function () {
	      return repStr;
	    };
	  }

	  var matchPos = rgxFindMatchPos(str, left, right, flags),
	      finalStr = str,
	      lng = matchPos.length;

	  if (lng > 0) {
	    var bits = [];
	    if (matchPos[0].wholeMatch.start !== 0) {
	      bits.push(str.slice(0, matchPos[0].wholeMatch.start));
	    }
	    for (var i = 0; i < lng; ++i) {
	      bits.push(
	        replacement(
	          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
	          str.slice(matchPos[i].match.start, matchPos[i].match.end),
	          str.slice(matchPos[i].left.start, matchPos[i].left.end),
	          str.slice(matchPos[i].right.start, matchPos[i].right.end)
	        )
	      );
	      if (i < lng - 1) {
	        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
	      }
	    }
	    if (matchPos[lng - 1].wholeMatch.end < str.length) {
	      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
	    }
	    finalStr = bits.join('');
	  }
	  return finalStr;
	};

	/**
	 * Returns the index within the passed String object of the first occurrence of the specified regex,
	 * starting the search at fromIndex. Returns -1 if the value is not found.
	 *
	 * @param {string} str string to search
	 * @param {RegExp} regex Regular expression to search
	 * @param {int} [fromIndex = 0] Index to start the search
	 * @returns {Number}
	 * @throws InvalidArgumentError
	 */
	showdown.helper.regexIndexOf = function (str, regex, fromIndex) {
	  if (!showdown.helper.isString(str)) {
	    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
	  }
	  if (regex instanceof RegExp === false) {
	    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';
	  }
	  var indexOf = str.substring(fromIndex || 0).search(regex);
	  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;
	};

	/**
	 * Splits the passed string object at the defined index, and returns an array composed of the two substrings
	 * @param {string} str string to split
	 * @param {int} index index to split string at
	 * @returns {[string,string]}
	 * @throws InvalidArgumentError
	 */
	showdown.helper.splitAtIndex = function (str, index) {
	  if (!showdown.helper.isString(str)) {
	    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
	  }
	  return [str.substring(0, index), str.substring(index)];
	};

	/**
	 * Obfuscate an e-mail address through the use of Character Entities,
	 * transforming ASCII characters into their equivalent decimal or hex entities.
	 *
	 * Since it has a random component, subsequent calls to this function produce different results
	 *
	 * @param {string} mail
	 * @returns {string}
	 */
	showdown.helper.encodeEmailAddress = function (mail) {
	  var encode = [
	    function (ch) {
	      return '&#' + ch.charCodeAt(0) + ';';
	    },
	    function (ch) {
	      return '&#x' + ch.charCodeAt(0).toString(16) + ';';
	    },
	    function (ch) {
	      return ch;
	    }
	  ];

	  mail = mail.replace(/./g, function (ch) {
	    if (ch === '@') {
	      // this *must* be encoded. I insist.
	      ch = encode[Math.floor(Math.random() * 2)](ch);
	    } else {
	      var r = Math.random();
	      // roughly 10% raw, 45% hex, 45% dec
	      ch = (
	        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)
	      );
	    }
	    return ch;
	  });

	  return mail;
	};

	/**
	 *
	 * @param str
	 * @param targetLength
	 * @param padString
	 * @returns {string}
	 */
	showdown.helper.padEnd = function padEnd (str, targetLength, padString) {
	  /*jshint bitwise: false*/
	  // eslint-disable-next-line space-infix-ops
	  targetLength = targetLength>>0; //floor if number or convert non-number to 0;
	  /*jshint bitwise: true*/
	  padString = String(padString || ' ');
	  if (str.length > targetLength) {
	    return String(str);
	  } else {
	    targetLength = targetLength - str.length;
	    if (targetLength > padString.length) {
	      padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
	    }
	    return String(str) + padString.slice(0,targetLength);
	  }
	};

	/**
	 * POLYFILLS
	 */
	// use this instead of builtin is undefined for IE8 compatibility
	if (typeof(console) === 'undefined') {
	  console = {
	    warn: function (msg) {
	      alert(msg);
	    },
	    log: function (msg) {
	      alert(msg);
	    },
	    error: function (msg) {
	      throw msg;
	    }
	  };
	}

	/**
	 * Common regexes.
	 * We declare some common regexes to improve performance
	 */
	showdown.helper.regexes = {
	  asteriskDashAndColon: /([*_:~])/g
	};

	/**
	 * EMOJIS LIST
	 */
	showdown.helper.emojis = {
	  '+1':'\ud83d\udc4d',
	  '-1':'\ud83d\udc4e',
	  '100':'\ud83d\udcaf',
	  '1234':'\ud83d\udd22',
	  '1st_place_medal':'\ud83e\udd47',
	  '2nd_place_medal':'\ud83e\udd48',
	  '3rd_place_medal':'\ud83e\udd49',
	  '8ball':'\ud83c\udfb1',
	  'a':'\ud83c\udd70\ufe0f',
	  'ab':'\ud83c\udd8e',
	  'abc':'\ud83d\udd24',
	  'abcd':'\ud83d\udd21',
	  'accept':'\ud83c\ude51',
	  'aerial_tramway':'\ud83d\udea1',
	  'airplane':'\u2708\ufe0f',
	  'alarm_clock':'\u23f0',
	  'alembic':'\u2697\ufe0f',
	  'alien':'\ud83d\udc7d',
	  'ambulance':'\ud83d\ude91',
	  'amphora':'\ud83c\udffa',
	  'anchor':'\u2693\ufe0f',
	  'angel':'\ud83d\udc7c',
	  'anger':'\ud83d\udca2',
	  'angry':'\ud83d\ude20',
	  'anguished':'\ud83d\ude27',
	  'ant':'\ud83d\udc1c',
	  'apple':'\ud83c\udf4e',
	  'aquarius':'\u2652\ufe0f',
	  'aries':'\u2648\ufe0f',
	  'arrow_backward':'\u25c0\ufe0f',
	  'arrow_double_down':'\u23ec',
	  'arrow_double_up':'\u23eb',
	  'arrow_down':'\u2b07\ufe0f',
	  'arrow_down_small':'\ud83d\udd3d',
	  'arrow_forward':'\u25b6\ufe0f',
	  'arrow_heading_down':'\u2935\ufe0f',
	  'arrow_heading_up':'\u2934\ufe0f',
	  'arrow_left':'\u2b05\ufe0f',
	  'arrow_lower_left':'\u2199\ufe0f',
	  'arrow_lower_right':'\u2198\ufe0f',
	  'arrow_right':'\u27a1\ufe0f',
	  'arrow_right_hook':'\u21aa\ufe0f',
	  'arrow_up':'\u2b06\ufe0f',
	  'arrow_up_down':'\u2195\ufe0f',
	  'arrow_up_small':'\ud83d\udd3c',
	  'arrow_upper_left':'\u2196\ufe0f',
	  'arrow_upper_right':'\u2197\ufe0f',
	  'arrows_clockwise':'\ud83d\udd03',
	  'arrows_counterclockwise':'\ud83d\udd04',
	  'art':'\ud83c\udfa8',
	  'articulated_lorry':'\ud83d\ude9b',
	  'artificial_satellite':'\ud83d\udef0',
	  'astonished':'\ud83d\ude32',
	  'athletic_shoe':'\ud83d\udc5f',
	  'atm':'\ud83c\udfe7',
	  'atom_symbol':'\u269b\ufe0f',
	  'avocado':'\ud83e\udd51',
	  'b':'\ud83c\udd71\ufe0f',
	  'baby':'\ud83d\udc76',
	  'baby_bottle':'\ud83c\udf7c',
	  'baby_chick':'\ud83d\udc24',
	  'baby_symbol':'\ud83d\udebc',
	  'back':'\ud83d\udd19',
	  'bacon':'\ud83e\udd53',
	  'badminton':'\ud83c\udff8',
	  'baggage_claim':'\ud83d\udec4',
	  'baguette_bread':'\ud83e\udd56',
	  'balance_scale':'\u2696\ufe0f',
	  'balloon':'\ud83c\udf88',
	  'ballot_box':'\ud83d\uddf3',
	  'ballot_box_with_check':'\u2611\ufe0f',
	  'bamboo':'\ud83c\udf8d',
	  'banana':'\ud83c\udf4c',
	  'bangbang':'\u203c\ufe0f',
	  'bank':'\ud83c\udfe6',
	  'bar_chart':'\ud83d\udcca',
	  'barber':'\ud83d\udc88',
	  'baseball':'\u26be\ufe0f',
	  'basketball':'\ud83c\udfc0',
	  'basketball_man':'\u26f9\ufe0f',
	  'basketball_woman':'\u26f9\ufe0f&zwj;\u2640\ufe0f',
	  'bat':'\ud83e\udd87',
	  'bath':'\ud83d\udec0',
	  'bathtub':'\ud83d\udec1',
	  'battery':'\ud83d\udd0b',
	  'beach_umbrella':'\ud83c\udfd6',
	  'bear':'\ud83d\udc3b',
	  'bed':'\ud83d\udecf',
	  'bee':'\ud83d\udc1d',
	  'beer':'\ud83c\udf7a',
	  'beers':'\ud83c\udf7b',
	  'beetle':'\ud83d\udc1e',
	  'beginner':'\ud83d\udd30',
	  'bell':'\ud83d\udd14',
	  'bellhop_bell':'\ud83d\udece',
	  'bento':'\ud83c\udf71',
	  'biking_man':'\ud83d\udeb4',
	  'bike':'\ud83d\udeb2',
	  'biking_woman':'\ud83d\udeb4&zwj;\u2640\ufe0f',
	  'bikini':'\ud83d\udc59',
	  'biohazard':'\u2623\ufe0f',
	  'bird':'\ud83d\udc26',
	  'birthday':'\ud83c\udf82',
	  'black_circle':'\u26ab\ufe0f',
	  'black_flag':'\ud83c\udff4',
	  'black_heart':'\ud83d\udda4',
	  'black_joker':'\ud83c\udccf',
	  'black_large_square':'\u2b1b\ufe0f',
	  'black_medium_small_square':'\u25fe\ufe0f',
	  'black_medium_square':'\u25fc\ufe0f',
	  'black_nib':'\u2712\ufe0f',
	  'black_small_square':'\u25aa\ufe0f',
	  'black_square_button':'\ud83d\udd32',
	  'blonde_man':'\ud83d\udc71',
	  'blonde_woman':'\ud83d\udc71&zwj;\u2640\ufe0f',
	  'blossom':'\ud83c\udf3c',
	  'blowfish':'\ud83d\udc21',
	  'blue_book':'\ud83d\udcd8',
	  'blue_car':'\ud83d\ude99',
	  'blue_heart':'\ud83d\udc99',
	  'blush':'\ud83d\ude0a',
	  'boar':'\ud83d\udc17',
	  'boat':'\u26f5\ufe0f',
	  'bomb':'\ud83d\udca3',
	  'book':'\ud83d\udcd6',
	  'bookmark':'\ud83d\udd16',
	  'bookmark_tabs':'\ud83d\udcd1',
	  'books':'\ud83d\udcda',
	  'boom':'\ud83d\udca5',
	  'boot':'\ud83d\udc62',
	  'bouquet':'\ud83d\udc90',
	  'bowing_man':'\ud83d\ude47',
	  'bow_and_arrow':'\ud83c\udff9',
	  'bowing_woman':'\ud83d\ude47&zwj;\u2640\ufe0f',
	  'bowling':'\ud83c\udfb3',
	  'boxing_glove':'\ud83e\udd4a',
	  'boy':'\ud83d\udc66',
	  'bread':'\ud83c\udf5e',
	  'bride_with_veil':'\ud83d\udc70',
	  'bridge_at_night':'\ud83c\udf09',
	  'briefcase':'\ud83d\udcbc',
	  'broken_heart':'\ud83d\udc94',
	  'bug':'\ud83d\udc1b',
	  'building_construction':'\ud83c\udfd7',
	  'bulb':'\ud83d\udca1',
	  'bullettrain_front':'\ud83d\ude85',
	  'bullettrain_side':'\ud83d\ude84',
	  'burrito':'\ud83c\udf2f',
	  'bus':'\ud83d\ude8c',
	  'business_suit_levitating':'\ud83d\udd74',
	  'busstop':'\ud83d\ude8f',
	  'bust_in_silhouette':'\ud83d\udc64',
	  'busts_in_silhouette':'\ud83d\udc65',
	  'butterfly':'\ud83e\udd8b',
	  'cactus':'\ud83c\udf35',
	  'cake':'\ud83c\udf70',
	  'calendar':'\ud83d\udcc6',
	  'call_me_hand':'\ud83e\udd19',
	  'calling':'\ud83d\udcf2',
	  'camel':'\ud83d\udc2b',
	  'camera':'\ud83d\udcf7',
	  'camera_flash':'\ud83d\udcf8',
	  'camping':'\ud83c\udfd5',
	  'cancer':'\u264b\ufe0f',
	  'candle':'\ud83d\udd6f',
	  'candy':'\ud83c\udf6c',
	  'canoe':'\ud83d\udef6',
	  'capital_abcd':'\ud83d\udd20',
	  'capricorn':'\u2651\ufe0f',
	  'car':'\ud83d\ude97',
	  'card_file_box':'\ud83d\uddc3',
	  'card_index':'\ud83d\udcc7',
	  'card_index_dividers':'\ud83d\uddc2',
	  'carousel_horse':'\ud83c\udfa0',
	  'carrot':'\ud83e\udd55',
	  'cat':'\ud83d\udc31',
	  'cat2':'\ud83d\udc08',
	  'cd':'\ud83d\udcbf',
	  'chains':'\u26d3',
	  'champagne':'\ud83c\udf7e',
	  'chart':'\ud83d\udcb9',
	  'chart_with_downwards_trend':'\ud83d\udcc9',
	  'chart_with_upwards_trend':'\ud83d\udcc8',
	  'checkered_flag':'\ud83c\udfc1',
	  'cheese':'\ud83e\uddc0',
	  'cherries':'\ud83c\udf52',
	  'cherry_blossom':'\ud83c\udf38',
	  'chestnut':'\ud83c\udf30',
	  'chicken':'\ud83d\udc14',
	  'children_crossing':'\ud83d\udeb8',
	  'chipmunk':'\ud83d\udc3f',
	  'chocolate_bar':'\ud83c\udf6b',
	  'christmas_tree':'\ud83c\udf84',
	  'church':'\u26ea\ufe0f',
	  'cinema':'\ud83c\udfa6',
	  'circus_tent':'\ud83c\udfaa',
	  'city_sunrise':'\ud83c\udf07',
	  'city_sunset':'\ud83c\udf06',
	  'cityscape':'\ud83c\udfd9',
	  'cl':'\ud83c\udd91',
	  'clamp':'\ud83d\udddc',
	  'clap':'\ud83d\udc4f',
	  'clapper':'\ud83c\udfac',
	  'classical_building':'\ud83c\udfdb',
	  'clinking_glasses':'\ud83e\udd42',
	  'clipboard':'\ud83d\udccb',
	  'clock1':'\ud83d\udd50',
	  'clock10':'\ud83d\udd59',
	  'clock1030':'\ud83d\udd65',
	  'clock11':'\ud83d\udd5a',
	  'clock1130':'\ud83d\udd66',
	  'clock12':'\ud83d\udd5b',
	  'clock1230':'\ud83d\udd67',
	  'clock130':'\ud83d\udd5c',
	  'clock2':'\ud83d\udd51',
	  'clock230':'\ud83d\udd5d',
	  'clock3':'\ud83d\udd52',
	  'clock330':'\ud83d\udd5e',
	  'clock4':'\ud83d\udd53',
	  'clock430':'\ud83d\udd5f',
	  'clock5':'\ud83d\udd54',
	  'clock530':'\ud83d\udd60',
	  'clock6':'\ud83d\udd55',
	  'clock630':'\ud83d\udd61',
	  'clock7':'\ud83d\udd56',
	  'clock730':'\ud83d\udd62',
	  'clock8':'\ud83d\udd57',
	  'clock830':'\ud83d\udd63',
	  'clock9':'\ud83d\udd58',
	  'clock930':'\ud83d\udd64',
	  'closed_book':'\ud83d\udcd5',
	  'closed_lock_with_key':'\ud83d\udd10',
	  'closed_umbrella':'\ud83c\udf02',
	  'cloud':'\u2601\ufe0f',
	  'cloud_with_lightning':'\ud83c\udf29',
	  'cloud_with_lightning_and_rain':'\u26c8',
	  'cloud_with_rain':'\ud83c\udf27',
	  'cloud_with_snow':'\ud83c\udf28',
	  'clown_face':'\ud83e\udd21',
	  'clubs':'\u2663\ufe0f',
	  'cocktail':'\ud83c\udf78',
	  'coffee':'\u2615\ufe0f',
	  'coffin':'\u26b0\ufe0f',
	  'cold_sweat':'\ud83d\ude30',
	  'comet':'\u2604\ufe0f',
	  'computer':'\ud83d\udcbb',
	  'computer_mouse':'\ud83d\uddb1',
	  'confetti_ball':'\ud83c\udf8a',
	  'confounded':'\ud83d\ude16',
	  'confused':'\ud83d\ude15',
	  'congratulations':'\u3297\ufe0f',
	  'construction':'\ud83d\udea7',
	  'construction_worker_man':'\ud83d\udc77',
	  'construction_worker_woman':'\ud83d\udc77&zwj;\u2640\ufe0f',
	  'control_knobs':'\ud83c\udf9b',
	  'convenience_store':'\ud83c\udfea',
	  'cookie':'\ud83c\udf6a',
	  'cool':'\ud83c\udd92',
	  'policeman':'\ud83d\udc6e',
	  'copyright':'\u00a9\ufe0f',
	  'corn':'\ud83c\udf3d',
	  'couch_and_lamp':'\ud83d\udecb',
	  'couple':'\ud83d\udc6b',
	  'couple_with_heart_woman_man':'\ud83d\udc91',
	  'couple_with_heart_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc68',
	  'couple_with_heart_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc69',
	  'couplekiss_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc68',
	  'couplekiss_man_woman':'\ud83d\udc8f',
	  'couplekiss_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc69',
	  'cow':'\ud83d\udc2e',
	  'cow2':'\ud83d\udc04',
	  'cowboy_hat_face':'\ud83e\udd20',
	  'crab':'\ud83e\udd80',
	  'crayon':'\ud83d\udd8d',
	  'credit_card':'\ud83d\udcb3',
	  'crescent_moon':'\ud83c\udf19',
	  'cricket':'\ud83c\udfcf',
	  'crocodile':'\ud83d\udc0a',
	  'croissant':'\ud83e\udd50',
	  'crossed_fingers':'\ud83e\udd1e',
	  'crossed_flags':'\ud83c\udf8c',
	  'crossed_swords':'\u2694\ufe0f',
	  'crown':'\ud83d\udc51',
	  'cry':'\ud83d\ude22',
	  'crying_cat_face':'\ud83d\ude3f',
	  'crystal_ball':'\ud83d\udd2e',
	  'cucumber':'\ud83e\udd52',
	  'cupid':'\ud83d\udc98',
	  'curly_loop':'\u27b0',
	  'currency_exchange':'\ud83d\udcb1',
	  'curry':'\ud83c\udf5b',
	  'custard':'\ud83c\udf6e',
	  'customs':'\ud83d\udec3',
	  'cyclone':'\ud83c\udf00',
	  'dagger':'\ud83d\udde1',
	  'dancer':'\ud83d\udc83',
	  'dancing_women':'\ud83d\udc6f',
	  'dancing_men':'\ud83d\udc6f&zwj;\u2642\ufe0f',
	  'dango':'\ud83c\udf61',
	  'dark_sunglasses':'\ud83d\udd76',
	  'dart':'\ud83c\udfaf',
	  'dash':'\ud83d\udca8',
	  'date':'\ud83d\udcc5',
	  'deciduous_tree':'\ud83c\udf33',
	  'deer':'\ud83e\udd8c',
	  'department_store':'\ud83c\udfec',
	  'derelict_house':'\ud83c\udfda',
	  'desert':'\ud83c\udfdc',
	  'desert_island':'\ud83c\udfdd',
	  'desktop_computer':'\ud83d\udda5',
	  'male_detective':'\ud83d\udd75\ufe0f',
	  'diamond_shape_with_a_dot_inside':'\ud83d\udca0',
	  'diamonds':'\u2666\ufe0f',
	  'disappointed':'\ud83d\ude1e',
	  'disappointed_relieved':'\ud83d\ude25',
	  'dizzy':'\ud83d\udcab',
	  'dizzy_face':'\ud83d\ude35',
	  'do_not_litter':'\ud83d\udeaf',
	  'dog':'\ud83d\udc36',
	  'dog2':'\ud83d\udc15',
	  'dollar':'\ud83d\udcb5',
	  'dolls':'\ud83c\udf8e',
	  'dolphin':'\ud83d\udc2c',
	  'door':'\ud83d\udeaa',
	  'doughnut':'\ud83c\udf69',
	  'dove':'\ud83d\udd4a',
	  'dragon':'\ud83d\udc09',
	  'dragon_face':'\ud83d\udc32',
	  'dress':'\ud83d\udc57',
	  'dromedary_camel':'\ud83d\udc2a',
	  'drooling_face':'\ud83e\udd24',
	  'droplet':'\ud83d\udca7',
	  'drum':'\ud83e\udd41',
	  'duck':'\ud83e\udd86',
	  'dvd':'\ud83d\udcc0',
	  'e-mail':'\ud83d\udce7',
	  'eagle':'\ud83e\udd85',
	  'ear':'\ud83d\udc42',
	  'ear_of_rice':'\ud83c\udf3e',
	  'earth_africa':'\ud83c\udf0d',
	  'earth_americas':'\ud83c\udf0e',
	  'earth_asia':'\ud83c\udf0f',
	  'egg':'\ud83e\udd5a',
	  'eggplant':'\ud83c\udf46',
	  'eight_pointed_black_star':'\u2734\ufe0f',
	  'eight_spoked_asterisk':'\u2733\ufe0f',
	  'electric_plug':'\ud83d\udd0c',
	  'elephant':'\ud83d\udc18',
	  'email':'\u2709\ufe0f',
	  'end':'\ud83d\udd1a',
	  'envelope_with_arrow':'\ud83d\udce9',
	  'euro':'\ud83d\udcb6',
	  'european_castle':'\ud83c\udff0',
	  'european_post_office':'\ud83c\udfe4',
	  'evergreen_tree':'\ud83c\udf32',
	  'exclamation':'\u2757\ufe0f',
	  'expressionless':'\ud83d\ude11',
	  'eye':'\ud83d\udc41',
	  'eye_speech_bubble':'\ud83d\udc41&zwj;\ud83d\udde8',
	  'eyeglasses':'\ud83d\udc53',
	  'eyes':'\ud83d\udc40',
	  'face_with_head_bandage':'\ud83e\udd15',
	  'face_with_thermometer':'\ud83e\udd12',
	  'fist_oncoming':'\ud83d\udc4a',
	  'factory':'\ud83c\udfed',
	  'fallen_leaf':'\ud83c\udf42',
	  'family_man_woman_boy':'\ud83d\udc6a',
	  'family_man_boy':'\ud83d\udc68&zwj;\ud83d\udc66',
	  'family_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_girl':'\ud83d\udc68&zwj;\ud83d\udc67',
	  'family_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_man_man_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66',
	  'family_man_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_man_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67',
	  'family_man_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_man_woman_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_man_woman_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_man_woman_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_man_woman_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc66',
	  'family_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'family_woman_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66',
	  'family_woman_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
	  'family_woman_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
	  'family_woman_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
	  'family_woman_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
	  'fast_forward':'\u23e9',
	  'fax':'\ud83d\udce0',
	  'fearful':'\ud83d\ude28',
	  'feet':'\ud83d\udc3e',
	  'female_detective':'\ud83d\udd75\ufe0f&zwj;\u2640\ufe0f',
	  'ferris_wheel':'\ud83c\udfa1',
	  'ferry':'\u26f4',
	  'field_hockey':'\ud83c\udfd1',
	  'file_cabinet':'\ud83d\uddc4',
	  'file_folder':'\ud83d\udcc1',
	  'film_projector':'\ud83d\udcfd',
	  'film_strip':'\ud83c\udf9e',
	  'fire':'\ud83d\udd25',
	  'fire_engine':'\ud83d\ude92',
	  'fireworks':'\ud83c\udf86',
	  'first_quarter_moon':'\ud83c\udf13',
	  'first_quarter_moon_with_face':'\ud83c\udf1b',
	  'fish':'\ud83d\udc1f',
	  'fish_cake':'\ud83c\udf65',
	  'fishing_pole_and_fish':'\ud83c\udfa3',
	  'fist_raised':'\u270a',
	  'fist_left':'\ud83e\udd1b',
	  'fist_right':'\ud83e\udd1c',
	  'flags':'\ud83c\udf8f',
	  'flashlight':'\ud83d\udd26',
	  'fleur_de_lis':'\u269c\ufe0f',
	  'flight_arrival':'\ud83d\udeec',
	  'flight_departure':'\ud83d\udeeb',
	  'floppy_disk':'\ud83d\udcbe',
	  'flower_playing_cards':'\ud83c\udfb4',
	  'flushed':'\ud83d\ude33',
	  'fog':'\ud83c\udf2b',
	  'foggy':'\ud83c\udf01',
	  'football':'\ud83c\udfc8',
	  'footprints':'\ud83d\udc63',
	  'fork_and_knife':'\ud83c\udf74',
	  'fountain':'\u26f2\ufe0f',
	  'fountain_pen':'\ud83d\udd8b',
	  'four_leaf_clover':'\ud83c\udf40',
	  'fox_face':'\ud83e\udd8a',
	  'framed_picture':'\ud83d\uddbc',
	  'free':'\ud83c\udd93',
	  'fried_egg':'\ud83c\udf73',
	  'fried_shrimp':'\ud83c\udf64',
	  'fries':'\ud83c\udf5f',
	  'frog':'\ud83d\udc38',
	  'frowning':'\ud83d\ude26',
	  'frowning_face':'\u2639\ufe0f',
	  'frowning_man':'\ud83d\ude4d&zwj;\u2642\ufe0f',
	  'frowning_woman':'\ud83d\ude4d',
	  'middle_finger':'\ud83d\udd95',
	  'fuelpump':'\u26fd\ufe0f',
	  'full_moon':'\ud83c\udf15',
	  'full_moon_with_face':'\ud83c\udf1d',
	  'funeral_urn':'\u26b1\ufe0f',
	  'game_die':'\ud83c\udfb2',
	  'gear':'\u2699\ufe0f',
	  'gem':'\ud83d\udc8e',
	  'gemini':'\u264a\ufe0f',
	  'ghost':'\ud83d\udc7b',
	  'gift':'\ud83c\udf81',
	  'gift_heart':'\ud83d\udc9d',
	  'girl':'\ud83d\udc67',
	  'globe_with_meridians':'\ud83c\udf10',
	  'goal_net':'\ud83e\udd45',
	  'goat':'\ud83d\udc10',
	  'golf':'\u26f3\ufe0f',
	  'golfing_man':'\ud83c\udfcc\ufe0f',
	  'golfing_woman':'\ud83c\udfcc\ufe0f&zwj;\u2640\ufe0f',
	  'gorilla':'\ud83e\udd8d',
	  'grapes':'\ud83c\udf47',
	  'green_apple':'\ud83c\udf4f',
	  'green_book':'\ud83d\udcd7',
	  'green_heart':'\ud83d\udc9a',
	  'green_salad':'\ud83e\udd57',
	  'grey_exclamation':'\u2755',
	  'grey_question':'\u2754',
	  'grimacing':'\ud83d\ude2c',
	  'grin':'\ud83d\ude01',
	  'grinning':'\ud83d\ude00',
	  'guardsman':'\ud83d\udc82',
	  'guardswoman':'\ud83d\udc82&zwj;\u2640\ufe0f',
	  'guitar':'\ud83c\udfb8',
	  'gun':'\ud83d\udd2b',
	  'haircut_woman':'\ud83d\udc87',
	  'haircut_man':'\ud83d\udc87&zwj;\u2642\ufe0f',
	  'hamburger':'\ud83c\udf54',
	  'hammer':'\ud83d\udd28',
	  'hammer_and_pick':'\u2692',
	  'hammer_and_wrench':'\ud83d\udee0',
	  'hamster':'\ud83d\udc39',
	  'hand':'\u270b',
	  'handbag':'\ud83d\udc5c',
	  'handshake':'\ud83e\udd1d',
	  'hankey':'\ud83d\udca9',
	  'hatched_chick':'\ud83d\udc25',
	  'hatching_chick':'\ud83d\udc23',
	  'headphones':'\ud83c\udfa7',
	  'hear_no_evil':'\ud83d\ude49',
	  'heart':'\u2764\ufe0f',
	  'heart_decoration':'\ud83d\udc9f',
	  'heart_eyes':'\ud83d\ude0d',
	  'heart_eyes_cat':'\ud83d\ude3b',
	  'heartbeat':'\ud83d\udc93',
	  'heartpulse':'\ud83d\udc97',
	  'hearts':'\u2665\ufe0f',
	  'heavy_check_mark':'\u2714\ufe0f',
	  'heavy_division_sign':'\u2797',
	  'heavy_dollar_sign':'\ud83d\udcb2',
	  'heavy_heart_exclamation':'\u2763\ufe0f',
	  'heavy_minus_sign':'\u2796',
	  'heavy_multiplication_x':'\u2716\ufe0f',
	  'heavy_plus_sign':'\u2795',
	  'helicopter':'\ud83d\ude81',
	  'herb':'\ud83c\udf3f',
	  'hibiscus':'\ud83c\udf3a',
	  'high_brightness':'\ud83d\udd06',
	  'high_heel':'\ud83d\udc60',
	  'hocho':'\ud83d\udd2a',
	  'hole':'\ud83d\udd73',
	  'honey_pot':'\ud83c\udf6f',
	  'horse':'\ud83d\udc34',
	  'horse_racing':'\ud83c\udfc7',
	  'hospital':'\ud83c\udfe5',
	  'hot_pepper':'\ud83c\udf36',
	  'hotdog':'\ud83c\udf2d',
	  'hotel':'\ud83c\udfe8',
	  'hotsprings':'\u2668\ufe0f',
	  'hourglass':'\u231b\ufe0f',
	  'hourglass_flowing_sand':'\u23f3',
	  'house':'\ud83c\udfe0',
	  'house_with_garden':'\ud83c\udfe1',
	  'houses':'\ud83c\udfd8',
	  'hugs':'\ud83e\udd17',
	  'hushed':'\ud83d\ude2f',
	  'ice_cream':'\ud83c\udf68',
	  'ice_hockey':'\ud83c\udfd2',
	  'ice_skate':'\u26f8',
	  'icecream':'\ud83c\udf66',
	  'id':'\ud83c\udd94',
	  'ideograph_advantage':'\ud83c\ude50',
	  'imp':'\ud83d\udc7f',
	  'inbox_tray':'\ud83d\udce5',
	  'incoming_envelope':'\ud83d\udce8',
	  'tipping_hand_woman':'\ud83d\udc81',
	  'information_source':'\u2139\ufe0f',
	  'innocent':'\ud83d\ude07',
	  'interrobang':'\u2049\ufe0f',
	  'iphone':'\ud83d\udcf1',
	  'izakaya_lantern':'\ud83c\udfee',
	  'jack_o_lantern':'\ud83c\udf83',
	  'japan':'\ud83d\uddfe',
	  'japanese_castle':'\ud83c\udfef',
	  'japanese_goblin':'\ud83d\udc7a',
	  'japanese_ogre':'\ud83d\udc79',
	  'jeans':'\ud83d\udc56',
	  'joy':'\ud83d\ude02',
	  'joy_cat':'\ud83d\ude39',
	  'joystick':'\ud83d\udd79',
	  'kaaba':'\ud83d\udd4b',
	  'key':'\ud83d\udd11',
	  'keyboard':'\u2328\ufe0f',
	  'keycap_ten':'\ud83d\udd1f',
	  'kick_scooter':'\ud83d\udef4',
	  'kimono':'\ud83d\udc58',
	  'kiss':'\ud83d\udc8b',
	  'kissing':'\ud83d\ude17',
	  'kissing_cat':'\ud83d\ude3d',
	  'kissing_closed_eyes':'\ud83d\ude1a',
	  'kissing_heart':'\ud83d\ude18',
	  'kissing_smiling_eyes':'\ud83d\ude19',
	  'kiwi_fruit':'\ud83e\udd5d',
	  'koala':'\ud83d\udc28',
	  'koko':'\ud83c\ude01',
	  'label':'\ud83c\udff7',
	  'large_blue_circle':'\ud83d\udd35',
	  'large_blue_diamond':'\ud83d\udd37',
	  'large_orange_diamond':'\ud83d\udd36',
	  'last_quarter_moon':'\ud83c\udf17',
	  'last_quarter_moon_with_face':'\ud83c\udf1c',
	  'latin_cross':'\u271d\ufe0f',
	  'laughing':'\ud83d\ude06',
	  'leaves':'\ud83c\udf43',
	  'ledger':'\ud83d\udcd2',
	  'left_luggage':'\ud83d\udec5',
	  'left_right_arrow':'\u2194\ufe0f',
	  'leftwards_arrow_with_hook':'\u21a9\ufe0f',
	  'lemon':'\ud83c\udf4b',
	  'leo':'\u264c\ufe0f',
	  'leopard':'\ud83d\udc06',
	  'level_slider':'\ud83c\udf9a',
	  'libra':'\u264e\ufe0f',
	  'light_rail':'\ud83d\ude88',
	  'link':'\ud83d\udd17',
	  'lion':'\ud83e\udd81',
	  'lips':'\ud83d\udc44',
	  'lipstick':'\ud83d\udc84',
	  'lizard':'\ud83e\udd8e',
	  'lock':'\ud83d\udd12',
	  'lock_with_ink_pen':'\ud83d\udd0f',
	  'lollipop':'\ud83c\udf6d',
	  'loop':'\u27bf',
	  'loud_sound':'\ud83d\udd0a',
	  'loudspeaker':'\ud83d\udce2',
	  'love_hotel':'\ud83c\udfe9',
	  'love_letter':'\ud83d\udc8c',
	  'low_brightness':'\ud83d\udd05',
	  'lying_face':'\ud83e\udd25',
	  'm':'\u24c2\ufe0f',
	  'mag':'\ud83d\udd0d',
	  'mag_right':'\ud83d\udd0e',
	  'mahjong':'\ud83c\udc04\ufe0f',
	  'mailbox':'\ud83d\udceb',
	  'mailbox_closed':'\ud83d\udcea',
	  'mailbox_with_mail':'\ud83d\udcec',
	  'mailbox_with_no_mail':'\ud83d\udced',
	  'man':'\ud83d\udc68',
	  'man_artist':'\ud83d\udc68&zwj;\ud83c\udfa8',
	  'man_astronaut':'\ud83d\udc68&zwj;\ud83d\ude80',
	  'man_cartwheeling':'\ud83e\udd38&zwj;\u2642\ufe0f',
	  'man_cook':'\ud83d\udc68&zwj;\ud83c\udf73',
	  'man_dancing':'\ud83d\udd7a',
	  'man_facepalming':'\ud83e\udd26&zwj;\u2642\ufe0f',
	  'man_factory_worker':'\ud83d\udc68&zwj;\ud83c\udfed',
	  'man_farmer':'\ud83d\udc68&zwj;\ud83c\udf3e',
	  'man_firefighter':'\ud83d\udc68&zwj;\ud83d\ude92',
	  'man_health_worker':'\ud83d\udc68&zwj;\u2695\ufe0f',
	  'man_in_tuxedo':'\ud83e\udd35',
	  'man_judge':'\ud83d\udc68&zwj;\u2696\ufe0f',
	  'man_juggling':'\ud83e\udd39&zwj;\u2642\ufe0f',
	  'man_mechanic':'\ud83d\udc68&zwj;\ud83d\udd27',
	  'man_office_worker':'\ud83d\udc68&zwj;\ud83d\udcbc',
	  'man_pilot':'\ud83d\udc68&zwj;\u2708\ufe0f',
	  'man_playing_handball':'\ud83e\udd3e&zwj;\u2642\ufe0f',
	  'man_playing_water_polo':'\ud83e\udd3d&zwj;\u2642\ufe0f',
	  'man_scientist':'\ud83d\udc68&zwj;\ud83d\udd2c',
	  'man_shrugging':'\ud83e\udd37&zwj;\u2642\ufe0f',
	  'man_singer':'\ud83d\udc68&zwj;\ud83c\udfa4',
	  'man_student':'\ud83d\udc68&zwj;\ud83c\udf93',
	  'man_teacher':'\ud83d\udc68&zwj;\ud83c\udfeb',
	  'man_technologist':'\ud83d\udc68&zwj;\ud83d\udcbb',
	  'man_with_gua_pi_mao':'\ud83d\udc72',
	  'man_with_turban':'\ud83d\udc73',
	  'tangerine':'\ud83c\udf4a',
	  'mans_shoe':'\ud83d\udc5e',
	  'mantelpiece_clock':'\ud83d\udd70',
	  'maple_leaf':'\ud83c\udf41',
	  'martial_arts_uniform':'\ud83e\udd4b',
	  'mask':'\ud83d\ude37',
	  'massage_woman':'\ud83d\udc86',
	  'massage_man':'\ud83d\udc86&zwj;\u2642\ufe0f',
	  'meat_on_bone':'\ud83c\udf56',
	  'medal_military':'\ud83c\udf96',
	  'medal_sports':'\ud83c\udfc5',
	  'mega':'\ud83d\udce3',
	  'melon':'\ud83c\udf48',
	  'memo':'\ud83d\udcdd',
	  'men_wrestling':'\ud83e\udd3c&zwj;\u2642\ufe0f',
	  'menorah':'\ud83d\udd4e',
	  'mens':'\ud83d\udeb9',
	  'metal':'\ud83e\udd18',
	  'metro':'\ud83d\ude87',
	  'microphone':'\ud83c\udfa4',
	  'microscope':'\ud83d\udd2c',
	  'milk_glass':'\ud83e\udd5b',
	  'milky_way':'\ud83c\udf0c',
	  'minibus':'\ud83d\ude90',
	  'minidisc':'\ud83d\udcbd',
	  'mobile_phone_off':'\ud83d\udcf4',
	  'money_mouth_face':'\ud83e\udd11',
	  'money_with_wings':'\ud83d\udcb8',
	  'moneybag':'\ud83d\udcb0',
	  'monkey':'\ud83d\udc12',
	  'monkey_face':'\ud83d\udc35',
	  'monorail':'\ud83d\ude9d',
	  'moon':'\ud83c\udf14',
	  'mortar_board':'\ud83c\udf93',
	  'mosque':'\ud83d\udd4c',
	  'motor_boat':'\ud83d\udee5',
	  'motor_scooter':'\ud83d\udef5',
	  'motorcycle':'\ud83c\udfcd',
	  'motorway':'\ud83d\udee3',
	  'mount_fuji':'\ud83d\uddfb',
	  'mountain':'\u26f0',
	  'mountain_biking_man':'\ud83d\udeb5',
	  'mountain_biking_woman':'\ud83d\udeb5&zwj;\u2640\ufe0f',
	  'mountain_cableway':'\ud83d\udea0',
	  'mountain_railway':'\ud83d\ude9e',
	  'mountain_snow':'\ud83c\udfd4',
	  'mouse':'\ud83d\udc2d',
	  'mouse2':'\ud83d\udc01',
	  'movie_camera':'\ud83c\udfa5',
	  'moyai':'\ud83d\uddff',
	  'mrs_claus':'\ud83e\udd36',
	  'muscle':'\ud83d\udcaa',
	  'mushroom':'\ud83c\udf44',
	  'musical_keyboard':'\ud83c\udfb9',
	  'musical_note':'\ud83c\udfb5',
	  'musical_score':'\ud83c\udfbc',
	  'mute':'\ud83d\udd07',
	  'nail_care':'\ud83d\udc85',
	  'name_badge':'\ud83d\udcdb',
	  'national_park':'\ud83c\udfde',
	  'nauseated_face':'\ud83e\udd22',
	  'necktie':'\ud83d\udc54',
	  'negative_squared_cross_mark':'\u274e',
	  'nerd_face':'\ud83e\udd13',
	  'neutral_face':'\ud83d\ude10',
	  'new':'\ud83c\udd95',
	  'new_moon':'\ud83c\udf11',
	  'new_moon_with_face':'\ud83c\udf1a',
	  'newspaper':'\ud83d\udcf0',
	  'newspaper_roll':'\ud83d\uddde',
	  'next_track_button':'\u23ed',
	  'ng':'\ud83c\udd96',
	  'no_good_man':'\ud83d\ude45&zwj;\u2642\ufe0f',
	  'no_good_woman':'\ud83d\ude45',
	  'night_with_stars':'\ud83c\udf03',
	  'no_bell':'\ud83d\udd15',
	  'no_bicycles':'\ud83d\udeb3',
	  'no_entry':'\u26d4\ufe0f',
	  'no_entry_sign':'\ud83d\udeab',
	  'no_mobile_phones':'\ud83d\udcf5',
	  'no_mouth':'\ud83d\ude36',
	  'no_pedestrians':'\ud83d\udeb7',
	  'no_smoking':'\ud83d\udead',
	  'non-potable_water':'\ud83d\udeb1',
	  'nose':'\ud83d\udc43',
	  'notebook':'\ud83d\udcd3',
	  'notebook_with_decorative_cover':'\ud83d\udcd4',
	  'notes':'\ud83c\udfb6',
	  'nut_and_bolt':'\ud83d\udd29',
	  'o':'\u2b55\ufe0f',
	  'o2':'\ud83c\udd7e\ufe0f',
	  'ocean':'\ud83c\udf0a',
	  'octopus':'\ud83d\udc19',
	  'oden':'\ud83c\udf62',
	  'office':'\ud83c\udfe2',
	  'oil_drum':'\ud83d\udee2',
	  'ok':'\ud83c\udd97',
	  'ok_hand':'\ud83d\udc4c',
	  'ok_man':'\ud83d\ude46&zwj;\u2642\ufe0f',
	  'ok_woman':'\ud83d\ude46',
	  'old_key':'\ud83d\udddd',
	  'older_man':'\ud83d\udc74',
	  'older_woman':'\ud83d\udc75',
	  'om':'\ud83d\udd49',
	  'on':'\ud83d\udd1b',
	  'oncoming_automobile':'\ud83d\ude98',
	  'oncoming_bus':'\ud83d\ude8d',
	  'oncoming_police_car':'\ud83d\ude94',
	  'oncoming_taxi':'\ud83d\ude96',
	  'open_file_folder':'\ud83d\udcc2',
	  'open_hands':'\ud83d\udc50',
	  'open_mouth':'\ud83d\ude2e',
	  'open_umbrella':'\u2602\ufe0f',
	  'ophiuchus':'\u26ce',
	  'orange_book':'\ud83d\udcd9',
	  'orthodox_cross':'\u2626\ufe0f',
	  'outbox_tray':'\ud83d\udce4',
	  'owl':'\ud83e\udd89',
	  'ox':'\ud83d\udc02',
	  'package':'\ud83d\udce6',
	  'page_facing_up':'\ud83d\udcc4',
	  'page_with_curl':'\ud83d\udcc3',
	  'pager':'\ud83d\udcdf',
	  'paintbrush':'\ud83d\udd8c',
	  'palm_tree':'\ud83c\udf34',
	  'pancakes':'\ud83e\udd5e',
	  'panda_face':'\ud83d\udc3c',
	  'paperclip':'\ud83d\udcce',
	  'paperclips':'\ud83d\udd87',
	  'parasol_on_ground':'\u26f1',
	  'parking':'\ud83c\udd7f\ufe0f',
	  'part_alternation_mark':'\u303d\ufe0f',
	  'partly_sunny':'\u26c5\ufe0f',
	  'passenger_ship':'\ud83d\udef3',
	  'passport_control':'\ud83d\udec2',
	  'pause_button':'\u23f8',
	  'peace_symbol':'\u262e\ufe0f',
	  'peach':'\ud83c\udf51',
	  'peanuts':'\ud83e\udd5c',
	  'pear':'\ud83c\udf50',
	  'pen':'\ud83d\udd8a',
	  'pencil2':'\u270f\ufe0f',
	  'penguin':'\ud83d\udc27',
	  'pensive':'\ud83d\ude14',
	  'performing_arts':'\ud83c\udfad',
	  'persevere':'\ud83d\ude23',
	  'person_fencing':'\ud83e\udd3a',
	  'pouting_woman':'\ud83d\ude4e',
	  'phone':'\u260e\ufe0f',
	  'pick':'\u26cf',
	  'pig':'\ud83d\udc37',
	  'pig2':'\ud83d\udc16',
	  'pig_nose':'\ud83d\udc3d',
	  'pill':'\ud83d\udc8a',
	  'pineapple':'\ud83c\udf4d',
	  'ping_pong':'\ud83c\udfd3',
	  'pisces':'\u2653\ufe0f',
	  'pizza':'\ud83c\udf55',
	  'place_of_worship':'\ud83d\uded0',
	  'plate_with_cutlery':'\ud83c\udf7d',
	  'play_or_pause_button':'\u23ef',
	  'point_down':'\ud83d\udc47',
	  'point_left':'\ud83d\udc48',
	  'point_right':'\ud83d\udc49',
	  'point_up':'\u261d\ufe0f',
	  'point_up_2':'\ud83d\udc46',
	  'police_car':'\ud83d\ude93',
	  'policewoman':'\ud83d\udc6e&zwj;\u2640\ufe0f',
	  'poodle':'\ud83d\udc29',
	  'popcorn':'\ud83c\udf7f',
	  'post_office':'\ud83c\udfe3',
	  'postal_horn':'\ud83d\udcef',
	  'postbox':'\ud83d\udcee',
	  'potable_water':'\ud83d\udeb0',
	  'potato':'\ud83e\udd54',
	  'pouch':'\ud83d\udc5d',
	  'poultry_leg':'\ud83c\udf57',
	  'pound':'\ud83d\udcb7',
	  'rage':'\ud83d\ude21',
	  'pouting_cat':'\ud83d\ude3e',
	  'pouting_man':'\ud83d\ude4e&zwj;\u2642\ufe0f',
	  'pray':'\ud83d\ude4f',
	  'prayer_beads':'\ud83d\udcff',
	  'pregnant_woman':'\ud83e\udd30',
	  'previous_track_button':'\u23ee',
	  'prince':'\ud83e\udd34',
	  'princess':'\ud83d\udc78',
	  'printer':'\ud83d\udda8',
	  'purple_heart':'\ud83d\udc9c',
	  'purse':'\ud83d\udc5b',
	  'pushpin':'\ud83d\udccc',
	  'put_litter_in_its_place':'\ud83d\udeae',
	  'question':'\u2753',
	  'rabbit':'\ud83d\udc30',
	  'rabbit2':'\ud83d\udc07',
	  'racehorse':'\ud83d\udc0e',
	  'racing_car':'\ud83c\udfce',
	  'radio':'\ud83d\udcfb',
	  'radio_button':'\ud83d\udd18',
	  'radioactive':'\u2622\ufe0f',
	  'railway_car':'\ud83d\ude83',
	  'railway_track':'\ud83d\udee4',
	  'rainbow':'\ud83c\udf08',
	  'rainbow_flag':'\ud83c\udff3\ufe0f&zwj;\ud83c\udf08',
	  'raised_back_of_hand':'\ud83e\udd1a',
	  'raised_hand_with_fingers_splayed':'\ud83d\udd90',
	  'raised_hands':'\ud83d\ude4c',
	  'raising_hand_woman':'\ud83d\ude4b',
	  'raising_hand_man':'\ud83d\ude4b&zwj;\u2642\ufe0f',
	  'ram':'\ud83d\udc0f',
	  'ramen':'\ud83c\udf5c',
	  'rat':'\ud83d\udc00',
	  'record_button':'\u23fa',
	  'recycle':'\u267b\ufe0f',
	  'red_circle':'\ud83d\udd34',
	  'registered':'\u00ae\ufe0f',
	  'relaxed':'\u263a\ufe0f',
	  'relieved':'\ud83d\ude0c',
	  'reminder_ribbon':'\ud83c\udf97',
	  'repeat':'\ud83d\udd01',
	  'repeat_one':'\ud83d\udd02',
	  'rescue_worker_helmet':'\u26d1',
	  'restroom':'\ud83d\udebb',
	  'revolving_hearts':'\ud83d\udc9e',
	  'rewind':'\u23ea',
	  'rhinoceros':'\ud83e\udd8f',
	  'ribbon':'\ud83c\udf80',
	  'rice':'\ud83c\udf5a',
	  'rice_ball':'\ud83c\udf59',
	  'rice_cracker':'\ud83c\udf58',
	  'rice_scene':'\ud83c\udf91',
	  'right_anger_bubble':'\ud83d\uddef',
	  'ring':'\ud83d\udc8d',
	  'robot':'\ud83e\udd16',
	  'rocket':'\ud83d\ude80',
	  'rofl':'\ud83e\udd23',
	  'roll_eyes':'\ud83d\ude44',
	  'roller_coaster':'\ud83c\udfa2',
	  'rooster':'\ud83d\udc13',
	  'rose':'\ud83c\udf39',
	  'rosette':'\ud83c\udff5',
	  'rotating_light':'\ud83d\udea8',
	  'round_pushpin':'\ud83d\udccd',
	  'rowing_man':'\ud83d\udea3',
	  'rowing_woman':'\ud83d\udea3&zwj;\u2640\ufe0f',
	  'rugby_football':'\ud83c\udfc9',
	  'running_man':'\ud83c\udfc3',
	  'running_shirt_with_sash':'\ud83c\udfbd',
	  'running_woman':'\ud83c\udfc3&zwj;\u2640\ufe0f',
	  'sa':'\ud83c\ude02\ufe0f',
	  'sagittarius':'\u2650\ufe0f',
	  'sake':'\ud83c\udf76',
	  'sandal':'\ud83d\udc61',
	  'santa':'\ud83c\udf85',
	  'satellite':'\ud83d\udce1',
	  'saxophone':'\ud83c\udfb7',
	  'school':'\ud83c\udfeb',
	  'school_satchel':'\ud83c\udf92',
	  'scissors':'\u2702\ufe0f',
	  'scorpion':'\ud83e\udd82',
	  'scorpius':'\u264f\ufe0f',
	  'scream':'\ud83d\ude31',
	  'scream_cat':'\ud83d\ude40',
	  'scroll':'\ud83d\udcdc',
	  'seat':'\ud83d\udcba',
	  'secret':'\u3299\ufe0f',
	  'see_no_evil':'\ud83d\ude48',
	  'seedling':'\ud83c\udf31',
	  'selfie':'\ud83e\udd33',
	  'shallow_pan_of_food':'\ud83e\udd58',
	  'shamrock':'\u2618\ufe0f',
	  'shark':'\ud83e\udd88',
	  'shaved_ice':'\ud83c\udf67',
	  'sheep':'\ud83d\udc11',
	  'shell':'\ud83d\udc1a',
	  'shield':'\ud83d\udee1',
	  'shinto_shrine':'\u26e9',
	  'ship':'\ud83d\udea2',
	  'shirt':'\ud83d\udc55',
	  'shopping':'\ud83d\udecd',
	  'shopping_cart':'\ud83d\uded2',
	  'shower':'\ud83d\udebf',
	  'shrimp':'\ud83e\udd90',
	  'signal_strength':'\ud83d\udcf6',
	  'six_pointed_star':'\ud83d\udd2f',
	  'ski':'\ud83c\udfbf',
	  'skier':'\u26f7',
	  'skull':'\ud83d\udc80',
	  'skull_and_crossbones':'\u2620\ufe0f',
	  'sleeping':'\ud83d\ude34',
	  'sleeping_bed':'\ud83d\udecc',
	  'sleepy':'\ud83d\ude2a',
	  'slightly_frowning_face':'\ud83d\ude41',
	  'slightly_smiling_face':'\ud83d\ude42',
	  'slot_machine':'\ud83c\udfb0',
	  'small_airplane':'\ud83d\udee9',
	  'small_blue_diamond':'\ud83d\udd39',
	  'small_orange_diamond':'\ud83d\udd38',
	  'small_red_triangle':'\ud83d\udd3a',
	  'small_red_triangle_down':'\ud83d\udd3b',
	  'smile':'\ud83d\ude04',
	  'smile_cat':'\ud83d\ude38',
	  'smiley':'\ud83d\ude03',
	  'smiley_cat':'\ud83d\ude3a',
	  'smiling_imp':'\ud83d\ude08',
	  'smirk':'\ud83d\ude0f',
	  'smirk_cat':'\ud83d\ude3c',
	  'smoking':'\ud83d\udeac',
	  'snail':'\ud83d\udc0c',
	  'snake':'\ud83d\udc0d',
	  'sneezing_face':'\ud83e\udd27',
	  'snowboarder':'\ud83c\udfc2',
	  'snowflake':'\u2744\ufe0f',
	  'snowman':'\u26c4\ufe0f',
	  'snowman_with_snow':'\u2603\ufe0f',
	  'sob':'\ud83d\ude2d',
	  'soccer':'\u26bd\ufe0f',
	  'soon':'\ud83d\udd1c',
	  'sos':'\ud83c\udd98',
	  'sound':'\ud83d\udd09',
	  'space_invader':'\ud83d\udc7e',
	  'spades':'\u2660\ufe0f',
	  'spaghetti':'\ud83c\udf5d',
	  'sparkle':'\u2747\ufe0f',
	  'sparkler':'\ud83c\udf87',
	  'sparkles':'\u2728',
	  'sparkling_heart':'\ud83d\udc96',
	  'speak_no_evil':'\ud83d\ude4a',
	  'speaker':'\ud83d\udd08',
	  'speaking_head':'\ud83d\udde3',
	  'speech_balloon':'\ud83d\udcac',
	  'speedboat':'\ud83d\udea4',
	  'spider':'\ud83d\udd77',
	  'spider_web':'\ud83d\udd78',
	  'spiral_calendar':'\ud83d\uddd3',
	  'spiral_notepad':'\ud83d\uddd2',
	  'spoon':'\ud83e\udd44',
	  'squid':'\ud83e\udd91',
	  'stadium':'\ud83c\udfdf',
	  'star':'\u2b50\ufe0f',
	  'star2':'\ud83c\udf1f',
	  'star_and_crescent':'\u262a\ufe0f',
	  'star_of_david':'\u2721\ufe0f',
	  'stars':'\ud83c\udf20',
	  'station':'\ud83d\ude89',
	  'statue_of_liberty':'\ud83d\uddfd',
	  'steam_locomotive':'\ud83d\ude82',
	  'stew':'\ud83c\udf72',
	  'stop_button':'\u23f9',
	  'stop_sign':'\ud83d\uded1',
	  'stopwatch':'\u23f1',
	  'straight_ruler':'\ud83d\udccf',
	  'strawberry':'\ud83c\udf53',
	  'stuck_out_tongue':'\ud83d\ude1b',
	  'stuck_out_tongue_closed_eyes':'\ud83d\ude1d',
	  'stuck_out_tongue_winking_eye':'\ud83d\ude1c',
	  'studio_microphone':'\ud83c\udf99',
	  'stuffed_flatbread':'\ud83e\udd59',
	  'sun_behind_large_cloud':'\ud83c\udf25',
	  'sun_behind_rain_cloud':'\ud83c\udf26',
	  'sun_behind_small_cloud':'\ud83c\udf24',
	  'sun_with_face':'\ud83c\udf1e',
	  'sunflower':'\ud83c\udf3b',
	  'sunglasses':'\ud83d\ude0e',
	  'sunny':'\u2600\ufe0f',
	  'sunrise':'\ud83c\udf05',
	  'sunrise_over_mountains':'\ud83c\udf04',
	  'surfing_man':'\ud83c\udfc4',
	  'surfing_woman':'\ud83c\udfc4&zwj;\u2640\ufe0f',
	  'sushi':'\ud83c\udf63',
	  'suspension_railway':'\ud83d\ude9f',
	  'sweat':'\ud83d\ude13',
	  'sweat_drops':'\ud83d\udca6',
	  'sweat_smile':'\ud83d\ude05',
	  'sweet_potato':'\ud83c\udf60',
	  'swimming_man':'\ud83c\udfca',
	  'swimming_woman':'\ud83c\udfca&zwj;\u2640\ufe0f',
	  'symbols':'\ud83d\udd23',
	  'synagogue':'\ud83d\udd4d',
	  'syringe':'\ud83d\udc89',
	  'taco':'\ud83c\udf2e',
	  'tada':'\ud83c\udf89',
	  'tanabata_tree':'\ud83c\udf8b',
	  'taurus':'\u2649\ufe0f',
	  'taxi':'\ud83d\ude95',
	  'tea':'\ud83c\udf75',
	  'telephone_receiver':'\ud83d\udcde',
	  'telescope':'\ud83d\udd2d',
	  'tennis':'\ud83c\udfbe',
	  'tent':'\u26fa\ufe0f',
	  'thermometer':'\ud83c\udf21',
	  'thinking':'\ud83e\udd14',
	  'thought_balloon':'\ud83d\udcad',
	  'ticket':'\ud83c\udfab',
	  'tickets':'\ud83c\udf9f',
	  'tiger':'\ud83d\udc2f',
	  'tiger2':'\ud83d\udc05',
	  'timer_clock':'\u23f2',
	  'tipping_hand_man':'\ud83d\udc81&zwj;\u2642\ufe0f',
	  'tired_face':'\ud83d\ude2b',
	  'tm':'\u2122\ufe0f',
	  'toilet':'\ud83d\udebd',
	  'tokyo_tower':'\ud83d\uddfc',
	  'tomato':'\ud83c\udf45',
	  'tongue':'\ud83d\udc45',
	  'top':'\ud83d\udd1d',
	  'tophat':'\ud83c\udfa9',
	  'tornado':'\ud83c\udf2a',
	  'trackball':'\ud83d\uddb2',
	  'tractor':'\ud83d\ude9c',
	  'traffic_light':'\ud83d\udea5',
	  'train':'\ud83d\ude8b',
	  'train2':'\ud83d\ude86',
	  'tram':'\ud83d\ude8a',
	  'triangular_flag_on_post':'\ud83d\udea9',
	  'triangular_ruler':'\ud83d\udcd0',
	  'trident':'\ud83d\udd31',
	  'triumph':'\ud83d\ude24',
	  'trolleybus':'\ud83d\ude8e',
	  'trophy':'\ud83c\udfc6',
	  'tropical_drink':'\ud83c\udf79',
	  'tropical_fish':'\ud83d\udc20',
	  'truck':'\ud83d\ude9a',
	  'trumpet':'\ud83c\udfba',
	  'tulip':'\ud83c\udf37',
	  'tumbler_glass':'\ud83e\udd43',
	  'turkey':'\ud83e\udd83',
	  'turtle':'\ud83d\udc22',
	  'tv':'\ud83d\udcfa',
	  'twisted_rightwards_arrows':'\ud83d\udd00',
	  'two_hearts':'\ud83d\udc95',
	  'two_men_holding_hands':'\ud83d\udc6c',
	  'two_women_holding_hands':'\ud83d\udc6d',
	  'u5272':'\ud83c\ude39',
	  'u5408':'\ud83c\ude34',
	  'u55b6':'\ud83c\ude3a',
	  'u6307':'\ud83c\ude2f\ufe0f',
	  'u6708':'\ud83c\ude37\ufe0f',
	  'u6709':'\ud83c\ude36',
	  'u6e80':'\ud83c\ude35',
	  'u7121':'\ud83c\ude1a\ufe0f',
	  'u7533':'\ud83c\ude38',
	  'u7981':'\ud83c\ude32',
	  'u7a7a':'\ud83c\ude33',
	  'umbrella':'\u2614\ufe0f',
	  'unamused':'\ud83d\ude12',
	  'underage':'\ud83d\udd1e',
	  'unicorn':'\ud83e\udd84',
	  'unlock':'\ud83d\udd13',
	  'up':'\ud83c\udd99',
	  'upside_down_face':'\ud83d\ude43',
	  'v':'\u270c\ufe0f',
	  'vertical_traffic_light':'\ud83d\udea6',
	  'vhs':'\ud83d\udcfc',
	  'vibration_mode':'\ud83d\udcf3',
	  'video_camera':'\ud83d\udcf9',
	  'video_game':'\ud83c\udfae',
	  'violin':'\ud83c\udfbb',
	  'virgo':'\u264d\ufe0f',
	  'volcano':'\ud83c\udf0b',
	  'volleyball':'\ud83c\udfd0',
	  'vs':'\ud83c\udd9a',
	  'vulcan_salute':'\ud83d\udd96',
	  'walking_man':'\ud83d\udeb6',
	  'walking_woman':'\ud83d\udeb6&zwj;\u2640\ufe0f',
	  'waning_crescent_moon':'\ud83c\udf18',
	  'waning_gibbous_moon':'\ud83c\udf16',
	  'warning':'\u26a0\ufe0f',
	  'wastebasket':'\ud83d\uddd1',
	  'watch':'\u231a\ufe0f',
	  'water_buffalo':'\ud83d\udc03',
	  'watermelon':'\ud83c\udf49',
	  'wave':'\ud83d\udc4b',
	  'wavy_dash':'\u3030\ufe0f',
	  'waxing_crescent_moon':'\ud83c\udf12',
	  'wc':'\ud83d\udebe',
	  'weary':'\ud83d\ude29',
	  'wedding':'\ud83d\udc92',
	  'weight_lifting_man':'\ud83c\udfcb\ufe0f',
	  'weight_lifting_woman':'\ud83c\udfcb\ufe0f&zwj;\u2640\ufe0f',
	  'whale':'\ud83d\udc33',
	  'whale2':'\ud83d\udc0b',
	  'wheel_of_dharma':'\u2638\ufe0f',
	  'wheelchair':'\u267f\ufe0f',
	  'white_check_mark':'\u2705',
	  'white_circle':'\u26aa\ufe0f',
	  'white_flag':'\ud83c\udff3\ufe0f',
	  'white_flower':'\ud83d\udcae',
	  'white_large_square':'\u2b1c\ufe0f',
	  'white_medium_small_square':'\u25fd\ufe0f',
	  'white_medium_square':'\u25fb\ufe0f',
	  'white_small_square':'\u25ab\ufe0f',
	  'white_square_button':'\ud83d\udd33',
	  'wilted_flower':'\ud83e\udd40',
	  'wind_chime':'\ud83c\udf90',
	  'wind_face':'\ud83c\udf2c',
	  'wine_glass':'\ud83c\udf77',
	  'wink':'\ud83d\ude09',
	  'wolf':'\ud83d\udc3a',
	  'woman':'\ud83d\udc69',
	  'woman_artist':'\ud83d\udc69&zwj;\ud83c\udfa8',
	  'woman_astronaut':'\ud83d\udc69&zwj;\ud83d\ude80',
	  'woman_cartwheeling':'\ud83e\udd38&zwj;\u2640\ufe0f',
	  'woman_cook':'\ud83d\udc69&zwj;\ud83c\udf73',
	  'woman_facepalming':'\ud83e\udd26&zwj;\u2640\ufe0f',
	  'woman_factory_worker':'\ud83d\udc69&zwj;\ud83c\udfed',
	  'woman_farmer':'\ud83d\udc69&zwj;\ud83c\udf3e',
	  'woman_firefighter':'\ud83d\udc69&zwj;\ud83d\ude92',
	  'woman_health_worker':'\ud83d\udc69&zwj;\u2695\ufe0f',
	  'woman_judge':'\ud83d\udc69&zwj;\u2696\ufe0f',
	  'woman_juggling':'\ud83e\udd39&zwj;\u2640\ufe0f',
	  'woman_mechanic':'\ud83d\udc69&zwj;\ud83d\udd27',
	  'woman_office_worker':'\ud83d\udc69&zwj;\ud83d\udcbc',
	  'woman_pilot':'\ud83d\udc69&zwj;\u2708\ufe0f',
	  'woman_playing_handball':'\ud83e\udd3e&zwj;\u2640\ufe0f',
	  'woman_playing_water_polo':'\ud83e\udd3d&zwj;\u2640\ufe0f',
	  'woman_scientist':'\ud83d\udc69&zwj;\ud83d\udd2c',
	  'woman_shrugging':'\ud83e\udd37&zwj;\u2640\ufe0f',
	  'woman_singer':'\ud83d\udc69&zwj;\ud83c\udfa4',
	  'woman_student':'\ud83d\udc69&zwj;\ud83c\udf93',
	  'woman_teacher':'\ud83d\udc69&zwj;\ud83c\udfeb',
	  'woman_technologist':'\ud83d\udc69&zwj;\ud83d\udcbb',
	  'woman_with_turban':'\ud83d\udc73&zwj;\u2640\ufe0f',
	  'womans_clothes':'\ud83d\udc5a',
	  'womans_hat':'\ud83d\udc52',
	  'women_wrestling':'\ud83e\udd3c&zwj;\u2640\ufe0f',
	  'womens':'\ud83d\udeba',
	  'world_map':'\ud83d\uddfa',
	  'worried':'\ud83d\ude1f',
	  'wrench':'\ud83d\udd27',
	  'writing_hand':'\u270d\ufe0f',
	  'x':'\u274c',
	  'yellow_heart':'\ud83d\udc9b',
	  'yen':'\ud83d\udcb4',
	  'yin_yang':'\u262f\ufe0f',
	  'yum':'\ud83d\ude0b',
	  'zap':'\u26a1\ufe0f',
	  'zipper_mouth_face':'\ud83e\udd10',
	  'zzz':'\ud83d\udca4',

	  /* special emojis :P */
	  'octocat':  '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
	  'showdown': '<span style="font-family: \'Anonymous Pro\', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>'
	};

	/**
	 * Created by Estevao on 31-05-2015.
	 */

	/**
	 * Showdown Converter class
	 * @class
	 * @param {object} [converterOptions]
	 * @returns {Converter}
	 */
	showdown.Converter = function (converterOptions) {

	  var
	      /**
	       * Options used by this converter
	       * @private
	       * @type {{}}
	       */
	      options = {},

	      /**
	       * Language extensions used by this converter
	       * @private
	       * @type {Array}
	       */
	      langExtensions = [],

	      /**
	       * Output modifiers extensions used by this converter
	       * @private
	       * @type {Array}
	       */
	      outputModifiers = [],

	      /**
	       * Event listeners
	       * @private
	       * @type {{}}
	       */
	      listeners = {},

	      /**
	       * The flavor set in this converter
	       */
	      setConvFlavor = setFlavor,

	    /**
	     * Metadata of the document
	     * @type {{parsed: {}, raw: string, format: string}}
	     */
	      metadata = {
	        parsed: {},
	        raw: '',
	        format: ''
	      };

	  _constructor();

	  /**
	   * Converter constructor
	   * @private
	   */
	  function _constructor () {
	    converterOptions = converterOptions || {};

	    for (var gOpt in globalOptions) {
	      if (globalOptions.hasOwnProperty(gOpt)) {
	        options[gOpt] = globalOptions[gOpt];
	      }
	    }

	    // Merge options
	    if (typeof converterOptions === 'object') {
	      for (var opt in converterOptions) {
	        if (converterOptions.hasOwnProperty(opt)) {
	          options[opt] = converterOptions[opt];
	        }
	      }
	    } else {
	      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +
	      ' was passed instead.');
	    }

	    if (options.extensions) {
	      showdown.helper.forEach(options.extensions, _parseExtension);
	    }
	  }

	  /**
	   * Parse extension
	   * @param {*} ext
	   * @param {string} [name='']
	   * @private
	   */
	  function _parseExtension (ext, name) {

	    name = name || null;
	    // If it's a string, the extension was previously loaded
	    if (showdown.helper.isString(ext)) {
	      ext = showdown.helper.stdExtName(ext);
	      name = ext;

	      // LEGACY_SUPPORT CODE
	      if (showdown.extensions[ext]) {
	        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +
	          'Please inform the developer that the extension should be updated!');
	        legacyExtensionLoading(showdown.extensions[ext], ext);
	        return;
	      // END LEGACY SUPPORT CODE

	      } else if (!showdown.helper.isUndefined(extensions[ext])) {
	        ext = extensions[ext];

	      } else {
	        throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
	      }
	    }

	    if (typeof ext === 'function') {
	      ext = ext();
	    }

	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }

	    var validExt = validate(ext, name);
	    if (!validExt.valid) {
	      throw Error(validExt.error);
	    }

	    for (var i = 0; i < ext.length; ++i) {
	      switch (ext[i].type) {

	        case 'lang':
	          langExtensions.push(ext[i]);
	          break;

	        case 'output':
	          outputModifiers.push(ext[i]);
	          break;
	      }
	      if (ext[i].hasOwnProperty('listeners')) {
	        for (var ln in ext[i].listeners) {
	          if (ext[i].listeners.hasOwnProperty(ln)) {
	            listen(ln, ext[i].listeners[ln]);
	          }
	        }
	      }
	    }

	  }

	  /**
	   * LEGACY_SUPPORT
	   * @param {*} ext
	   * @param {string} name
	   */
	  function legacyExtensionLoading (ext, name) {
	    if (typeof ext === 'function') {
	      ext = ext(new showdown.Converter());
	    }
	    if (!showdown.helper.isArray(ext)) {
	      ext = [ext];
	    }
	    var valid = validate(ext, name);

	    if (!valid.valid) {
	      throw Error(valid.error);
	    }

	    for (var i = 0; i < ext.length; ++i) {
	      switch (ext[i].type) {
	        case 'lang':
	          langExtensions.push(ext[i]);
	          break;
	        case 'output':
	          outputModifiers.push(ext[i]);
	          break;
	        default:// should never reach here
	          throw Error('Extension loader error: Type unrecognized!!!');
	      }
	    }
	  }

	  /**
	   * Listen to an event
	   * @param {string} name
	   * @param {function} callback
	   */
	  function listen (name, callback) {
	    if (!showdown.helper.isString(name)) {
	      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');
	    }

	    if (typeof callback !== 'function') {
	      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');
	    }

	    if (!listeners.hasOwnProperty(name)) {
	      listeners[name] = [];
	    }
	    listeners[name].push(callback);
	  }

	  function rTrimInputText (text) {
	    var rsp = text.match(/^\s*/)[0].length,
	        rgx = new RegExp('^\\s{0,' + rsp + '}', 'gm');
	    return text.replace(rgx, '');
	  }

	  /**
	   * Dispatch an event
	   * @private
	   * @param {string} evtName Event name
	   * @param {string} text Text
	   * @param {{}} options Converter Options
	   * @param {{}} globals
	   * @returns {string}
	   */
	  this._dispatch = function dispatch (evtName, text, options, globals) {
	    if (listeners.hasOwnProperty(evtName)) {
	      for (var ei = 0; ei < listeners[evtName].length; ++ei) {
	        var nText = listeners[evtName][ei](evtName, text, this, options, globals);
	        if (nText && typeof nText !== 'undefined') {
	          text = nText;
	        }
	      }
	    }
	    return text;
	  };

	  /**
	   * Listen to an event
	   * @param {string} name
	   * @param {function} callback
	   * @returns {showdown.Converter}
	   */
	  this.listen = function (name, callback) {
	    listen(name, callback);
	    return this;
	  };

	  /**
	   * Converts a markdown string into HTML
	   * @param {string} text
	   * @returns {*}
	   */
	  this.makeHtml = function (text) {
	    //check if text is not falsy
	    if (!text) {
	      return text;
	    }

	    var globals = {
	      gHtmlBlocks:     [],
	      gHtmlMdBlocks:   [],
	      gHtmlSpans:      [],
	      gUrls:           {},
	      gTitles:         {},
	      gDimensions:     {},
	      gListLevel:      0,
	      hashLinkCounts:  {},
	      langExtensions:  langExtensions,
	      outputModifiers: outputModifiers,
	      converter:       this,
	      ghCodeBlocks:    [],
	      metadata: {
	        parsed: {},
	        raw: '',
	        format: ''
	      }
	    };

	    // This lets us use  trema as an escape char to avoid md5 hashes
	    // The choice of character is arbitrary; anything that isn't
	    // magic in Markdown will work.
	    text = text.replace(//g, 'T');

	    // Replace $ with D
	    // RegExp interprets $ as a special character
	    // when it's in a replacement string
	    text = text.replace(/\$/g, 'D');

	    // Standardize line endings
	    text = text.replace(/\r\n/g, '\n'); // DOS to Unix
	    text = text.replace(/\r/g, '\n'); // Mac to Unix

	    // Stardardize line spaces
	    text = text.replace(/\u00A0/g, '&nbsp;');

	    if (options.smartIndentationFix) {
	      text = rTrimInputText(text);
	    }

	    // Make sure text begins and ends with a couple of newlines:
	    text = '\n\n' + text + '\n\n';

	    // detab
	    text = showdown.subParser('detab')(text, options, globals);

	    /**
	     * Strip any lines consisting only of spaces and tabs.
	     * This makes subsequent regexs easier to write, because we can
	     * match consecutive blank lines with /\n+/ instead of something
	     * contorted like /[ \t]*\n+/
	     */
	    text = text.replace(/^[ \t]+$/mg, '');

	    //run languageExtensions
	    showdown.helper.forEach(langExtensions, function (ext) {
	      text = showdown.subParser('runExtension')(ext, text, options, globals);
	    });

	    // run the sub parsers
	    text = showdown.subParser('metadata')(text, options, globals);
	    text = showdown.subParser('hashPreCodeTags')(text, options, globals);
	    text = showdown.subParser('githubCodeBlocks')(text, options, globals);
	    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
	    text = showdown.subParser('hashCodeTags')(text, options, globals);
	    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);
	    text = showdown.subParser('blockGamut')(text, options, globals);
	    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);
	    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);

	    // attacklab: Restore dollar signs
	    text = text.replace(/D/g, '$$');

	    // attacklab: Restore tremas
	    text = text.replace(/T/g, '');

	    // render a complete html document instead of a partial if the option is enabled
	    text = showdown.subParser('completeHTMLDocument')(text, options, globals);

	    // Run output modifiers
	    showdown.helper.forEach(outputModifiers, function (ext) {
	      text = showdown.subParser('runExtension')(ext, text, options, globals);
	    });

	    // update metadata
	    metadata = globals.metadata;
	    return text;
	  };

	  /**
	   * Converts an HTML string into a markdown string
	   * @param src
	   * @param [HTMLParser] A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.
	   * @returns {string}
	   */
	  this.makeMarkdown = this.makeMd = function (src, HTMLParser) {

	    // replace \r\n with \n
	    src = src.replace(/\r\n/g, '\n');
	    src = src.replace(/\r/g, '\n'); // old macs

	    // due to an edge case, we need to find this: > <
	    // to prevent removing of non silent white spaces
	    // ex: <em>this is</em> <strong>sparta</strong>
	    src = src.replace(/>[ \t]+</, '>NBSP;<');

	    if (!HTMLParser) {
	      if (window && window.document) {
	        HTMLParser = window.document;
	      } else {
	        throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM');
	      }
	    }

	    var doc = HTMLParser.createElement('div');
	    doc.innerHTML = src;

	    var globals = {
	      preList: substitutePreCodeTags(doc)
	    };

	    // remove all newlines and collapse spaces
	    clean(doc);

	    // some stuff, like accidental reference links must now be escaped
	    // TODO
	    // doc.innerHTML = doc.innerHTML.replace(/\[[\S\t ]]/);

	    var nodes = doc.childNodes,
	        mdDoc = '';

	    for (var i = 0; i < nodes.length; i++) {
	      mdDoc += showdown.subParser('makeMarkdown.node')(nodes[i], globals);
	    }

	    function clean (node) {
	      for (var n = 0; n < node.childNodes.length; ++n) {
	        var child = node.childNodes[n];
	        if (child.nodeType === 3) {
	          if (!/\S/.test(child.nodeValue)) {
	            node.removeChild(child);
	            --n;
	          } else {
	            child.nodeValue = child.nodeValue.split('\n').join(' ');
	            child.nodeValue = child.nodeValue.replace(/(\s)+/g, '$1');
	          }
	        } else if (child.nodeType === 1) {
	          clean(child);
	        }
	      }
	    }

	    // find all pre tags and replace contents with placeholder
	    // we need this so that we can remove all indentation from html
	    // to ease up parsing
	    function substitutePreCodeTags (doc) {

	      var pres = doc.querySelectorAll('pre'),
	          presPH = [];

	      for (var i = 0; i < pres.length; ++i) {

	        if (pres[i].childElementCount === 1 && pres[i].firstChild.tagName.toLowerCase() === 'code') {
	          var content = pres[i].firstChild.innerHTML.trim(),
	              language = pres[i].firstChild.getAttribute('data-language') || '';

	          // if data-language attribute is not defined, then we look for class language-*
	          if (language === '') {
	            var classes = pres[i].firstChild.className.split(' ');
	            for (var c = 0; c < classes.length; ++c) {
	              var matches = classes[c].match(/^language-(.+)$/);
	              if (matches !== null) {
	                language = matches[1];
	                break;
	              }
	            }
	          }

	          // unescape html entities in content
	          content = showdown.helper.unescapeHTMLEntities(content);

	          presPH.push(content);
	          pres[i].outerHTML = '<precode language="' + language + '" precodenum="' + i.toString() + '"></precode>';
	        } else {
	          presPH.push(pres[i].innerHTML);
	          pres[i].innerHTML = '';
	          pres[i].setAttribute('prenum', i.toString());
	        }
	      }
	      return presPH;
	    }

	    return mdDoc;
	  };

	  /**
	   * Set an option of this Converter instance
	   * @param {string} key
	   * @param {*} value
	   */
	  this.setOption = function (key, value) {
	    options[key] = value;
	  };

	  /**
	   * Get the option of this Converter instance
	   * @param {string} key
	   * @returns {*}
	   */
	  this.getOption = function (key) {
	    return options[key];
	  };

	  /**
	   * Get the options of this Converter instance
	   * @returns {{}}
	   */
	  this.getOptions = function () {
	    return options;
	  };

	  /**
	   * Add extension to THIS converter
	   * @param {{}} extension
	   * @param {string} [name=null]
	   */
	  this.addExtension = function (extension, name) {
	    name = name || null;
	    _parseExtension(extension, name);
	  };

	  /**
	   * Use a global registered extension with THIS converter
	   * @param {string} extensionName Name of the previously registered extension
	   */
	  this.useExtension = function (extensionName) {
	    _parseExtension(extensionName);
	  };

	  /**
	   * Set the flavor THIS converter should use
	   * @param {string} name
	   */
	  this.setFlavor = function (name) {
	    if (!flavor.hasOwnProperty(name)) {
	      throw Error(name + ' flavor was not found');
	    }
	    var preset = flavor[name];
	    setConvFlavor = name;
	    for (var option in preset) {
	      if (preset.hasOwnProperty(option)) {
	        options[option] = preset[option];
	      }
	    }
	  };

	  /**
	   * Get the currently set flavor of this converter
	   * @returns {string}
	   */
	  this.getFlavor = function () {
	    return setConvFlavor;
	  };

	  /**
	   * Remove an extension from THIS converter.
	   * Note: This is a costly operation. It's better to initialize a new converter
	   * and specify the extensions you wish to use
	   * @param {Array} extension
	   */
	  this.removeExtension = function (extension) {
	    if (!showdown.helper.isArray(extension)) {
	      extension = [extension];
	    }
	    for (var a = 0; a < extension.length; ++a) {
	      var ext = extension[a];
	      for (var i = 0; i < langExtensions.length; ++i) {
	        if (langExtensions[i] === ext) {
	          langExtensions[i].splice(i, 1);
	        }
	      }
	      for (var ii = 0; ii < outputModifiers.length; ++i) {
	        if (outputModifiers[ii] === ext) {
	          outputModifiers[ii].splice(i, 1);
	        }
	      }
	    }
	  };

	  /**
	   * Get all extension of THIS converter
	   * @returns {{language: Array, output: Array}}
	   */
	  this.getAllExtensions = function () {
	    return {
	      language: langExtensions,
	      output: outputModifiers
	    };
	  };

	  /**
	   * Get the metadata of the previously parsed document
	   * @param raw
	   * @returns {string|{}}
	   */
	  this.getMetadata = function (raw) {
	    if (raw) {
	      return metadata.raw;
	    } else {
	      return metadata.parsed;
	    }
	  };

	  /**
	   * Get the metadata format of the previously parsed document
	   * @returns {string}
	   */
	  this.getMetadataFormat = function () {
	    return metadata.format;
	  };

	  /**
	   * Private: set a single key, value metadata pair
	   * @param {string} key
	   * @param {string} value
	   */
	  this._setMetadataPair = function (key, value) {
	    metadata.parsed[key] = value;
	  };

	  /**
	   * Private: set metadata format
	   * @param {string} format
	   */
	  this._setMetadataFormat = function (format) {
	    metadata.format = format;
	  };

	  /**
	   * Private: set metadata raw text
	   * @param {string} raw
	   */
	  this._setMetadataRaw = function (raw) {
	    metadata.raw = raw;
	  };
	};

	/**
	 * Turn Markdown link shortcuts into XHTML <a> tags.
	 */
	showdown.subParser('anchors', function (text, options, globals) {

	  text = globals.converter._dispatch('anchors.before', text, options, globals);

	  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {
	    if (showdown.helper.isUndefined(title)) {
	      title = '';
	    }
	    linkId = linkId.toLowerCase();

	    // Special case for explicit empty url
	    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
	      url = '';
	    } else if (!url) {
	      if (!linkId) {
	        // lower-case and turn embedded newlines into spaces
	        linkId = linkText.toLowerCase().replace(/ ?\n/g, ' ');
	      }
	      url = '#' + linkId;

	      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {
	        url = globals.gUrls[linkId];
	        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {
	          title = globals.gTitles[linkId];
	        }
	      } else {
	        return wholeMatch;
	      }
	    }

	    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance
	    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);

	    var result = '<a href="' + url + '"';

	    if (title !== '' && title !== null) {
	      title = title.replace(/"/g, '&quot;');
	      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance
	      title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	      result += ' title="' + title + '"';
	    }

	    // optionLinksInNewWindow only applies
	    // to external links. Hash links (#) open in same page
	    if (options.openLinksInNewWindow && !/^#/.test(url)) {
	      // escaped _
	      result += ' target="E95Eblank"';
	    }

	    result += '>' + linkText + '</a>';

	    return result;
	  };

	  // First, handle reference-style links: [link text] [id]
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);

	  // Next, inline-style links: [link text](url "optional title")
	  // cases with crazy urls like ./image/cat1).png
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
	    writeAnchorTag);

	  // normal cases
	  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
	                      writeAnchorTag);

	  // handle reference-style shortcuts: [link text]
	  // These must come last in case you've also got [link test][1]
	  // or [link test](/foo)
	  text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);

	  // Lastly handle GithubMentions if option is enabled
	  if (options.ghMentions) {
	    text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (wm, st, escape, mentions, username) {
	      if (escape === '\\') {
	        return st + mentions;
	      }

	      //check if options.ghMentionsLink is a string
	      if (!showdown.helper.isString(options.ghMentionsLink)) {
	        throw new Error('ghMentionsLink option must be a string');
	      }
	      var lnk = options.ghMentionsLink.replace(/\{u}/g, username),
	          target = '';
	      if (options.openLinksInNewWindow) {
	        target = ' target="E95Eblank"';
	      }
	      return st + '<a href="' + lnk + '"' + target + '>' + mentions + '</a>';
	    });
	  }

	  text = globals.converter._dispatch('anchors.after', text, options, globals);
	  return text;
	});

	// url allowed chars [a-z\d_.~:/?#[]@!$&'()*+,;=-]

	var simpleURLRegex  = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
	    simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
	    delimUrlRegex   = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
	    simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi,
	    delimMailRegex  = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,

	    replaceLink = function (options) {
	      return function (wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
	        link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	        var lnkTxt = link,
	            append = '',
	            target = '',
	            lmc    = leadingMagicChars || '',
	            tmc    = trailingMagicChars || '';
	        if (/^www\./i.test(link)) {
	          link = link.replace(/^www\./i, 'http://www.');
	        }
	        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
	          append = trailingPunctuation;
	        }
	        if (options.openLinksInNewWindow) {
	          target = ' target="E95Eblank"';
	        }
	        return lmc + '<a href="' + link + '"' + target + '>' + lnkTxt + '</a>' + append + tmc;
	      };
	    },

	    replaceMail = function (options, globals) {
	      return function (wholeMatch, b, mail) {
	        var href = 'mailto:';
	        b = b || '';
	        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);
	        if (options.encodeEmails) {
	          href = showdown.helper.encodeEmailAddress(href + mail);
	          mail = showdown.helper.encodeEmailAddress(mail);
	        } else {
	          href = href + mail;
	        }
	        return b + '<a href="' + href + '">' + mail + '</a>';
	      };
	    };

	showdown.subParser('autoLinks', function (text, options, globals) {

	  text = globals.converter._dispatch('autoLinks.before', text, options, globals);

	  text = text.replace(delimUrlRegex, replaceLink(options));
	  text = text.replace(delimMailRegex, replaceMail(options, globals));

	  text = globals.converter._dispatch('autoLinks.after', text, options, globals);

	  return text;
	});

	showdown.subParser('simplifiedAutoLinks', function (text, options, globals) {

	  if (!options.simplifiedAutoLink) {
	    return text;
	  }

	  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);

	  if (options.excludeTrailingPunctuationFromURLs) {
	    text = text.replace(simpleURLRegex2, replaceLink(options));
	  } else {
	    text = text.replace(simpleURLRegex, replaceLink(options));
	  }
	  text = text.replace(simpleMailRegex, replaceMail(options, globals));

	  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);

	  return text;
	});

	/**
	 * These are all the transformations that form block-level
	 * tags like paragraphs, headers, and list items.
	 */
	showdown.subParser('blockGamut', function (text, options, globals) {

	  text = globals.converter._dispatch('blockGamut.before', text, options, globals);

	  // we parse blockquotes first so that we can have headings and hrs
	  // inside blockquotes
	  text = showdown.subParser('blockQuotes')(text, options, globals);
	  text = showdown.subParser('headers')(text, options, globals);

	  // Do Horizontal Rules:
	  text = showdown.subParser('horizontalRule')(text, options, globals);

	  text = showdown.subParser('lists')(text, options, globals);
	  text = showdown.subParser('codeBlocks')(text, options, globals);
	  text = showdown.subParser('tables')(text, options, globals);

	  // We already ran _HashHTMLBlocks() before, in Markdown(), but that
	  // was to escape raw HTML in the original Markdown source. This time,
	  // we're escaping the markup we've just created, so that we don't wrap
	  // <p> tags around block-level tags.
	  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
	  text = showdown.subParser('paragraphs')(text, options, globals);

	  text = globals.converter._dispatch('blockGamut.after', text, options, globals);

	  return text;
	});

	showdown.subParser('blockQuotes', function (text, options, globals) {

	  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);

	  // add a couple extra lines after the text and endtext mark
	  text = text + '\n\n';

	  var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;

	  if (options.splitAdjacentBlockquotes) {
	    rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
	  }

	  text = text.replace(rgx, function (bq) {
	    // attacklab: hack around Konqueror 3.5.4 bug:
	    // "----------bug".replace(/^-/g,"") == "bug"
	    bq = bq.replace(/^[ \t]*>[ \t]?/gm, ''); // trim one level of quoting

	    // attacklab: clean up hack
	    bq = bq.replace(/0/g, '');

	    bq = bq.replace(/^[ \t]+$/gm, ''); // trim whitespace-only lines
	    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);
	    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse

	    bq = bq.replace(/(^|\n)/g, '$1  ');
	    // These leading spaces screw with <pre> content, so we need to fix that:
	    bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (wholeMatch, m1) {
	      var pre = m1;
	      // attacklab: hack around Konqueror 3.5.4 bug:
	      pre = pre.replace(/^  /mg, '0');
	      pre = pre.replace(/0/g, '');
	      return pre;
	    });

	    return showdown.subParser('hashBlock')('<blockquote>\n' + bq + '\n</blockquote>', options, globals);
	  });

	  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);
	  return text;
	});

	/**
	 * Process Markdown `<pre><code>` blocks.
	 */
	showdown.subParser('codeBlocks', function (text, options, globals) {

	  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);

	  // sentinel workarounds for lack of \A and \Z, safari\khtml bug
	  text += '0';

	  var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=0))/g;
	  text = text.replace(pattern, function (wholeMatch, m1, m2) {
	    var codeblock = m1,
	        nextChar = m2,
	        end = '\n';

	    codeblock = showdown.subParser('outdent')(codeblock, options, globals);
	    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
	    codeblock = showdown.subParser('detab')(codeblock, options, globals);
	    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
	    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing newlines

	    if (options.omitExtraWLInCodeBlocks) {
	      end = '';
	    }

	    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';

	    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;
	  });

	  // strip sentinel
	  text = text.replace(/0/, '');

	  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);
	  return text;
	});

	/**
	 *
	 *   *  Backtick quotes are used for <code></code> spans.
	 *
	 *   *  You can use multiple backticks as the delimiters if you want to
	 *     include literal backticks in the code span. So, this input:
	 *
	 *         Just type ``foo `bar` baz`` at the prompt.
	 *
	 *       Will translate to:
	 *
	 *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
	 *
	 *    There's no arbitrary limit to the number of backticks you
	 *    can use as delimters. If you need three consecutive backticks
	 *    in your code, use four for delimiters, etc.
	 *
	 *  *  You can use spaces to get literal backticks at the edges:
	 *
	 *         ... type `` `bar` `` ...
	 *
	 *       Turns to:
	 *
	 *         ... type <code>`bar`</code> ...
	 */
	showdown.subParser('codeSpans', function (text, options, globals) {

	  text = globals.converter._dispatch('codeSpans.before', text, options, globals);

	  if (typeof(text) === 'undefined') {
	    text = '';
	  }
	  text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
	    function (wholeMatch, m1, m2, m3) {
	      var c = m3;
	      c = c.replace(/^([ \t]*)/g, '');	// leading whitespace
	      c = c.replace(/[ \t]*$/g, '');	// trailing whitespace
	      c = showdown.subParser('encodeCode')(c, options, globals);
	      c = m1 + '<code>' + c + '</code>';
	      c = showdown.subParser('hashHTMLSpans')(c, options, globals);
	      return c;
	    }
	  );

	  text = globals.converter._dispatch('codeSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Create a full HTML document from the processed markdown
	 */
	showdown.subParser('completeHTMLDocument', function (text, options, globals) {

	  if (!options.completeHTMLDocument) {
	    return text;
	  }

	  text = globals.converter._dispatch('completeHTMLDocument.before', text, options, globals);

	  var doctype = 'html',
	      doctypeParsed = '<!DOCTYPE HTML>\n',
	      title = '',
	      charset = '<meta charset="utf-8">\n',
	      lang = '',
	      metadata = '';

	  if (typeof globals.metadata.parsed.doctype !== 'undefined') {
	    doctypeParsed = '<!DOCTYPE ' +  globals.metadata.parsed.doctype + '>\n';
	    doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
	    if (doctype === 'html' || doctype === 'html5') {
	      charset = '<meta charset="utf-8">';
	    }
	  }

	  for (var meta in globals.metadata.parsed) {
	    if (globals.metadata.parsed.hasOwnProperty(meta)) {
	      switch (meta.toLowerCase()) {
	        case 'doctype':
	          break;

	        case 'title':
	          title = '<title>' +  globals.metadata.parsed.title + '</title>\n';
	          break;

	        case 'charset':
	          if (doctype === 'html' || doctype === 'html5') {
	            charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
	          } else {
	            charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
	          }
	          break;

	        case 'language':
	        case 'lang':
	          lang = ' lang="' + globals.metadata.parsed[meta] + '"';
	          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
	          break;

	        default:
	          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
	      }
	    }
	  }

	  text = doctypeParsed + '<html' + lang + '>\n<head>\n' + title + charset + metadata + '</head>\n<body>\n' + text.trim() + '\n</body>\n</html>';

	  text = globals.converter._dispatch('completeHTMLDocument.after', text, options, globals);
	  return text;
	});

	/**
	 * Convert all tabs to spaces
	 */
	showdown.subParser('detab', function (text, options, globals) {
	  text = globals.converter._dispatch('detab.before', text, options, globals);

	  // expand first n-1 tabs
	  text = text.replace(/\t(?=\t)/g, '    '); // g_tab_width

	  // replace the nth with two sentinels
	  text = text.replace(/\t/g, 'AB');

	  // use the sentinel to anchor our regex so it doesn't explode
	  text = text.replace(/B(.+?)A/g, function (wholeMatch, m1) {
	    var leadingText = m1,
	        numSpaces = 4 - leadingText.length % 4;  // g_tab_width

	    // there *must* be a better way to do this:
	    for (var i = 0; i < numSpaces; i++) {
	      leadingText += ' ';
	    }

	    return leadingText;
	  });

	  // clean up sentinels
	  text = text.replace(/A/g, '    ');  // g_tab_width
	  text = text.replace(/B/g, '');

	  text = globals.converter._dispatch('detab.after', text, options, globals);
	  return text;
	});

	showdown.subParser('ellipsis', function (text, options, globals) {

	  text = globals.converter._dispatch('ellipsis.before', text, options, globals);

	  text = text.replace(/\.\.\./g, '');

	  text = globals.converter._dispatch('ellipsis.after', text, options, globals);

	  return text;
	});

	/**
	 * Turn emoji codes into emojis
	 *
	 * List of supported emojis: https://github.com/showdownjs/showdown/wiki/Emojis
	 */
	showdown.subParser('emoji', function (text, options, globals) {

	  if (!options.emoji) {
	    return text;
	  }

	  text = globals.converter._dispatch('emoji.before', text, options, globals);

	  var emojiRgx = /:([\S]+?):/g;

	  text = text.replace(emojiRgx, function (wm, emojiCode) {
	    if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {
	      return showdown.helper.emojis[emojiCode];
	    }
	    return wm;
	  });

	  text = globals.converter._dispatch('emoji.after', text, options, globals);

	  return text;
	});

	/**
	 * Smart processing for ampersands and angle brackets that need to be encoded.
	 */
	showdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {
	  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);

	  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
	  // http://bumppo.net/projects/amputator/
	  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, '&amp;');

	  // Encode naked <'s
	  text = text.replace(/<(?![a-z\/?$!])/gi, '&lt;');

	  // Encode <
	  text = text.replace(/</g, '&lt;');

	  // Encode >
	  text = text.replace(/>/g, '&gt;');

	  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);
	  return text;
	});

	/**
	 * Returns the string, with after processing the following backslash escape sequences.
	 *
	 * attacklab: The polite way to do this is with the new escapeCharacters() function:
	 *
	 *    text = escapeCharacters(text,"\\",true);
	 *    text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
	 *
	 * ...but we're sidestepping its use of the (slow) RegExp constructor
	 * as an optimization for Firefox.  This function gets called a LOT.
	 */
	showdown.subParser('encodeBackslashEscapes', function (text, options, globals) {
	  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);

	  text = text.replace(/\\(\\)/g, showdown.helper.escapeCharactersCallback);
	  text = text.replace(/\\([`*_{}\[\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);
	  return text;
	});

	/**
	 * Encode/escape certain characters inside Markdown code runs.
	 * The point is that in code, these characters are literals,
	 * and lose their special Markdown meanings.
	 */
	showdown.subParser('encodeCode', function (text, options, globals) {

	  text = globals.converter._dispatch('encodeCode.before', text, options, globals);

	  // Encode all ampersands; HTML entities are not
	  // entities within a Markdown code span.
	  text = text
	    .replace(/&/g, '&amp;')
	  // Do the angle bracket song and dance:
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	  // Now, escape characters that are magic in Markdown:
	    .replace(/([*_{}\[\]\\=~-])/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('encodeCode.after', text, options, globals);
	  return text;
	});

	/**
	 * Within tags -- meaning between < and > -- encode [\ ` * _ ~ =] so they
	 * don't conflict with their use in Markdown for code, italics and strong.
	 */
	showdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {
	  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);

	  // Build a regex to find HTML tags.
	  var tags     = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
	      comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;

	  text = text.replace(tags, function (wholeMatch) {
	    return wholeMatch
	      .replace(/(.)<\/?code>(?=.)/g, '$1`')
	      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
	  });

	  text = text.replace(comments, function (wholeMatch) {
	    return wholeMatch
	      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
	  });

	  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);
	  return text;
	});

	/**
	 * Handle github codeblocks prior to running HashHTML so that
	 * HTML contained within the codeblock gets escaped properly
	 * Example:
	 * ```ruby
	 *     def hello_world(x)
	 *       puts "Hello, #{x}"
	 *     end
	 * ```
	 */
	showdown.subParser('githubCodeBlocks', function (text, options, globals) {

	  // early exit if option is not enabled
	  if (!options.ghCodeBlocks) {
	    return text;
	  }

	  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);

	  text += '0';

	  text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (wholeMatch, delim, language, codeblock) {
	    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\n';

	    // First parse the github code block
	    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
	    codeblock = showdown.subParser('detab')(codeblock, options, globals);
	    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
	    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing whitespace

	    codeblock = '<pre><code' + (language ? ' class="' + language + ' language-' + language + '"' : '') + '>' + codeblock + end + '</code></pre>';

	    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);

	    // Since GHCodeblocks can be false positives, we need to
	    // store the primitive text and the parsed text in a global var,
	    // and then return a token
	    return '\n\nG' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
	  });

	  // attacklab: strip sentinel
	  text = text.replace(/0/, '');

	  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);
	});

	showdown.subParser('hashBlock', function (text, options, globals) {
	  text = globals.converter._dispatch('hashBlock.before', text, options, globals);
	  text = text.replace(/(^\n+|\n+$)/g, '');
	  text = '\n\nK' + (globals.gHtmlBlocks.push(text) - 1) + 'K\n\n';
	  text = globals.converter._dispatch('hashBlock.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash and escape <code> elements that should not be parsed as markdown
	 */
	showdown.subParser('hashCodeTags', function (text, options, globals) {
	  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);

	  var repFunc = function (wholeMatch, match, left, right) {
	    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
	    return 'C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';
	  };

	  // Hash naked <code>
	  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\b[^>]*>', '</code>', 'gim');

	  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);
	  return text;
	});

	showdown.subParser('hashElement', function (text, options, globals) {

	  return function (wholeMatch, m1) {
	    var blockText = m1;

	    // Undo double lines
	    blockText = blockText.replace(/\n\n/g, '\n');
	    blockText = blockText.replace(/^\n/, '');

	    // strip trailing blank lines
	    blockText = blockText.replace(/\n+$/g, '');

	    // Replace the element text with a marker ("KxK" where x is its key)
	    blockText = '\n\nK' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\n\n';

	    return blockText;
	  };
	});

	showdown.subParser('hashHTMLBlocks', function (text, options, globals) {
	  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);

	  var blockTags = [
	        'pre',
	        'div',
	        'h1',
	        'h2',
	        'h3',
	        'h4',
	        'h5',
	        'h6',
	        'blockquote',
	        'table',
	        'dl',
	        'ol',
	        'ul',
	        'script',
	        'noscript',
	        'form',
	        'fieldset',
	        'iframe',
	        'math',
	        'style',
	        'section',
	        'header',
	        'footer',
	        'nav',
	        'article',
	        'aside',
	        'address',
	        'audio',
	        'canvas',
	        'figure',
	        'hgroup',
	        'output',
	        'video',
	        'p'
	      ],
	      repFunc = function (wholeMatch, match, left, right) {
	        var txt = wholeMatch;
	        // check if this html element is marked as markdown
	        // if so, it's contents should be parsed as markdown
	        if (left.search(/\bmarkdown\b/) !== -1) {
	          txt = left + globals.converter.makeHtml(match) + right;
	        }
	        return '\n\nK' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
	      };

	  if (options.backslashEscapesHTMLTags) {
	    // encode backslash escaped HTML tags
	    text = text.replace(/\\<(\/?[^>]+?)>/g, function (wm, inside) {
	      return '&lt;' + inside + '&gt;';
	    });
	  }

	  // hash HTML Blocks
	  for (var i = 0; i < blockTags.length; ++i) {

	    var opTagPos,
	        rgx1     = new RegExp('^ {0,3}(<' + blockTags[i] + '\\b[^>]*>)', 'im'),
	        patLeft  = '<' + blockTags[i] + '\\b[^>]*>',
	        patRight = '</' + blockTags[i] + '>';
	    // 1. Look for the first position of the first opening HTML tag in the text
	    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {

	      // if the HTML tag is \ escaped, we need to escape it and break


	      //2. Split the text in that position
	      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),
	      //3. Match recursively
	          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');

	      // prevent an infinite loop
	      if (newSubText1 === subTexts[1]) {
	        break;
	      }
	      text = subTexts[0].concat(newSubText1);
	    }
	  }
	  // HR SPECIAL CASE
	  text = text.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
	    showdown.subParser('hashElement')(text, options, globals));

	  // Special case for standalone HTML comments
	  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {
	    return '\n\nK' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
	  }, '^ {0,3}<!--', '-->', 'gm');

	  // PHP and ASP-style processor instructions (<?...?> and <%...%>)
	  text = text.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
	    showdown.subParser('hashElement')(text, options, globals));

	  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash span elements that should not be parsed as markdown
	 */
	showdown.subParser('hashHTMLSpans', function (text, options, globals) {
	  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);

	  function hashHTMLSpan (html) {
	    return 'C' + (globals.gHtmlSpans.push(html) - 1) + 'C';
	  }

	  // Hash Self Closing tags
	  text = text.replace(/<[^>]+?\/>/gi, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash tags without properties
	  text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash tags with properties
	  text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  // Hash self closing tags without />
	  text = text.replace(/<[^>]+?>/gi, function (wm) {
	    return hashHTMLSpan(wm);
	  });

	  /*showdown.helper.matchRecursiveRegExp(text, '<code\\b[^>]*>', '</code>', 'gi');*/

	  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Unhash HTML spans
	 */
	showdown.subParser('unhashHTMLSpans', function (text, options, globals) {
	  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);

	  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
	    var repText = globals.gHtmlSpans[i],
	        // limiter to prevent infinite loop (assume 10 as limit for recurse)
	        limit = 0;

	    while (/C(\d+)C/.test(repText)) {
	      var num = RegExp.$1;
	      repText = repText.replace('C' + num + 'C', globals.gHtmlSpans[num]);
	      if (limit === 10) {
	        console.error('maximum nesting of 10 spans reached!!!');
	        break;
	      }
	      ++limit;
	    }
	    text = text.replace('C' + i + 'C', repText);
	  }

	  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);
	  return text;
	});

	/**
	 * Hash and escape <pre><code> elements that should not be parsed as markdown
	 */
	showdown.subParser('hashPreCodeTags', function (text, options, globals) {
	  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);

	  var repFunc = function (wholeMatch, match, left, right) {
	    // encode html entities
	    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
	    return '\n\nG' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
	  };

	  // Hash <pre><code>
	  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>', '^ {0,3}</code>\\s*</pre>', 'gim');

	  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);
	  return text;
	});

	showdown.subParser('headers', function (text, options, globals) {

	  text = globals.converter._dispatch('headers.before', text, options, globals);

	  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),

	  // Set text-style headers:
	  //	Header 1
	  //	========
	  //
	  //	Header 2
	  //	--------
	  //
	      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
	      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;

	  text = text.replace(setextRegexH1, function (wholeMatch, m1) {

	    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
	        hLevel = headerLevelStart,
	        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
	    return showdown.subParser('hashBlock')(hashBlock, options, globals);
	  });

	  text = text.replace(setextRegexH2, function (matchFound, m1) {
	    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
	        hLevel = headerLevelStart + 1,
	        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
	    return showdown.subParser('hashBlock')(hashBlock, options, globals);
	  });

	  // atx-style headers:
	  //  # Header 1
	  //  ## Header 2
	  //  ## Header 2 with closing hashes ##
	  //  ...
	  //  ###### Header 6
	  //
	  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;

	  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {
	    var hText = m2;
	    if (options.customizedHeaderId) {
	      hText = m2.replace(/\s?\{([^{]+?)}\s*$/, '');
	    }

	    var span = showdown.subParser('spanGamut')(hText, options, globals),
	        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m2) + '"',
	        hLevel = headerLevelStart - 1 + m1.length,
	        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';

	    return showdown.subParser('hashBlock')(header, options, globals);
	  });

	  function headerId (m) {
	    var title,
	        prefix;

	    // It is separate from other options to allow combining prefix and customized
	    if (options.customizedHeaderId) {
	      var match = m.match(/\{([^{]+?)}\s*$/);
	      if (match && match[1]) {
	        m = match[1];
	      }
	    }

	    title = m;

	    // Prefix id to prevent causing inadvertent pre-existing style matches.
	    if (showdown.helper.isString(options.prefixHeaderId)) {
	      prefix = options.prefixHeaderId;
	    } else if (options.prefixHeaderId === true) {
	      prefix = 'section-';
	    } else {
	      prefix = '';
	    }

	    if (!options.rawPrefixHeaderId) {
	      title = prefix + title;
	    }

	    if (options.ghCompatibleHeaderId) {
	      title = title
	        .replace(/ /g, '-')
	        // replace previously escaped chars (&,  and $)
	        .replace(/&amp;/g, '')
	        .replace(/T/g, '')
	        .replace(/D/g, '')
	        // replace rest of the chars (&~$ are repeated as they might have been escaped)
	        // borrowed from github's redcarpet (some they should produce similar results)
	        .replace(/[&+$,\/:;=?@"#{}|^~\[\]`\\*)(%.!'<>]/g, '')
	        .toLowerCase();
	    } else if (options.rawHeaderId) {
	      title = title
	        .replace(/ /g, '-')
	        // replace previously escaped chars (&,  and $)
	        .replace(/&amp;/g, '&')
	        .replace(/T/g, '')
	        .replace(/D/g, '$')
	        // replace " and '
	        .replace(/["']/g, '-')
	        .toLowerCase();
	    } else {
	      title = title
	        .replace(/[^\w]/g, '')
	        .toLowerCase();
	    }

	    if (options.rawPrefixHeaderId) {
	      title = prefix + title;
	    }

	    if (globals.hashLinkCounts[title]) {
	      title = title + '-' + (globals.hashLinkCounts[title]++);
	    } else {
	      globals.hashLinkCounts[title] = 1;
	    }
	    return title;
	  }

	  text = globals.converter._dispatch('headers.after', text, options, globals);
	  return text;
	});

	/**
	 * Turn Markdown link shortcuts into XHTML <a> tags.
	 */
	showdown.subParser('horizontalRule', function (text, options, globals) {
	  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);

	  var key = showdown.subParser('hashBlock')('<hr />', options, globals);
	  text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
	  text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
	  text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);

	  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);
	  return text;
	});

	/**
	 * Turn Markdown image shortcuts into <img> tags.
	 */
	showdown.subParser('images', function (text, options, globals) {

	  text = globals.converter._dispatch('images.before', text, options, globals);

	  var inlineRegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
	      crazyRegExp       = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
	      base64RegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
	      referenceRegExp   = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
	      refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;

	  function writeImageTagBase64 (wholeMatch, altText, linkId, url, width, height, m5, title) {
	    url = url.replace(/\s/g, '');
	    return writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title);
	  }

	  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {

	    var gUrls   = globals.gUrls,
	        gTitles = globals.gTitles,
	        gDims   = globals.gDimensions;

	    linkId = linkId.toLowerCase();

	    if (!title) {
	      title = '';
	    }
	    // Special case for explicit empty url
	    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
	      url = '';

	    } else if (url === '' || url === null) {
	      if (linkId === '' || linkId === null) {
	        // lower-case and turn embedded newlines into spaces
	        linkId = altText.toLowerCase().replace(/ ?\n/g, ' ');
	      }
	      url = '#' + linkId;

	      if (!showdown.helper.isUndefined(gUrls[linkId])) {
	        url = gUrls[linkId];
	        if (!showdown.helper.isUndefined(gTitles[linkId])) {
	          title = gTitles[linkId];
	        }
	        if (!showdown.helper.isUndefined(gDims[linkId])) {
	          width = gDims[linkId].width;
	          height = gDims[linkId].height;
	        }
	      } else {
	        return wholeMatch;
	      }
	    }

	    altText = altText
	      .replace(/"/g, '&quot;')
	    //altText = showdown.helper.escapeCharacters(altText, '*_', false);
	      .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	    //url = showdown.helper.escapeCharacters(url, '*_', false);
	    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	    var result = '<img src="' + url + '" alt="' + altText + '"';

	    if (title && showdown.helper.isString(title)) {
	      title = title
	        .replace(/"/g, '&quot;')
	      //title = showdown.helper.escapeCharacters(title, '*_', false);
	        .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
	      result += ' title="' + title + '"';
	    }

	    if (width && height) {
	      width  = (width === '*') ? 'auto' : width;
	      height = (height === '*') ? 'auto' : height;

	      result += ' width="' + width + '"';
	      result += ' height="' + height + '"';
	    }

	    result += ' />';

	    return result;
	  }

	  // First, handle reference-style labeled images: ![alt text][id]
	  text = text.replace(referenceRegExp, writeImageTag);

	  // Next, handle inline images:  ![alt text](url =<width>x<height> "optional title")

	  // base64 encoded images
	  text = text.replace(base64RegExp, writeImageTagBase64);

	  // cases with crazy urls like ./image/cat1).png
	  text = text.replace(crazyRegExp, writeImageTag);

	  // normal cases
	  text = text.replace(inlineRegExp, writeImageTag);

	  // handle reference-style shortcuts: ![img text]
	  text = text.replace(refShortcutRegExp, writeImageTag);

	  text = globals.converter._dispatch('images.after', text, options, globals);
	  return text;
	});

	showdown.subParser('italicsAndBold', function (text, options, globals) {

	  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);

	  // it's faster to have 3 separate regexes for each case than have just one
	  // because of backtracing, in some cases, it could lead to an exponential effect
	  // called "catastrophic backtrace". Ominous!

	  function parseInside (txt, left, right) {
	    /*
	    if (options.simplifiedAutoLink) {
	      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
	    }
	    */
	    return left + txt + right;
	  }

	  // Parse underscores
	  if (options.literalMidWordUnderscores) {
	    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
	      return parseInside (txt, '<strong><em>', '</em></strong>');
	    });
	    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
	      return parseInside (txt, '<strong>', '</strong>');
	    });
	    text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function (wm, txt) {
	      return parseInside (txt, '<em>', '</em>');
	    });
	  } else {
	    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
	    });
	    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
	    });
	    text = text.replace(/_([^\s_][\s\S]*?)_/g, function (wm, m) {
	      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)
	      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
	    });
	  }

	  // Now parse asterisks
	  if (options.literalMidWordAsterisks) {
	    text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<strong><em>', '</em></strong>');
	    });
	    text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<strong>', '</strong>');
	    });
	    text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (wm, lead, txt) {
	      return parseInside (txt, lead + '<em>', '</em>');
	    });
	  } else {
	    text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
	    });
	    text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (wm, m) {
	      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
	    });
	    text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function (wm, m) {
	      // !/^\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)
	      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
	    });
	  }


	  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);
	  return text;
	});

	/**
	 * Form HTML ordered (numbered) and unordered (bulleted) lists.
	 */
	showdown.subParser('lists', function (text, options, globals) {

	  /**
	   * Process the contents of a single ordered or unordered list, splitting it
	   * into individual list items.
	   * @param {string} listStr
	   * @param {boolean} trimTrailing
	   * @returns {string}
	   */
	  function processListItems (listStr, trimTrailing) {
	    // The $g_list_level global keeps track of when we're inside a list.
	    // Each time we enter a list, we increment it; when we leave a list,
	    // we decrement. If it's zero, we're not in a list anymore.
	    //
	    // We do this because when we're not inside a list, we want to treat
	    // something like this:
	    //
	    //    I recommend upgrading to version
	    //    8. Oops, now this line is treated
	    //    as a sub-list.
	    //
	    // As a single paragraph, despite the fact that the second line starts
	    // with a digit-period-space sequence.
	    //
	    // Whereas when we're inside a list (or sub-list), that line will be
	    // treated as the start of a sub-list. What a kludge, huh? This is
	    // an aspect of Markdown's syntax that's hard to parse perfectly
	    // without resorting to mind-reading. Perhaps the solution is to
	    // change the syntax rules such that sub-lists must start with a
	    // starting cardinal number; e.g. "1." or "a.".
	    globals.gListLevel++;

	    // trim trailing blank lines:
	    listStr = listStr.replace(/\n{2,}$/, '\n');

	    // attacklab: add sentinel to emulate \z
	    listStr += '0';

	    var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
	        isParagraphed = (/\n[ \t]*\n(?!0)/.test(listStr));

	    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,
	    // which is a syntax breaking change
	    // activating this option reverts to old behavior
	    if (options.disableForced4SpacesIndentedSublists) {
	      rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0|\2([*+-]|\d+[.])[ \t]+))/gm;
	    }

	    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
	      checked = (checked && checked.trim() !== '');

	      var item = showdown.subParser('outdent')(m4, options, globals),
	          bulletStyle = '';

	      // Support for github tasklists
	      if (taskbtn && options.tasklists) {
	        bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
	        item = item.replace(/^[ \t]*\[(x|X| )?]/m, function () {
	          var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
	          if (checked) {
	            otp += ' checked';
	          }
	          otp += '>';
	          return otp;
	        });
	      }

	      // ISSUE #312
	      // This input: - - - a
	      // causes trouble to the parser, since it interprets it as:
	      // <ul><li><li><li>a</li></li></li></ul>
	      // instead of:
	      // <ul><li>- - a</li></ul>
	      // So, to prevent it, we will put a marker (A)in the beginning of the line
	      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser
	      item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (wm2) {
	        return 'A' + wm2;
	      });

	      // m1 - Leading line or
	      // Has a double return (multi paragraph) or
	      // Has sublist
	      if (m1 || (item.search(/\n{2,}/) > -1)) {
	        item = showdown.subParser('githubCodeBlocks')(item, options, globals);
	        item = showdown.subParser('blockGamut')(item, options, globals);
	      } else {
	        // Recursion for sub-lists:
	        item = showdown.subParser('lists')(item, options, globals);
	        item = item.replace(/\n$/, ''); // chomp(item)
	        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);

	        // Colapse double linebreaks
	        item = item.replace(/\n\n+/g, '\n\n');
	        if (isParagraphed) {
	          item = showdown.subParser('paragraphs')(item, options, globals);
	        } else {
	          item = showdown.subParser('spanGamut')(item, options, globals);
	        }
	      }

	      // now we need to remove the marker (A)
	      item = item.replace('A', '');
	      // we can finally wrap the line in list item tags
	      item =  '<li' + bulletStyle + '>' + item + '</li>\n';

	      return item;
	    });

	    // attacklab: strip sentinel
	    listStr = listStr.replace(/0/g, '');

	    globals.gListLevel--;

	    if (trimTrailing) {
	      listStr = listStr.replace(/\s+$/, '');
	    }

	    return listStr;
	  }

	  function styleStartNumber (list, listType) {
	    // check if ol and starts by a number different than 1
	    if (listType === 'ol') {
	      var res = list.match(/^ *(\d+)\./);
	      if (res && res[1] !== '1') {
	        return ' start="' + res[1] + '"';
	      }
	    }
	    return '';
	  }

	  /**
	   * Check and parse consecutive lists (better fix for issue #142)
	   * @param {string} list
	   * @param {string} listType
	   * @param {boolean} trimTrailing
	   * @returns {string}
	   */
	  function parseConsecutiveLists (list, listType, trimTrailing) {
	    // check if we caught 2 or more consecutive lists by mistake
	    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa
	    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm,
	        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm,
	        counterRxg = (listType === 'ul') ? olRgx : ulRgx,
	        result = '';

	    if (list.search(counterRxg) !== -1) {
	      (function parseCL (txt) {
	        var pos = txt.search(counterRxg),
	            style = styleStartNumber(list, listType);
	        if (pos !== -1) {
	          // slice
	          result += '\n\n<' + listType + style + '>\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\n';

	          // invert counterType and listType
	          listType = (listType === 'ul') ? 'ol' : 'ul';
	          counterRxg = (listType === 'ul') ? olRgx : ulRgx;

	          //recurse
	          parseCL(txt.slice(pos));
	        } else {
	          result += '\n\n<' + listType + style + '>\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\n';
	        }
	      })(list);
	    } else {
	      var style = styleStartNumber(list, listType);
	      result = '\n\n<' + listType + style + '>\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\n';
	    }

	    return result;
	  }

	  /** Start of list parsing **/
	  text = globals.converter._dispatch('lists.before', text, options, globals);
	  // add sentinel to hack around khtml/safari bug:
	  // http://bugs.webkit.org/show_bug.cgi?id=11231
	  text += '0';

	  if (globals.gListLevel) {
	    text = text.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
	      function (wholeMatch, list, m2) {
	        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
	        return parseConsecutiveLists(list, listType, true);
	      }
	    );
	  } else {
	    text = text.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
	      function (wholeMatch, m1, list, m3) {
	        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
	        return parseConsecutiveLists(list, listType, false);
	      }
	    );
	  }

	  // strip sentinel
	  text = text.replace(/0/, '');
	  text = globals.converter._dispatch('lists.after', text, options, globals);
	  return text;
	});

	/**
	 * Parse metadata at the top of the document
	 */
	showdown.subParser('metadata', function (text, options, globals) {

	  if (!options.metadata) {
	    return text;
	  }

	  text = globals.converter._dispatch('metadata.before', text, options, globals);

	  function parseMetadataContents (content) {
	    // raw is raw so it's not changed in any way
	    globals.metadata.raw = content;

	    // escape chars forbidden in html attributes
	    // double quotes
	    content = content
	      // ampersand first
	      .replace(/&/g, '&amp;')
	      // double quotes
	      .replace(/"/g, '&quot;');

	    content = content.replace(/\n {4}/g, ' ');
	    content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (wm, key, value) {
	      globals.metadata.parsed[key] = value;
	      return '';
	    });
	  }

	  text = text.replace(/^\s*+(\S*?)\n([\s\S]+?)\n+\n/, function (wholematch, format, content) {
	    parseMetadataContents(content);
	    return 'M';
	  });

	  text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (wholematch, format, content) {
	    if (format) {
	      globals.metadata.format = format;
	    }
	    parseMetadataContents(content);
	    return 'M';
	  });

	  text = text.replace(/M/g, '');

	  text = globals.converter._dispatch('metadata.after', text, options, globals);
	  return text;
	});

	/**
	 * Remove one level of line-leading tabs or spaces
	 */
	showdown.subParser('outdent', function (text, options, globals) {
	  text = globals.converter._dispatch('outdent.before', text, options, globals);

	  // attacklab: hack around Konqueror 3.5.4 bug:
	  // "----------bug".replace(/^-/g,"") == "bug"
	  text = text.replace(/^(\t|[ ]{1,4})/gm, '0'); // attacklab: g_tab_width

	  // attacklab: clean up hack
	  text = text.replace(/0/g, '');

	  text = globals.converter._dispatch('outdent.after', text, options, globals);
	  return text;
	});

	/**
	 *
	 */
	showdown.subParser('paragraphs', function (text, options, globals) {

	  text = globals.converter._dispatch('paragraphs.before', text, options, globals);
	  // Strip leading and trailing lines:
	  text = text.replace(/^\n+/g, '');
	  text = text.replace(/\n+$/g, '');

	  var grafs = text.split(/\n{2,}/g),
	      grafsOut = [],
	      end = grafs.length; // Wrap <p> tags

	  for (var i = 0; i < end; i++) {
	    var str = grafs[i];
	    // if this is an HTML marker, copy it
	    if (str.search(/(K|G)(\d+)\1/g) >= 0) {
	      grafsOut.push(str);

	    // test for presence of characters to prevent empty lines being parsed
	    // as paragraphs (resulting in undesired extra empty paragraphs)
	    } else if (str.search(/\S/) >= 0) {
	      str = showdown.subParser('spanGamut')(str, options, globals);
	      str = str.replace(/^([ \t]*)/g, '<p>');
	      str += '</p>';
	      grafsOut.push(str);
	    }
	  }

	  /** Unhashify HTML blocks */
	  end = grafsOut.length;
	  for (i = 0; i < end; i++) {
	    var blockText = '',
	        grafsOutIt = grafsOut[i],
	        codeFlag = false;
	    // if this is a marker for an html block...
	    // use RegExp.test instead of string.search because of QML bug
	    while (/(K|G)(\d+)\1/.test(grafsOutIt)) {
	      var delim = RegExp.$1,
	          num   = RegExp.$2;

	      if (delim === 'K') {
	        blockText = globals.gHtmlBlocks[num];
	      } else {
	        // we need to check if ghBlock is a false positive
	        if (codeFlag) {
	          // use encoded version of all text
	          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);
	        } else {
	          blockText = globals.ghCodeBlocks[num].codeblock;
	        }
	      }
	      blockText = blockText.replace(/\$/g, '$$$$'); // Escape any dollar signs

	      grafsOutIt = grafsOutIt.replace(/(\n\n)?(K|G)\d+\2(\n\n)?/, blockText);
	      // Check if grafsOutIt is a pre->code
	      if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
	        codeFlag = true;
	      }
	    }
	    grafsOut[i] = grafsOutIt;
	  }
	  text = grafsOut.join('\n');
	  // Strip leading and trailing lines:
	  text = text.replace(/^\n+/g, '');
	  text = text.replace(/\n+$/g, '');
	  return globals.converter._dispatch('paragraphs.after', text, options, globals);
	});

	/**
	 * Run extension
	 */
	showdown.subParser('runExtension', function (ext, text, options, globals) {

	  if (ext.filter) {
	    text = ext.filter(text, globals.converter, options);

	  } else if (ext.regex) {
	    // TODO remove this when old extension loading mechanism is deprecated
	    var re = ext.regex;
	    if (!(re instanceof RegExp)) {
	      re = new RegExp(re, 'g');
	    }
	    text = text.replace(re, ext.replace);
	  }

	  return text;
	});

	/**
	 * These are all the transformations that occur *within* block-level
	 * tags like paragraphs, headers, and list items.
	 */
	showdown.subParser('spanGamut', function (text, options, globals) {

	  text = globals.converter._dispatch('spanGamut.before', text, options, globals);
	  text = showdown.subParser('codeSpans')(text, options, globals);
	  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);
	  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);

	  // Process anchor and image tags. Images must come first,
	  // because ![foo][f] looks like an anchor.
	  text = showdown.subParser('images')(text, options, globals);
	  text = showdown.subParser('anchors')(text, options, globals);

	  // Make links out of things like `<http://example.com/>`
	  // Must come after anchors, because you can use < and >
	  // delimiters in inline links like [this](<url>).
	  text = showdown.subParser('autoLinks')(text, options, globals);
	  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);
	  text = showdown.subParser('emoji')(text, options, globals);
	  text = showdown.subParser('underline')(text, options, globals);
	  text = showdown.subParser('italicsAndBold')(text, options, globals);
	  text = showdown.subParser('strikethrough')(text, options, globals);
	  text = showdown.subParser('ellipsis')(text, options, globals);

	  // we need to hash HTML tags inside spans
	  text = showdown.subParser('hashHTMLSpans')(text, options, globals);

	  // now we encode amps and angles
	  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);

	  // Do hard breaks
	  if (options.simpleLineBreaks) {
	    // GFM style hard breaks
	    // only add line breaks if the text does not contain a block (special case for lists)
	    if (!/\n\nK/.test(text)) {
	      text = text.replace(/\n+/g, '<br />\n');
	    }
	  } else {
	    // Vanilla hard breaks
	    text = text.replace(/  +\n/g, '<br />\n');
	  }

	  text = globals.converter._dispatch('spanGamut.after', text, options, globals);
	  return text;
	});

	showdown.subParser('strikethrough', function (text, options, globals) {

	  function parseInside (txt) {
	    if (options.simplifiedAutoLink) {
	      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
	    }
	    return '<del>' + txt + '</del>';
	  }

	  if (options.strikethrough) {
	    text = globals.converter._dispatch('strikethrough.before', text, options, globals);
	    text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });
	    text = globals.converter._dispatch('strikethrough.after', text, options, globals);
	  }

	  return text;
	});

	/**
	 * Strips link definitions from text, stores the URLs and titles in
	 * hash references.
	 * Link defs are in the form: ^[id]: url "optional title"
	 */
	showdown.subParser('stripLinkDefinitions', function (text, options, globals) {

	  var regex       = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=0))/gm,
	      base64Regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=0)|(?=\n\[))/gm;

	  // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
	  text += '0';

	  var replaceFunc = function (wholeMatch, linkId, url, width, height, blankLines, title) {
	    linkId = linkId.toLowerCase();
	    if (url.match(/^data:.+?\/.+?;base64,/)) {
	      // remove newlines
	      globals.gUrls[linkId] = url.replace(/\s/g, '');
	    } else {
	      globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive
	    }

	    if (blankLines) {
	      // Oops, found blank lines, so it's not a title.
	      // Put back the parenthetical statement we stole.
	      return blankLines + title;

	    } else {
	      if (title) {
	        globals.gTitles[linkId] = title.replace(/"|'/g, '&quot;');
	      }
	      if (options.parseImgDimensions && width && height) {
	        globals.gDimensions[linkId] = {
	          width:  width,
	          height: height
	        };
	      }
	    }
	    // Completely remove the definition from the text
	    return '';
	  };

	  // first we try to find base64 link references
	  text = text.replace(base64Regex, replaceFunc);

	  text = text.replace(regex, replaceFunc);

	  // attacklab: strip sentinel
	  text = text.replace(/0/, '');

	  return text;
	});

	showdown.subParser('tables', function (text, options, globals) {

	  if (!options.tables) {
	    return text;
	  }

	  var tableRgx       = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|0)/gm,
	    //singeColTblRgx = /^ {0,3}\|.+\|\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n(?: {0,3}\|.+\|\n)+(?:\n\n|0)/gm;
	      singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|0)/gm;

	  function parseStyles (sLine) {
	    if (/^:[ \t]*--*$/.test(sLine)) {
	      return ' style="text-align:left;"';
	    } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
	      return ' style="text-align:right;"';
	    } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
	      return ' style="text-align:center;"';
	    } else {
	      return '';
	    }
	  }

	  function parseHeaders (header, style) {
	    var id = '';
	    header = header.trim();
	    // support both tablesHeaderId and tableHeaderId due to error in documentation so we don't break backwards compatibility
	    if (options.tablesHeaderId || options.tableHeaderId) {
	      id = ' id="' + header.replace(/ /g, '_').toLowerCase() + '"';
	    }
	    header = showdown.subParser('spanGamut')(header, options, globals);

	    return '<th' + id + style + '>' + header + '</th>\n';
	  }

	  function parseCells (cell, style) {
	    var subText = showdown.subParser('spanGamut')(cell, options, globals);
	    return '<td' + style + '>' + subText + '</td>\n';
	  }

	  function buildTable (headers, cells) {
	    var tb = '<table>\n<thead>\n<tr>\n',
	        tblLgn = headers.length;

	    for (var i = 0; i < tblLgn; ++i) {
	      tb += headers[i];
	    }
	    tb += '</tr>\n</thead>\n<tbody>\n';

	    for (i = 0; i < cells.length; ++i) {
	      tb += '<tr>\n';
	      for (var ii = 0; ii < tblLgn; ++ii) {
	        tb += cells[i][ii];
	      }
	      tb += '</tr>\n';
	    }
	    tb += '</tbody>\n</table>\n';
	    return tb;
	  }

	  function parseTable (rawTable) {
	    var i, tableLines = rawTable.split('\n');

	    for (i = 0; i < tableLines.length; ++i) {
	      // strip wrong first and last column if wrapped tables are used
	      if (/^ {0,3}\|/.test(tableLines[i])) {
	        tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, '');
	      }
	      if (/\|[ \t]*$/.test(tableLines[i])) {
	        tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, '');
	      }
	      // parse code spans first, but we only support one line code spans
	      tableLines[i] = showdown.subParser('codeSpans')(tableLines[i], options, globals);
	    }

	    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),
	        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),
	        rawCells = [],
	        headers = [],
	        styles = [],
	        cells = [];

	    tableLines.shift();
	    tableLines.shift();

	    for (i = 0; i < tableLines.length; ++i) {
	      if (tableLines[i].trim() === '') {
	        continue;
	      }
	      rawCells.push(
	        tableLines[i]
	          .split('|')
	          .map(function (s) {
	            return s.trim();
	          })
	      );
	    }

	    if (rawHeaders.length < rawStyles.length) {
	      return rawTable;
	    }

	    for (i = 0; i < rawStyles.length; ++i) {
	      styles.push(parseStyles(rawStyles[i]));
	    }

	    for (i = 0; i < rawHeaders.length; ++i) {
	      if (showdown.helper.isUndefined(styles[i])) {
	        styles[i] = '';
	      }
	      headers.push(parseHeaders(rawHeaders[i], styles[i]));
	    }

	    for (i = 0; i < rawCells.length; ++i) {
	      var row = [];
	      for (var ii = 0; ii < headers.length; ++ii) {
	        if (showdown.helper.isUndefined(rawCells[i][ii])) ;
	        row.push(parseCells(rawCells[i][ii], styles[ii]));
	      }
	      cells.push(row);
	    }

	    return buildTable(headers, cells);
	  }

	  text = globals.converter._dispatch('tables.before', text, options, globals);

	  // find escaped pipe characters
	  text = text.replace(/\\(\|)/g, showdown.helper.escapeCharactersCallback);

	  // parse multi column tables
	  text = text.replace(tableRgx, parseTable);

	  // parse one column tables
	  text = text.replace(singeColTblRgx, parseTable);

	  text = globals.converter._dispatch('tables.after', text, options, globals);

	  return text;
	});

	showdown.subParser('underline', function (text, options, globals) {

	  if (!options.underline) {
	    return text;
	  }

	  text = globals.converter._dispatch('underline.before', text, options, globals);

	  if (options.literalMidWordUnderscores) {
	    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
	      return '<u>' + txt + '</u>';
	    });
	    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
	      return '<u>' + txt + '</u>';
	    });
	  } else {
	    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
	      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
	    });
	    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
	      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
	    });
	  }

	  // escape remaining underscores to prevent them being parsed by italic and bold
	  text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);

	  text = globals.converter._dispatch('underline.after', text, options, globals);

	  return text;
	});

	/**
	 * Swap back in all the special characters we've hidden.
	 */
	showdown.subParser('unescapeSpecialChars', function (text, options, globals) {
	  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);

	  text = text.replace(/E(\d+)E/g, function (wholeMatch, m1) {
	    var charCodeToReplace = parseInt(m1);
	    return String.fromCharCode(charCodeToReplace);
	  });

	  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);
	  return text;
	});

	showdown.subParser('makeMarkdown.blockquote', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    var children = node.childNodes,
	        childrenLength = children.length;

	    for (var i = 0; i < childrenLength; ++i) {
	      var innerTxt = showdown.subParser('makeMarkdown.node')(children[i], globals);

	      if (innerTxt === '') {
	        continue;
	      }
	      txt += innerTxt;
	    }
	  }
	  // cleanup
	  txt = txt.trim();
	  txt = '> ' + txt.split('\n').join('\n> ');
	  return txt;
	});

	showdown.subParser('makeMarkdown.codeBlock', function (node, globals) {

	  var lang = node.getAttribute('language'),
	      num  = node.getAttribute('precodenum');
	  return '```' + lang + '\n' + globals.preList[num] + '\n```';
	});

	showdown.subParser('makeMarkdown.codeSpan', function (node) {

	  return '`' + node.innerHTML + '`';
	});

	showdown.subParser('makeMarkdown.emphasis', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '*';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '*';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.header', function (node, globals, headerLevel) {

	  var headerMark = new Array(headerLevel + 1).join('#'),
	      txt = '';

	  if (node.hasChildNodes()) {
	    txt = headerMark + ' ';
	    var children = node.childNodes,
	        childrenLength = children.length;

	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.hr', function () {

	  return '---';
	});

	showdown.subParser('makeMarkdown.image', function (node) {

	  var txt = '';
	  if (node.hasAttribute('src')) {
	    txt += '![' + node.getAttribute('alt') + '](';
	    txt += '<' + node.getAttribute('src') + '>';
	    if (node.hasAttribute('width') && node.hasAttribute('height')) {
	      txt += ' =' + node.getAttribute('width') + 'x' + node.getAttribute('height');
	    }

	    if (node.hasAttribute('title')) {
	      txt += ' "' + node.getAttribute('title') + '"';
	    }
	    txt += ')';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.links', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes() && node.hasAttribute('href')) {
	    var children = node.childNodes,
	        childrenLength = children.length;
	    txt = '[';
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '](';
	    txt += '<' + node.getAttribute('href') + '>';
	    if (node.hasAttribute('title')) {
	      txt += ' "' + node.getAttribute('title') + '"';
	    }
	    txt += ')';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.list', function (node, globals, type) {

	  var txt = '';
	  if (!node.hasChildNodes()) {
	    return '';
	  }
	  var listItems       = node.childNodes,
	      listItemsLenght = listItems.length,
	      listNum = node.getAttribute('start') || 1;

	  for (var i = 0; i < listItemsLenght; ++i) {
	    if (typeof listItems[i].tagName === 'undefined' || listItems[i].tagName.toLowerCase() !== 'li') {
	      continue;
	    }

	    // define the bullet to use in list
	    var bullet = '';
	    if (type === 'ol') {
	      bullet = listNum.toString() + '. ';
	    } else {
	      bullet = '- ';
	    }

	    // parse list item
	    txt += bullet + showdown.subParser('makeMarkdown.listItem')(listItems[i], globals);
	    ++listNum;
	  }

	  // add comment at the end to prevent consecutive lists to be parsed as one
	  txt += '\n<!-- -->\n';
	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.listItem', function (node, globals) {

	  var listItemTxt = '';

	  var children = node.childNodes,
	      childrenLenght = children.length;

	  for (var i = 0; i < childrenLenght; ++i) {
	    listItemTxt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	  }
	  // if it's only one liner, we need to add a newline at the end
	  if (!/\n$/.test(listItemTxt)) {
	    listItemTxt += '\n';
	  } else {
	    // it's multiparagraph, so we need to indent
	    listItemTxt = listItemTxt
	      .split('\n')
	      .join('\n    ')
	      .replace(/^ {4}$/gm, '')
	      .replace(/\n\n+/g, '\n\n');
	  }

	  return listItemTxt;
	});



	showdown.subParser('makeMarkdown.node', function (node, globals, spansOnly) {

	  spansOnly = spansOnly || false;

	  var txt = '';

	  // edge case of text without wrapper paragraph
	  if (node.nodeType === 3) {
	    return showdown.subParser('makeMarkdown.txt')(node, globals);
	  }

	  // HTML comment
	  if (node.nodeType === 8) {
	    return '<!--' + node.data + '-->\n\n';
	  }

	  // process only node elements
	  if (node.nodeType !== 1) {
	    return '';
	  }

	  var tagName = node.tagName.toLowerCase();

	  switch (tagName) {

	    //
	    // BLOCKS
	    //
	    case 'h1':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 1) + '\n\n'; }
	      break;
	    case 'h2':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 2) + '\n\n'; }
	      break;
	    case 'h3':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 3) + '\n\n'; }
	      break;
	    case 'h4':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 4) + '\n\n'; }
	      break;
	    case 'h5':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 5) + '\n\n'; }
	      break;
	    case 'h6':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 6) + '\n\n'; }
	      break;

	    case 'p':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.paragraph')(node, globals) + '\n\n'; }
	      break;

	    case 'blockquote':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.blockquote')(node, globals) + '\n\n'; }
	      break;

	    case 'hr':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.hr')(node, globals) + '\n\n'; }
	      break;

	    case 'ol':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ol') + '\n\n'; }
	      break;

	    case 'ul':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ul') + '\n\n'; }
	      break;

	    case 'precode':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.codeBlock')(node, globals) + '\n\n'; }
	      break;

	    case 'pre':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.pre')(node, globals) + '\n\n'; }
	      break;

	    case 'table':
	      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.table')(node, globals) + '\n\n'; }
	      break;

	    //
	    // SPANS
	    //
	    case 'code':
	      txt = showdown.subParser('makeMarkdown.codeSpan')(node, globals);
	      break;

	    case 'em':
	    case 'i':
	      txt = showdown.subParser('makeMarkdown.emphasis')(node, globals);
	      break;

	    case 'strong':
	    case 'b':
	      txt = showdown.subParser('makeMarkdown.strong')(node, globals);
	      break;

	    case 'del':
	      txt = showdown.subParser('makeMarkdown.strikethrough')(node, globals);
	      break;

	    case 'a':
	      txt = showdown.subParser('makeMarkdown.links')(node, globals);
	      break;

	    case 'img':
	      txt = showdown.subParser('makeMarkdown.image')(node, globals);
	      break;

	    default:
	      txt = node.outerHTML + '\n\n';
	  }

	  // common normalization
	  // TODO eventually

	  return txt;
	});

	showdown.subParser('makeMarkdown.paragraph', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	  }

	  // some text normalization
	  txt = txt.trim();

	  return txt;
	});

	showdown.subParser('makeMarkdown.pre', function (node, globals) {

	  var num  = node.getAttribute('prenum');
	  return '<pre>' + globals.preList[num] + '</pre>';
	});

	showdown.subParser('makeMarkdown.strikethrough', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '~~';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '~~';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.strong', function (node, globals) {

	  var txt = '';
	  if (node.hasChildNodes()) {
	    txt += '**';
	    var children = node.childNodes,
	        childrenLength = children.length;
	    for (var i = 0; i < childrenLength; ++i) {
	      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
	    }
	    txt += '**';
	  }
	  return txt;
	});

	showdown.subParser('makeMarkdown.table', function (node, globals) {

	  var txt = '',
	      tableArray = [[], []],
	      headings   = node.querySelectorAll('thead>tr>th'),
	      rows       = node.querySelectorAll('tbody>tr'),
	      i, ii;
	  for (i = 0; i < headings.length; ++i) {
	    var headContent = showdown.subParser('makeMarkdown.tableCell')(headings[i], globals),
	        allign = '---';

	    if (headings[i].hasAttribute('style')) {
	      var style = headings[i].getAttribute('style').toLowerCase().replace(/\s/g, '');
	      switch (style) {
	        case 'text-align:left;':
	          allign = ':---';
	          break;
	        case 'text-align:right;':
	          allign = '---:';
	          break;
	        case 'text-align:center;':
	          allign = ':---:';
	          break;
	      }
	    }
	    tableArray[0][i] = headContent.trim();
	    tableArray[1][i] = allign;
	  }

	  for (i = 0; i < rows.length; ++i) {
	    var r = tableArray.push([]) - 1,
	        cols = rows[i].getElementsByTagName('td');

	    for (ii = 0; ii < headings.length; ++ii) {
	      var cellContent = ' ';
	      if (typeof cols[ii] !== 'undefined') {
	        cellContent = showdown.subParser('makeMarkdown.tableCell')(cols[ii], globals);
	      }
	      tableArray[r].push(cellContent);
	    }
	  }

	  var cellSpacesCount = 3;
	  for (i = 0; i < tableArray.length; ++i) {
	    for (ii = 0; ii < tableArray[i].length; ++ii) {
	      var strLen = tableArray[i][ii].length;
	      if (strLen > cellSpacesCount) {
	        cellSpacesCount = strLen;
	      }
	    }
	  }

	  for (i = 0; i < tableArray.length; ++i) {
	    for (ii = 0; ii < tableArray[i].length; ++ii) {
	      if (i === 1) {
	        if (tableArray[i][ii].slice(-1) === ':') {
	          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, '-') + ':';
	        } else {
	          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, '-');
	        }
	      } else {
	        tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);
	      }
	    }
	    txt += '| ' + tableArray[i].join(' | ') + ' |\n';
	  }

	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.tableCell', function (node, globals) {

	  var txt = '';
	  if (!node.hasChildNodes()) {
	    return '';
	  }
	  var children = node.childNodes,
	      childrenLength = children.length;

	  for (var i = 0; i < childrenLength; ++i) {
	    txt += showdown.subParser('makeMarkdown.node')(children[i], globals, true);
	  }
	  return txt.trim();
	});

	showdown.subParser('makeMarkdown.txt', function (node) {

	  var txt = node.nodeValue;

	  // multiple spaces are collapsed
	  txt = txt.replace(/ +/g, ' ');

	  // replace the custom NBSP; with a space
	  txt = txt.replace(/NBSP;/g, ' ');

	  // ", <, > and & should replace escaped html entities
	  txt = showdown.helper.unescapeHTMLEntities(txt);

	  // escape markdown magic characters
	  // emphasis, strong and strikethrough - can appear everywhere
	  // we also escape pipe (|) because of tables
	  // and escape ` because of code blocks and spans
	  txt = txt.replace(/([*_~|`])/g, '\\$1');

	  // escape > because of blockquotes
	  txt = txt.replace(/^(\s*)>/g, '\\$1>');

	  // hash character, only troublesome at the beginning of a line because of headers
	  txt = txt.replace(/^#/gm, '\\#');

	  // horizontal rules
	  txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, '$1\\$2$3');

	  // dot, because of ordered lists, only troublesome at the beginning of a line when preceded by an integer
	  txt = txt.replace(/^( {0,3}\d+)\./gm, '$1\\.');

	  // +, * and -, at the beginning of a line becomes a list, so we need to escape them also (asterisk was already escaped)
	  txt = txt.replace(/^( {0,3})([+-])/gm, '$1\\$2');

	  // images and links, ] followed by ( is problematic, so we escape it
	  txt = txt.replace(/]([\s]*)\(/g, '\\]$1\\(');

	  // reference URIs must also be escaped
	  txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, '\\[$1]:');

	  return txt;
	});

	var root = this;

	// AMD Loader
	if (module.exports) {
	  module.exports = showdown;

	// Regular Browser loader
	} else {
	  root.showdown = showdown;
	}
	}).call(commonjsGlobal);


	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide("frappe.tools");

	frappe.tools.downloadify = function(data, roles, title) {
		if(roles && roles.length && !has_common(roles, roles)) {
			frappe.msgprint(__("Export not allowed. You need {0} role to export.", [frappe.utils.comma_or(roles)]));
			return;
		}

		var filename = title + ".csv";
		var csv_data = frappe.tools.to_csv(data);
		var a = document.createElement('a');

		if ("download" in a) {
			// Used Blob object, because it can handle large files
			var blob_object = new Blob([csv_data], { type: 'text/csv;charset=UTF-8' });
			a.href = URL.createObjectURL(blob_object);
			a.download = filename;

		} else {
			// use old method
			a.href = 'data:attachment/csv,' + encodeURIComponent(csv_data);
			a.download = filename;
			a.target = "_blank";
		}

		document.body.appendChild(a);
		a.click();

		document.body.removeChild(a);
	};

	frappe.markdown = function(txt) {
		if(!frappe.md2html) {
			frappe.md2html = new showdown.Converter();
		}

		while(txt.substr(0,1)==="\n") {
			txt = txt.substr(1);
		}

		// remove leading tab (if they exist in the first line)
		var whitespace_len = 0,
			first_line = txt.split("\n")[0];

		while(["\n", "\t"].indexOf(first_line.substr(0,1))!== -1) {
			whitespace_len++;
			first_line = first_line.substr(1);
		}

		if(whitespace_len && whitespace_len != first_line.length) {
			var txt1 = [];
			$.each(txt.split("\n"), function(i, t) {
				txt1.push(t.substr(whitespace_len));
			});
			txt = txt1.join("\n");
		}

		return frappe.md2html.makeHtml(txt);
	};

	frappe.tools.to_csv = function(data) {
		var res = [];
		$.each(data, function(i, row) {
			row = $.map(row, function(col) {
				if (col === null || col === undefined) { col = ''; }
				return typeof col === "string" ? ('"' + $('<i>').html(col.replace(/"/g, '""')).text() + '"') : col;
			});
			res.push(row.join(","));
		});
		return res.join("\n");
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.datetime');

	frappe.defaultDateFormat = "YYYY-MM-DD";
	frappe.defaultTimeFormat = "HH:mm:ss";
	frappe.defaultDatetimeFormat = frappe.defaultDateFormat + " " + frappe.defaultTimeFormat;
	moment.defaultFormat = frappe.defaultDateFormat;

	frappe.provide("frappe.datetime");

	$.extend(frappe.datetime, {
		convert_to_user_tz: function(date, format) {
			// format defaults to true
			if(frappe.sys_defaults.time_zone) {
				var date_obj = moment.tz(date, frappe.sys_defaults.time_zone).local();
			} else {
				var date_obj = moment(date);
			}

			return (format===false) ? date_obj : date_obj.format(frappe.defaultDatetimeFormat);
		},

		convert_to_system_tz: function(date, format) {
			// format defaults to true

			if(frappe.sys_defaults.time_zone) {
				var date_obj = moment(date).tz(frappe.sys_defaults.time_zone);
			} else {
				var date_obj = moment(date);
			}

			return (format===false) ? date_obj : date_obj.format(frappe.defaultDatetimeFormat);
		},

		is_timezone_same: function() {
			if(frappe.sys_defaults.time_zone) {
				return moment().tz(frappe.sys_defaults.time_zone).utcOffset() === moment().utcOffset();
			} else {
				return true;
			}
		},

		str_to_obj: function(d) {
			return moment(d, frappe.defaultDatetimeFormat)._d;
		},

		obj_to_str: function(d) {
			return moment(d).locale("en").format();
		},

		obj_to_user: function(d) {
			return moment(d).format(frappe.datetime.get_user_fmt().toUpperCase());
		},

		get_diff: function(d1, d2) {
			return moment(d1).diff(d2, "days");
		},

		get_hour_diff: function(d1, d2) {
			return moment(d1).diff(d2, "hours");
		},

		get_day_diff: function(d1, d2) {
			return moment(d1).diff(d2, "days");
		},

		add_days: function(d, days) {
			return moment(d).add(days, "days").format();
		},

		add_months: function(d, months) {
			return moment(d).add(months, "months").format();
		},

		week_start: function() {
			return moment().startOf("week").format();
		},

		week_end: function() {
			return moment().endOf("week").format();
		},

		month_start: function() {
			return moment().startOf("month").format();
		},

		month_end: function() {
			return moment().endOf("month").format();
		},

		year_start: function(){
			return moment().startOf("year").format();
		},

		year_end: function(){
			return moment().endOf("year").format();
		},

		get_user_fmt: function() {
			return frappe.sys_defaults && frappe.sys_defaults.date_format || "yyyy-mm-dd";
		},

		str_to_user: function(val, only_time) {
			if ( only_time === void 0 ) only_time = false;

			if(!val) { return ""; }

			if(only_time) {
				return moment(val, frappe.defaultTimeFormat)
					.format(frappe.defaultTimeFormat);
			}

			var user_fmt = frappe.datetime.get_user_fmt().toUpperCase();
			if(typeof val !== "string" || val.indexOf(" ")===-1) {
				return moment(val).format(user_fmt);
			} else {
				return moment(val, "YYYY-MM-DD HH:mm:ss").format(user_fmt + " HH:mm:ss");
			}
		},

		get_datetime_as_string: function(d) {
			return moment(d).format("YYYY-MM-DD HH:mm:ss");
		},

		user_to_str: function(val, only_time) {
			if ( only_time === void 0 ) only_time = false;


			if(only_time) {
				return moment(val, frappe.defaultTimeFormat)
					.format(frappe.defaultTimeFormat);
			}

			var user_fmt = frappe.datetime.get_user_fmt().toUpperCase();
			var system_fmt = "YYYY-MM-DD";

			if(val.indexOf(" ")!==-1) {
				user_fmt += " HH:mm:ss";
				system_fmt += " HH:mm:ss";
			}

			// user_fmt.replace("YYYY", "YY")? user might only input 2 digits of the year, which should also be parsed
			return moment(val, [user_fmt.replace("YYYY", "YY"),
				user_fmt]).locale("en").format(system_fmt);
		},

		user_to_obj: function(d) {
			return frappe.datetime.str_to_obj(frappe.datetime.user_to_str(d));
		},

		global_date_format: function(d) {
			var m = moment(d);
			if(m._f && m._f.indexOf("HH")!== -1) {
				return m.format("Do MMMM YYYY, h:mma")
			} else {
				return m.format('Do MMMM YYYY');
			}
		},

		now_date: function(as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			return frappe.datetime._date(frappe.defaultDateFormat, as_obj);
		},

		now_time: function(as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			return frappe.datetime._date(frappe.defaultTimeFormat, as_obj);
		},

		now_datetime: function(as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			return frappe.datetime._date(frappe.defaultDatetimeFormat, as_obj);
		},

		_date: function(format, as_obj) {
			if ( as_obj === void 0 ) as_obj = false;

			var time_zone = frappe.sys_defaults && frappe.sys_defaults.time_zone;
			var date;
			if (time_zone) {
				date = moment.tz(time_zone);
			} else {
				date = moment();
			}
			if (as_obj) {
				return frappe.datetime.moment_to_date_obj(date);
			} else {
				return date.format(format);
			}
		},

		moment_to_date_obj: function(moment) {
			var date_obj = new Date();
			var date_array = moment.toArray();
			date_obj.setFullYear(date_array[0]);
			date_obj.setMonth(date_array[1]);
			date_obj.setDate(date_array[2]);
			date_obj.setHours(date_array[3]);
			date_obj.setMinutes(date_array[4]);
			date_obj.setSeconds(date_array[5]);
			date_obj.setMilliseconds(date_array[6]);
			return date_obj;
		},

		nowdate: function() {
			return frappe.datetime.now_date();
		},

		get_today: function() {
			return frappe.datetime.now_date();
		},

		get_time: function (timestamp) {
			// return time with AM/PM
			return moment(timestamp).format('hh:mm A');
		},

		validate: function(d) {
			return moment(d, [
				frappe.defaultDateFormat,
				frappe.defaultDatetimeFormat,
				frappe.defaultTimeFormat
			], true).isValid();
		},

	});

	// Proxy for dateutil and get_today
	Object.defineProperties(window, {
		'dateutil': {
			get: function() {
				console.warn('Please use `frappe.datetime` instead of `dateutil`. It will be deprecated soon.');
				return frappe.datetime;
			}
		},
		'date': {
			get: function() {
				console.warn('Please use `frappe.datetime` instead of `date`. It will be deprecated soon.');
				return frappe.datetime;
			}
		},
		'get_today': {
			get: function() {
				console.warn('Please use `frappe.datetime.get_today` instead of `get_today`. It will be deprecated soon.');
				return frappe.datetime.get_today;
			}
		}
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	window.cstr = function(s) {
		if(s==null){ return ''; }
		return s+'';
	};

	window.cint = function(v, def) {
		if (v === true)
			{ return 1; }
		if (v === false)
			{ return 0; }
		v = v + '';
		if (v !== "0") { v = lstrip(v, ['0']); }
		v = parseInt(v); // eslint-ignore-line
		if (isNaN(v)) { v = def === undefined ? 0 : def; }
		return v;
	};

	// to title case
	window.toTitle = function(str){
		var word_in = str.split(" ");
		var word_out = [];

		for(var w in word_in){
			word_out[w] = word_in[w].charAt(0).toUpperCase() + word_in[w].slice(1);
		}

		return word_out.join(" ");
	};

	window.is_null = function(v) {
		if(v===null || v===undefined || cstr(v).trim()==="") { return true; }
	};

	window.copy_dict = function(d) {
		var n = {};
		for(var k in d) { n[k] = d[k]; }
		return n;
	};

	window.validate_email = function(txt) {
		return frappe.utils.validate_type(txt, "email");
	};

	window.nth = function(number) {
		number = cint(number);
		var s = 'th';
		if((number+'').substr(-1)=='1') { s = 'st'; }
		if((number+'').substr(-1)=='2') { s = 'nd'; }
		if((number+'').substr(-1)=='3') { s = 'rd'; }
		return number+s;
	};

	window.has_words = function(list, item) {
		if(!item) { return true; }
		if(!list) { return false; }
		for(var i=0, j=list.length; i<j; i++) {
			if(item.indexOf(list[i])!=-1)
				{ return true; }
		}
		return false;
	};

	window.has_common = function(list1, list2) {
		if(!list1 || !list2) { return false; }
		for(var i=0, j=list1.length; i<j; i++) {
			if(in_list(list2, list1[i])){ return true; }
		}
		return false;
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	if (!window.frappe) { window.frappe = {}; }

	function flt$1(v, decimals, number_format) {
		if (v == null || v == '') { return 0; }

		if (typeof v !== "number") {
			v = v + "";

			// strip currency symbol if exists
			if (v.indexOf(" ") != -1) {
				// using slice(1).join(" ") because space could also be a group separator
				var parts = v.split(" ");
				v = isNaN(parseFloat(parts[0])) ? parts.slice(parts.length - 1).join(" ") : v;
			}

			v = strip_number_groups(v, number_format);

			v = parseFloat(v);
			if (isNaN(v))
				{ v = 0; }
		}

		if (decimals != null)
			{ return _round(v, decimals); }
		return v;
	}

	function strip_number_groups(v, number_format) {
		if (!number_format) { number_format = get_number_format$1(); }
		var info = get_number_format_info$1(number_format);

		// strip groups (,)
		var group_regex = new RegExp(info.group_sep === "." ? "\\." : info.group_sep, "g");
		v = v.replace(group_regex, "");

		// replace decimal separator with (.)
		if (info.decimal_str !== "." && info.decimal_str !== "") {
			var decimal_regex = new RegExp(info.decimal_str, "g");
			v = v.replace(decimal_regex, ".");
		}

		return v;
	}


	frappe.number_format_info = {
		"#,###.##": { decimal_str: ".", group_sep: "," },
		"#.###,##": { decimal_str: ",", group_sep: "." },
		"# ###.##": { decimal_str: ".", group_sep: " " },
		"# ###,##": { decimal_str: ",", group_sep: " " },
		"#'###.##": { decimal_str: ".", group_sep: "'" },
		"#, ###.##": { decimal_str: ".", group_sep: ", " },
		"#,##,###.##": { decimal_str: ".", group_sep: "," },
		"#,###.###": { decimal_str: ".", group_sep: "," },
		"#.###": { decimal_str: "", group_sep: "." },
		"#,###": { decimal_str: "", group_sep: "," },
	};

	window.format_number = function (v, format, decimals) {
		if (!format) {
			format = get_number_format$1();
			if (decimals == null) { decimals = cint(frappe.defaults.get_default("float_precision")) || 3; }
		}

		var info = get_number_format_info$1(format);

		// Fix the decimal first, toFixed will auto fill trailing zero.
		if (decimals == null) { decimals = info.precision; }

		v = flt$1(v, decimals, format);

		var is_negative = false;
		if (v < 0) { is_negative = true; }
		v = Math.abs(v);

		v = v.toFixed(decimals);

		var part = v.split('.');

		// get group position and parts
		var group_position = info.group_sep ? 3 : 0;

		if (group_position) {
			var integer = part[0];
			var str = '';
			var offset = integer.length % group_position;
			for (var i = integer.length; i >= 0; i--) {
				var l = replace_all(str, info.group_sep, "").length;
				if (format == "#,##,###.##" && str.indexOf(",") != -1) { // INR
					group_position = 2;
					l += 1;
				}

				str += integer.charAt(i);

				if (l && !((l + 1) % group_position) && i != 0) {
					str += info.group_sep;
				}
			}
			part[0] = str.split("").reverse().join("");
		}
		if (part[0] + "" == "") {
			part[0] = "0";
		}

		// join decimal
		part[1] = (part[1] && info.decimal_str) ? (info.decimal_str + part[1]) : "";

		// join
		return (is_negative ? "-" : "") + part[0] + part[1];
	};

	function format_currency$1(v, currency, decimals) {
		var format = get_number_format$1(currency);
		var symbol = get_currency_symbol(currency);
		if(decimals === undefined) {
			decimals = frappe.boot.sysdefaults.currency_precision || null;
		}

		if (symbol)
			{ return symbol + " " + format_number(v, format, decimals); }
		else
			{ return format_number(v, format, decimals); }
	}

	function get_currency_symbol(currency) {
		if (frappe.boot) {
			if (frappe.boot.sysdefaults.hide_currency_symbol == "Yes")
				{ return null; }

			if (!currency)
				{ currency = frappe.boot.sysdefaults.currency; }

			return frappe.model.get_value(":Currency", currency, "symbol") || currency;
		} else {
			// load in template
			return frappe.currency_symbols[currency];
		}
	}

	function get_number_format$1(currency) {
		return (frappe.boot && frappe.boot.sysdefaults && frappe.boot.sysdefaults.number_format) || "#,###.##";
	}

	function get_number_format_info$1(format) {
		var info = frappe.number_format_info[format];

		if (!info) {
			info = { decimal_str: ".", group_sep: "," };
		}

		// get the precision from the number format
		info.precision = format.split(info.decimal_str).slice(1)[0].length;

		return info;
	}

	function _round(num, precision) {
		var is_negative = num < 0 ? true : false;
		var d = cint(precision);
		var m = Math.pow(10, d);
		var n = +(d ? Math.abs(num) * m : Math.abs(num)).toFixed(8); // Avoid rounding errors
		var i = Math.floor(n), f = n - i;
		var r = ((!precision && f == 0.5) ? ((i % 2 == 0) ? i : i + 1) : Math.round(n));
		r = d ? r / m : r;
		return is_negative ? -r : r;

	}

	function roundNumber(num, precision) {
		// backward compatibility
		return _round(num, precision);
	}

	function precision$1(fieldname, doc) {
		if (cur_frm) {
			if (!doc) { doc = cur_frm.doc; }
			var df = frappe.meta.get_docfield(doc.doctype, fieldname, doc.parent || doc.name);
			if (!df) { console.log(fieldname + ": could not find docfield in method precision()"); }
			return frappe.meta.get_field_precision(df, doc);
		} else {
			return frappe.boot.sysdefaults.float_precision
		}
	}

	function in_list$1(list, item) {
		return list.includes(item);
	}

	function remainder(numerator, denominator, precision) {
		precision = cint(precision);
		var multiplier = Math.pow(10, precision);
		if (precision) {
			var _remainder = ((numerator * multiplier) % (denominator * multiplier)) / multiplier;
		} else {
			var _remainder = numerator % denominator;
		}

		return flt$1(_remainder, precision);
	}

	function round_based_on_smallest_currency_fraction(value, currency, precision) {
		var smallest_currency_fraction_value = flt$1(frappe.model.get_value(":Currency",
			currency, "smallest_currency_fraction_value"));

		if (smallest_currency_fraction_value) {
			var remainder_val = remainder(value, smallest_currency_fraction_value, precision);
			if (remainder_val > (smallest_currency_fraction_value / 2)) {
				value += (smallest_currency_fraction_value - remainder_val);
			} else {
				value -= remainder_val;
			}
		} else {
			value = _round(value);
		}
		return value;
	}

	function fmt_money(v, format){
		// deprecated!
		// for backward compatibility
		return format_currency$1(v, format);
	}


	Object.assign(window, {
		flt: flt$1,
		cint: cint,
		strip_number_groups: strip_number_groups,
		format_currency: format_currency$1,
		fmt_money: fmt_money,
		get_currency_symbol: get_currency_symbol,
		get_number_format: get_number_format$1,
		get_number_format_info: get_number_format_info$1,
		_round: _round,
		roundNumber: roundNumber,
		precision: precision$1,
		remainder: remainder,
		round_based_on_smallest_currency_fraction: round_based_on_smallest_currency_fraction,
		in_list: in_list$1
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.help");

	frappe.help.youtube_id = {};

	frappe.help.has_help = function(doctype) {
		return frappe.help.youtube_id[doctype];
	};

	frappe.help.show = function(doctype) {
		if(frappe.help.youtube_id[doctype]) {
			frappe.help.show_video(frappe.help.youtube_id[doctype]);
		}
	};

	frappe.help.show_video = function(youtube_id, title) {
		if($("body").width() > 768) {
			var size = [670, 377];
		} else {
			var size = [560, 315];
		}
		var dialog = frappe.msgprint({
			message: "<iframe width=\"" + (size[0]) + "\" height=\"" + (size[1]) + "\"\n\t\t\tsrc=\"https://www.youtube.com/embed/" + youtube_id + "\"\n\t\t\tframeborder=\"0\" allowfullscreen></iframe>" + (frappe.help_feedback_link || ""),
			title: title || __("Help"),
			wide: true
		});

		dialog.$wrapper.addClass("video-modal");
	};

	$("body").on("click", "a.help-link", function() {
		var doctype = $(this).attr("data-doctype");
		doctype && frappe.help.show(doctype);
	});

	frappe.provide('frappe.help.help_links');

	frappe.help.help_links['data-import-tool'] = [
		{ label: 'Importing and Exporting Data', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/data/data-import-tool.html' } ];

	frappe.help.help_links['modules/Setup'] = [
		{ label: 'Users and Permissions', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/' },
		{ label: 'Settings', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/settings/' },
		{ label: 'Data Management', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/data/' },
		{ label: 'Email', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/email/' },
		{ label: 'Printing', url: 'http://frappe.github.io/erpnext/user/manual/en/setting-up/print/' } ];

	frappe.help.help_links['List/User'] = [
		{ label: 'Adding Users', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/adding-users' },
		{ label: 'Rename User', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/articles/rename-user' } ];

	frappe.help.help_links['permission-manager'] = [
		{ label: 'Role Permissions Manager', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/role-based-permissions' } ];

	frappe.help.help_links['user-permissions'] = [
		{ label: 'User Permissions', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/users-and-permissions/user-permissions' } ];

	frappe.help.help_links['Form/System Settings'] = [
		{ label: 'System Settings', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/settings/system-settings' } ];

	frappe.help.help_links['List/Email Account'] = [
		{ label: 'Email Account', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/email/email-account' } ];

	frappe.help.help_links['List/Notification'] = [
		{ label: 'Notification', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/email/email-alerts' } ];

	frappe.help.help_links['Form/Print Settings'] = [
		{ label: 'Print Settings', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/print/print-settings' } ];

	frappe.help.help_links['print-format-builder'] = [
		{ label: 'Print Format Builder', url: 'https://frappe.github.io/erpnext/user/manual/en/setting-up/print/print-format-builder' } ];

	frappe.provide('frappe.contacts');

	$.extend(frappe.contacts, {
		clear_address_and_contact: function(frm) {
			$(frm.fields_dict['address_html'].wrapper).html("");
			frm.fields_dict['contact_html'] && $(frm.fields_dict['contact_html'].wrapper).html("");
		},

		render_address_and_contact: function(frm) {
			// render address
			if(frm.fields_dict['address_html'] && "addr_list" in frm.doc.__onload) {
				$(frm.fields_dict['address_html'].wrapper)
					.html(frappe.render_template("address_list",
						frm.doc.__onload))
					.find(".btn-address").on("click", function() {
						frappe.new_doc("Address");
					});
			}

			// render contact
			if(frm.fields_dict['contact_html'] && "contact_list" in frm.doc.__onload) {
				$(frm.fields_dict['contact_html'].wrapper)
					.html(frappe.render_template("contact_list",
						frm.doc.__onload))
					.find(".btn-contact").on("click", function() {
						frappe.new_doc("Contact");
					}
				);
			}
		},
		get_last_doc: function(frm) {
			var reverse_routes = frappe.route_history.reverse();
			var last_route = reverse_routes.find(function (route) {
				return route[0] === 'Form' && route[1] !== frm.doctype
			});
			var doctype = last_route && last_route[1];
			var docname = last_route && last_route[2];

			if (last_route && last_route.length > 3)
				{ docname = last_route.slice(2).join("/"); }

			return {
				doctype: doctype,
				docname: docname
			}
		}
	});

	frappe.preview_email = function(template, args, header) {
		frappe.call({
			method: 'frappe.email.email_body.get_email_html',
			args: {
				subject: 'Test',
				template: template,
				args: args,
				header: header
			}
		}).then(function (r) {
			var html = r.message;
			html = html.replace(/embed=/, 'src=');
			var d = frappe.msgprint(html);
			d.$wrapper.find('.modal-dialog').css('width', '70%');
		});
	};

	frappe.provide('frappe.file_manager');

	frappe.file_manager = function() {
		var files_to_move = [];
		var	old_folder = null;
		var new_folder = null;

		function cut(files, old_folder_) {
			files_to_move = files;
			old_folder = old_folder_;
		}

		function paste(new_folder_) {
			return new Promise(function (resolve, reject) {
				if (files_to_move.length === 0 || !old_folder) {
					reset();
					resolve();
					return;
				}
				new_folder = new_folder_;

				frappe.call({
					method:"frappe.core.doctype.file.file.move_file",
					args: {
						file_list: files_to_move,
						new_parent: new_folder,
						old_parent: old_folder
					},
					callback: function (r) {
						reset();
						resolve(r);
					}
				}).fail(reject);
			});
		}

		function reset() {
			files_to_move = [];
			old_folder = null;
			new_folder = null;
		}

		return {
			cut: cut,
			paste: paste,
			get can_paste() {
				return Boolean(files_to_move.length > 0 && old_folder);
			},
			get old_folder() {
				return old_folder;
			},
			get files_to_move() {
				return files_to_move;
			}
		};
	}();

	frappe.templates['upload'] = '<div class="file-upload">  <div class="input-upload">   <input class="input-upload-file hidden" type="file" {{ opts.allow_multiple ? "multiple" : "" }} name="filedata" />   <button class="btn btn-primary btn-sm btn-browse">{%= __("Browse") %}</button>  </div>  <div class="uploaded-filename hidden" style="width: 100%; margin-top: 12px;"></div>  <div class="web-link-wrapper" style="width: calc(100% - 80px);">   <span class="text-muted file-upload-or">{%= __("or") %}</span>   <div class="input-link" style="width: calc(100% - 30px);">    <div class="input-group">     <div class="input-group-addon">      <span class="hidden-xs">{%= __("Web Link") %}</span>      <i class="fa fa-link visible-xs"></i>     </div>     <input class="form-control" type="text" name="file_url"      placeholder="{%= (opts.sample_url || "e.g. http://example.com/somefile.png") %}"/>    </div>   </div>  </div>  <div class="private-file hidden">   <div class="checkbox">       <label>         <input type="checkbox" checked> {{ __("Private") }}       </label>     </div>  </div> </div> ';

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var script = {
		name: 'FilePreview',
		props: ['file'],
		data: function data() {
			return {
				src: null
			}
		},
		mounted: function mounted() {
			var this$1 = this;

			if (this.is_image) {
				if (window.FileReader) {
					var fr = new FileReader();
					fr.onload = function () { return this$1.src = fr.result; };
					fr.readAsDataURL(this.file.file_obj);
				}
			}
		},
		filters: {
			file_size: function file_size(value) {
				return frappe.form.formatters.FileSize(value);
			},
			file_name: function file_name(value) {
				return frappe.utils.file_name_ellipsis(value, 9);
			}
		},
		computed: {
			uploaded: function uploaded() {
				return this.file.total && this.file.total === this.file.progress && !this.file.failed;
			},
			is_image: function is_image() {
				return this.file.file_obj.type.startsWith('image');
			}
		}
	};

	/* script */
	            var __vue_script__ = script;
	            
	/* template */
	var __vue_render__ = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "file-preview" }, [
	    _c("div", { staticClass: "file-icon border rounded" }, [
	      _vm.is_image
	        ? _c("img", {
	            staticStyle: { "object-fit": "cover", height: "100%" },
	            attrs: { src: _vm.src, alt: _vm.file.name }
	          })
	        : _c(
	            "div",
	            {
	              staticClass: "flex align-center justify-center",
	              staticStyle: { height: "100%" }
	            },
	            [
	              _c("i", {
	                staticClass: "octicon octicon-file-text text-extra-muted",
	                staticStyle: { "font-size": "5rem" }
	              })
	            ]
	          )
	    ]),
	    _vm._v(" "),
	    _c("div", { staticClass: "file-info" }, [
	      _c("div", { staticClass: "text-medium flex justify-between" }, [
	        _c("span", { attrs: { title: _vm.file.name } }, [
	          _vm.file.doc
	            ? _c(
	                "a",
	                { attrs: { href: _vm.file.doc.file_url, target: "_blank" } },
	                [
	                  _vm.file.doc.is_private
	                    ? _c("i", { staticClass: "fa fa-lock fa-fw text-warning" })
	                    : _c("i", {
	                        staticClass: "fa fa-unlock-alt fa-fw text-warning"
	                      }),
	                  _vm._v(
	                    "\n\t\t\t\t\t" +
	                      _vm._s(_vm._f("file_name")(_vm.file.name)) +
	                      "\n\t\t\t\t"
	                  )
	                ]
	              )
	            : _c("span", [
	                _c(
	                  "span",
	                  {
	                    staticClass: "cursor-pointer",
	                    attrs: { title: _vm.__("Toggle Public/Private") },
	                    on: {
	                      click: function($event) {
	                        return _vm.$emit("toggle_private")
	                      }
	                    }
	                  },
	                  [
	                    _vm.file.private
	                      ? _c("i", {
	                          staticClass: "fa fa-lock fa-fw text-warning"
	                        })
	                      : _c("i", {
	                          staticClass: "fa fa-unlock-alt fa-fw text-warning"
	                        })
	                  ]
	                ),
	                _vm._v(
	                  "\n\t\t\t\t\t" +
	                    _vm._s(_vm._f("file_name")(_vm.file.name)) +
	                    "\n\t\t\t\t"
	                )
	              ])
	        ]),
	        _vm._v(" "),
	        _vm.uploaded
	          ? _c("i", {
	              staticClass: "octicon octicon-check text-success",
	              attrs: { title: _vm.__("Uploaded successfully") }
	            })
	          : _vm._e(),
	        _vm._v(" "),
	        _vm.file.failed
	          ? _c("i", {
	              staticClass: "octicon octicon-x text-danger",
	              attrs: { title: _vm.__("Upload failed") }
	            })
	          : _vm._e()
	      ]),
	      _vm._v(" "),
	      _c("div", [
	        _c("span", { staticClass: "text-small text-muted" }, [
	          _vm._v(
	            "\n\t\t\t\t" +
	              _vm._s(_vm._f("file_size")(_vm.file.file_obj.size)) +
	              "\n\t\t\t"
	          )
	        ])
	      ])
	    ]),
	    _vm._v(" "),
	    !_vm.uploaded
	      ? _c(
	          "div",
	          {
	            staticClass: "file-remove",
	            on: {
	              click: function($event) {
	                return _vm.$emit("remove")
	              }
	            }
	          },
	          [
	            _c(
	              "svg",
	              {
	                staticClass: "feather feather-x",
	                attrs: {
	                  xmlns: "http://www.w3.org/2000/svg",
	                  width: "12",
	                  height: "12",
	                  viewBox: "0 0 24 24",
	                  fill: "none",
	                  stroke: "currentColor",
	                  "stroke-width": "2",
	                  "stroke-linecap": "round",
	                  "stroke-linejoin": "round"
	                }
	              },
	              [
	                _c("line", { attrs: { x1: "18", y1: "6", x2: "6", y2: "18" } }),
	                _c("line", { attrs: { x1: "6", y1: "6", x2: "18", y2: "18" } })
	              ]
	            )
	          ]
	        )
	      : _vm._e()
	  ])
	};
	var __vue_staticRenderFns__ = [];
	__vue_render__._withStripped = true;

	  /* style */
	  var __vue_inject_styles__ = function (inject) {
	    if (!inject) { return }
	    inject("data-v-217e62ce_0", { source: "/* palette colors*/\n.file-preview {\n  width: 25%;\n  padding-right: 15px;\n  padding-bottom: 15px;\n  position: relative;\n}\n.file-icon {\n  height: 10rem;\n  overflow: hidden;\n}\n.file-info {\n  margin-top: 5px;\n}\n.file-remove {\n  position: absolute;\n  top: -7px;\n  right: 7px;\n  background: #2e3338;\n  color: white;\n  padding: 3px;\n  border-radius: 50%;\n  display: flex;\n  cursor: pointer;\n}\n", map: {"version":3,"sources":["FilePreview.vue"],"names":[],"mappings":"AAAA,kBAAkB;AAClB;EACE,UAAU;EACV,mBAAmB;EACnB,oBAAoB;EACpB,kBAAkB;AACpB;AACA;EACE,aAAa;EACb,gBAAgB;AAClB;AACA;EACE,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,UAAU;EACV,mBAAmB;EACnB,YAAY;EACZ,YAAY;EACZ,kBAAkB;EAClB,aAAa;EACb,eAAe;AACjB","file":"FilePreview.vue","sourcesContent":["/* palette colors*/\n.file-preview {\n  width: 25%;\n  padding-right: 15px;\n  padding-bottom: 15px;\n  position: relative;\n}\n.file-icon {\n  height: 10rem;\n  overflow: hidden;\n}\n.file-info {\n  margin-top: 5px;\n}\n.file-remove {\n  position: absolute;\n  top: -7px;\n  right: 7px;\n  background: #2e3338;\n  color: white;\n  padding: 3px;\n  border-radius: 50%;\n  display: flex;\n  cursor: pointer;\n}\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__ = undefined;
	  /* module identifier */
	  var __vue_module_identifier__ = undefined;
	  /* functional template */
	  var __vue_is_functional_template__ = false;
	  /* component normalizer */
	  function __vue_normalize__(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FilePreview.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var FilePreview = __vue_normalize__(
	    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
	    __vue_inject_styles__,
	    __vue_script__,
	    __vue_scope_id__,
	    __vue_is_functional_template__,
	    __vue_module_identifier__,
	    __vue_create_injector__,
	    undefined
	  );

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var script$1 = {
		name: 'TreeNode',
		props: ['node', 'selected_node'],
		components: {
			TreeNode: function () { return frappe.ui.components.TreeNode; }
		}
	};

	/* script */
	            var __vue_script__$1 = script$1;
	            
	/* template */
	var __vue_render__$1 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    {
	      directives: [
	        {
	          name: "show",
	          rawName: "v-show",
	          value: _vm.node.filtered,
	          expression: "node.filtered"
	        }
	      ],
	      staticClass: "tree-node",
	      class: { opened: _vm.node.open }
	    },
	    [
	      _c(
	        "span",
	        {
	          staticClass: "tree-link",
	          class: { active: _vm.node.value === _vm.selected_node.value },
	          attrs: { disabled: _vm.node.fetching },
	          on: {
	            click: function($event) {
	              return _vm.$emit("node-click", _vm.node)
	            }
	          }
	        },
	        [
	          _vm.node.is_leaf
	            ? _c("i", {
	                staticClass: "octicon octicon-primitive-dot node-leaf"
	              })
	            : _c("i", {
	                staticClass: "fa fa-fw node-parent",
	                class: [_vm.node.open ? "fa-folder-open" : "fa-folder"]
	              }),
	          _vm._v(" "),
	          _c("a", { staticClass: "tree-label grey h6" }, [
	            _vm._v(_vm._s(_vm.node.label))
	          ])
	        ]
	      ),
	      _vm._v(" "),
	      _c(
	        "ul",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value: _vm.node.open,
	              expression: "node.open"
	            }
	          ],
	          staticClass: "tree-children"
	        },
	        _vm._l(_vm.node.children, function(n) {
	          return _c("TreeNode", {
	            key: n.value,
	            attrs: { node: n, selected_node: _vm.selected_node },
	            on: {
	              "node-click": function(n) {
	                return _vm.$emit("node-click", n)
	              }
	            }
	          })
	        }),
	        1
	      )
	    ]
	  )
	};
	var __vue_staticRenderFns__$1 = [];
	__vue_render__$1._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$1 = undefined;
	  /* scoped */
	  var __vue_scope_id__$1 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$1 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$1 = false;
	  /* component normalizer */
	  function __vue_normalize__$1(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/TreeNode.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    return component
	  }
	  /* style inject */
	  
	  /* style inject SSR */
	  

	  
	  var TreeNode = __vue_normalize__$1(
	    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
	    __vue_inject_styles__$1,
	    __vue_script__$1,
	    __vue_scope_id__$1,
	    __vue_is_functional_template__$1,
	    __vue_module_identifier__$1,
	    undefined,
	    undefined
	  );

	//

	var script$2 = {
		name: 'FileBrowser',
		components: {
			TreeNode: TreeNode
		},
		data: function data() {
			return {
				node: {
					label: __('Home'),
					value: 'Home',
					children: [],
					is_leaf: false,
					fetching: false,
					fetched: false,
					open: false,
					filtered: true
				},
				selected_node: {},
				filter_text: ''
			}
		},
		mounted: function mounted() {
			this.toggle_node(this.node);
		},
		methods: {
			toggle_node: function toggle_node(node) {
				if (!node.fetched && !node.is_leaf) {
					node.fetching = true;
					this.get_files_in_folder(node.value)
						.then(function (files) {
							node.open = true;
							node.children = files;
							node.fetched = true;
							node.fetching = false;
						});
				} else {
					node.open = !node.open;
					this.select_node(node);
				}
			},
			select_node: function select_node(node) {
				if (node.is_leaf) {
					this.selected_node = node;
				}
			},
			get_files_in_folder: function get_files_in_folder(folder) {
				return frappe.call('frappe.core.doctype.file.file.get_files_in_folder', { folder: folder })
					.then(function (r) {
						var files = r.message || [];
						files.sort(function (a, b) {
							if (a.is_folder && b.is_folder) {
								return a.modified < b.modified ? -1 : 1;
							}
							if (a.is_folder) {
								return -1;
							}
							if (b.is_folder) {
								return 1;
							}
							return 0;
						});
						return files.map(function (file) {
							var filename = file.file_name || file.name;
							return {
								label: frappe.utils.file_name_ellipsis(filename, 40),
								filename: filename,
								file_url: file.file_url,
								value: file.name,
								is_leaf: !file.is_folder,
								fetched: !file.is_folder, // fetched if node is leaf
								children: [],
								open: false,
								fetching: false,
								filtered: true
							}
						});
					});
			},
			apply_filter: frappe.utils.debounce(function() {
				var filter_text = this.filter_text.toLowerCase();
				var apply_filter = function (node) {
					var search_string = node.filename.toLowerCase();
					if (node.is_leaf) {
						node.filtered = search_string.includes(filter_text);
					} else {
						node.children.forEach(apply_filter);
					}
				};
				this.node.children.forEach(apply_filter);
			}, 300)
		}
	};

	/* script */
	            var __vue_script__$2 = script$2;
	            
	/* template */
	var __vue_render__$2 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "file-browser" }, [
	    _c("div", [
	      _c(
	        "a",
	        {
	          staticClass: "text-muted text-medium",
	          attrs: { href: "" },
	          on: {
	            click: function($event) {
	              $event.preventDefault();
	              return _vm.$emit("hide-browser")
	            }
	          }
	        },
	        [_vm._v(_vm._s(_vm.__(" Back to upload files")))]
	      )
	    ]),
	    _vm._v(" "),
	    _c(
	      "div",
	      { staticClass: "file-browser-list border rounded" },
	      [
	        _c("div", { staticClass: "file-filter" }, [
	          _c("input", {
	            directives: [
	              {
	                name: "model",
	                rawName: "v-model",
	                value: _vm.filter_text,
	                expression: "filter_text"
	              }
	            ],
	            staticClass: "form-control input-xs",
	            attrs: {
	              type: "text",
	              placeholder: _vm.__("Search by filename or extension")
	            },
	            domProps: { value: _vm.filter_text },
	            on: {
	              input: [
	                function($event) {
	                  if ($event.target.composing) {
	                    return
	                  }
	                  _vm.filter_text = $event.target.value;
	                },
	                _vm.apply_filter
	              ]
	            }
	          })
	        ]),
	        _vm._v(" "),
	        _c("TreeNode", {
	          staticClass: "tree with-skeleton",
	          attrs: { node: _vm.node, selected_node: _vm.selected_node },
	          on: {
	            "node-click": function(n) {
	              return _vm.toggle_node(n)
	            }
	          }
	        })
	      ],
	      1
	    )
	  ])
	};
	var __vue_staticRenderFns__$2 = [];
	__vue_render__$2._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$2 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-7e670395_0", { source: "\n.file-browser-list {\n\theight: 300px;\n\toverflow: auto;\n\tmargin-top: 10px;\n}\n.file-filter {\n\tpadding: 15px 15px 0;\n}\n", map: {"version":3,"sources":["/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FileBrowser.vue"],"names":[],"mappings":";AA8HA;CACA,aAAA;CACA,cAAA;CACA,gBAAA;AACA;AAEA;CACA,oBAAA;AACA","file":"FileBrowser.vue","sourcesContent":["<template>\n\t<div class=\"file-browser\">\n\t\t<div>\n\t\t\t<a\n\t\t\t\thref=\"\"\n\t\t\t\tclass=\"text-muted text-medium\"\n\t\t\t\t@click.prevent=\"$emit('hide-browser')\"\n\t\t\t>{{ __(' Back to upload files') }}</a>\n\t\t</div>\n\t\t<div class=\"file-browser-list border rounded\">\n\t\t\t<div class=\"file-filter\">\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tclass=\"form-control input-xs\"\n\t\t\t\t\t:placeholder=\"__('Search by filename or extension')\"\n\t\t\t\t\tv-model=\"filter_text\"\n\t\t\t\t\t@input=\"apply_filter\"\n\t\t\t\t>\n\t\t\t</div>\n\t\t\t<TreeNode\n\t\t\t\tclass=\"tree with-skeleton\"\n\t\t\t\t:node=\"node\"\n\t\t\t\t:selected_node=\"selected_node\"\n\t\t\t\t@node-click=\"n => toggle_node(n)\"\n\t\t\t/>\n\t\t</div>\n\t</div>\n</template>\n<script>\nimport TreeNode from \"./TreeNode.vue\";\n\nexport default {\n\tname: 'FileBrowser',\n\tcomponents: {\n\t\tTreeNode\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tnode: {\n\t\t\t\tlabel: __('Home'),\n\t\t\t\tvalue: 'Home',\n\t\t\t\tchildren: [],\n\t\t\t\tis_leaf: false,\n\t\t\t\tfetching: false,\n\t\t\t\tfetched: false,\n\t\t\t\topen: false,\n\t\t\t\tfiltered: true\n\t\t\t},\n\t\t\tselected_node: {},\n\t\t\tfilter_text: ''\n\t\t}\n\t},\n\tmounted() {\n\t\tthis.toggle_node(this.node);\n\t},\n\tmethods: {\n\t\ttoggle_node(node) {\n\t\t\tif (!node.fetched && !node.is_leaf) {\n\t\t\t\tnode.fetching = true;\n\t\t\t\tthis.get_files_in_folder(node.value)\n\t\t\t\t\t.then(files => {\n\t\t\t\t\t\tnode.open = true;\n\t\t\t\t\t\tnode.children = files;\n\t\t\t\t\t\tnode.fetched = true;\n\t\t\t\t\t\tnode.fetching = false;\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tnode.open = !node.open;\n\t\t\t\tthis.select_node(node);\n\t\t\t}\n\t\t},\n\t\tselect_node(node) {\n\t\t\tif (node.is_leaf) {\n\t\t\t\tthis.selected_node = node;\n\t\t\t}\n\t\t},\n\t\tget_files_in_folder(folder) {\n\t\t\treturn frappe.call('frappe.core.doctype.file.file.get_files_in_folder', { folder })\n\t\t\t\t.then(r => {\n\t\t\t\t\tlet files = r.message || [];\n\t\t\t\t\tfiles.sort((a, b) => {\n\t\t\t\t\t\tif (a.is_folder && b.is_folder) {\n\t\t\t\t\t\t\treturn a.modified < b.modified ? -1 : 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a.is_folder) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (b.is_folder) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t});\n\t\t\t\t\treturn files.map(file => {\n\t\t\t\t\t\tlet filename = file.file_name || file.name;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tlabel: frappe.utils.file_name_ellipsis(filename, 40),\n\t\t\t\t\t\t\tfilename: filename,\n\t\t\t\t\t\t\tfile_url: file.file_url,\n\t\t\t\t\t\t\tvalue: file.name,\n\t\t\t\t\t\t\tis_leaf: !file.is_folder,\n\t\t\t\t\t\t\tfetched: !file.is_folder, // fetched if node is leaf\n\t\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\t\topen: false,\n\t\t\t\t\t\t\tfetching: false,\n\t\t\t\t\t\t\tfiltered: true\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t},\n\t\tapply_filter: frappe.utils.debounce(function() {\n\t\t\tlet filter_text = this.filter_text.toLowerCase();\n\t\t\tlet apply_filter = (node) => {\n\t\t\t\tlet search_string = node.filename.toLowerCase();\n\t\t\t\tif (node.is_leaf) {\n\t\t\t\t\tnode.filtered = search_string.includes(filter_text);\n\t\t\t\t} else {\n\t\t\t\t\tnode.children.forEach(apply_filter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.node.children.forEach(apply_filter);\n\t\t}, 300)\n\t}\n}\n</script>\n\n<style>\n.file-browser-list {\n\theight: 300px;\n\toverflow: auto;\n\tmargin-top: 10px;\n}\n\n.file-filter {\n\tpadding: 15px 15px 0;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$2 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$2 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$2 = false;
	  /* component normalizer */
	  function __vue_normalize__$2(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FileBrowser.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$1() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var FileBrowser = __vue_normalize__$2(
	    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
	    __vue_inject_styles__$2,
	    __vue_script__$2,
	    __vue_scope_id__$2,
	    __vue_is_functional_template__$2,
	    __vue_module_identifier__$2,
	    __vue_create_injector__$1,
	    undefined
	  );

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var script$3 = {
		name: 'WebLink',
		data: function data() {
			return {
				url: '',
			}
		}
	};

	/* script */
	            var __vue_script__$3 = script$3;
	            
	/* template */
	var __vue_render__$3 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "file-web-link margin-bottom" }, [
	    _c(
	      "a",
	      {
	        staticClass: "text-muted text-medium",
	        attrs: { href: "" },
	        on: {
	          click: function($event) {
	            $event.preventDefault();
	            return _vm.$emit("hide-web-link")
	          }
	        }
	      },
	      [_vm._v("\n\t\t" + _vm._s(_vm.__(" Back to upload files")) + "\n\t")]
	    ),
	    _vm._v(" "),
	    _c("div", { staticClass: "input-group" }, [
	      _c("div", { staticClass: "input-group-addon" }, [
	        _c("span", { staticClass: "text-muted text-medium" }, [
	          _vm._v(_vm._s(_vm.__("Web Link")))
	        ])
	      ]),
	      _vm._v(" "),
	      _c("input", {
	        directives: [
	          {
	            name: "model",
	            rawName: "v-model",
	            value: _vm.url,
	            expression: "url"
	          }
	        ],
	        staticClass: "form-control",
	        attrs: { type: "text", placeholder: _vm.__("Attach a web link") },
	        domProps: { value: _vm.url },
	        on: {
	          input: function($event) {
	            if ($event.target.composing) {
	              return
	            }
	            _vm.url = $event.target.value;
	          }
	        }
	      })
	    ])
	  ])
	};
	var __vue_staticRenderFns__$3 = [];
	__vue_render__$3._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$3 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-39de550b_0", { source: "\n.file-web-link .input-group {\n\tmargin-top: 10px;\n}\n", map: {"version":3,"sources":["/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/WebLink.vue"],"names":[],"mappings":";AAgCA;CACA,gBAAA;AACA","file":"WebLink.vue","sourcesContent":["<template>\n\t<div class=\"file-web-link margin-bottom\">\n\t\t<a href class=\"text-muted text-medium\"\n\t\t\t@click.prevent=\"$emit('hide-web-link')\"\n\t\t>\n\t\t\t{{ __(' Back to upload files') }}\n\t\t</a>\n\t\t<div class=\"input-group\">\n\t\t\t<div class=\"input-group-addon\">\n\t\t\t\t<span class=\"text-muted text-medium\">{{ __('Web Link') }}</span>\n\t\t\t</div>\n\t\t\t<input\n\t\t\t\ttype=\"text\"\n\t\t\t\tclass=\"form-control\"\n\t\t\t\t:placeholder=\"__('Attach a web link')\"\n\t\t\t\tv-model=\"url\"\n\t\t\t>\n\t\t</div>\n\t</div>\n</template>\n<script>\nexport default {\n\tname: 'WebLink',\n\tdata() {\n\t\treturn {\n\t\t\turl: '',\n\t\t}\n\t}\n}\n</script>\n\n<style>\n.file-web-link .input-group {\n\tmargin-top: 10px;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$3 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$3 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$3 = false;
	  /* component normalizer */
	  function __vue_normalize__$3(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/WebLink.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$2() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var WebLink = __vue_normalize__$3(
	    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
	    __vue_inject_styles__$3,
	    __vue_script__$3,
	    __vue_scope_id__$3,
	    __vue_is_functional_template__$3,
	    __vue_module_identifier__$3,
	    __vue_create_injector__$2,
	    undefined
	  );

	//

	var script$4 = {
		name: 'FileUploader',
		props: {
			show_upload_button: {
				default: true
			},
			allow_multiple: {
				default: true
			},
			as_dataurl: {
				default: false
			},
			doctype: {
				default: null
			},
			docname: {
				default: null
			},
			folder: {
				default: 'Home'
			},
			method: {
				default: null
			},
			on_success: {
				default: null
			},
			restrictions: {
				default: function () { return ({
					max_file_size: null, // 2048 -> 2KB
					max_number_of_files: null,
					allowed_file_types: [] // ['image/*', 'video/*', '.jpg', '.gif', '.pdf']
				}); }
			},
			upload_notes: {
				default: null // "Images or video, upto 2MB"
			}
		},
		components: {
			FilePreview: FilePreview,
			FileBrowser: FileBrowser,
			WebLink: WebLink
		},
		data: function data() {
			return {
				files: [],
				is_dragging: false,
				currently_uploading: -1,
				show_file_browser: false,
				show_web_link: false,
			}
		},
		watch: {
			files: function files(newvalue, oldvalue) {
				if (!this.allow_multiple && newvalue.length > 1) {
					this.files = [newvalue[newvalue.length - 1]];
				}
			}
		},
		computed: {
			upload_complete: function upload_complete() {
				return this.files.length > 0
					&& this.files.every(
						function (file) { return file.total !== 0 && file.progress === file.total; });
			},
		},
		methods: {
			dragover: function dragover() {
				this.is_dragging = true;
			},
			dragleave: function dragleave() {
				this.is_dragging = false;
			},
			dropfiles: function dropfiles(e) {
				this.is_dragging = false;
				this.add_files(e.dataTransfer.files);
			},
			browse_files: function browse_files() {
				this.$refs.file_input.click();
			},
			on_file_input: function on_file_input(e) {
				this.add_files(this.$refs.file_input.files);
			},
			remove_file: function remove_file(i) {
				this.files = this.files.filter(function (file, j) { return i !== j; });
			},
			toggle_private: function toggle_private(i) {
				this.files[i].private = !this.files[i].private;
			},
			toggle_all_private: function toggle_all_private(flag) {
				this.files = this.files.map(function (file) {
					file.private = flag;
					return file;
				});
			},
			add_files: function add_files(file_array) {
				var files = Array.from(file_array)
					.filter(this.check_restrictions)
					.map(function (file) {
						var is_image = file.type.startsWith('image');
						return {
							file_obj: file,
							name: file.name,
							doc: null,
							progress: 0,
							total: 0,
							failed: false,
							uploading: false,
							private: !is_image
						}
					});
				this.files = this.files.concat(files);
			},
			check_restrictions: function check_restrictions(file) {
				var ref = this.restrictions;
				var max_file_size = ref.max_file_size;
				var allowed_file_types = ref.allowed_file_types;

				var mime_type = file.type;
				var extension = '.' + file.name.split('.').pop();

				var is_correct_type = true;
				var valid_file_size = true;

				if (allowed_file_types.length) {
					is_correct_type = allowed_file_types.some(function (type) {
						// is this is a mime-type
						if (type.includes('/')) {
							if (!file.type) { return false; }
							return file.type.match(type);
						}

						// otherwise this is likely an extension
						if (type[0] === '.') {
							return file.name.endsWith(type);
						}
						return false;
					});
				}

				if (max_file_size && file.size != null) {
					valid_file_size = file.size < max_file_size;
				}

				if (!is_correct_type) {
					console.warn('File skipped because of invalid file type', file);
				}
				if (!valid_file_size) {
					console.warn('File skipped because of invalid file size', file.size, file);
				}

				return is_correct_type && valid_file_size;
			},
			upload_files: function upload_files() {
				var this$1 = this;

				if (this.show_file_browser) {
					return this.upload_via_file_browser();
				}
				if (this.show_web_link) {
					return this.upload_via_web_link();
				}
				if (this.as_dataurl) {
					return this.return_as_dataurl();
				}
				return frappe.run_serially(
					this.files.map(
						function (file, i) { return function () { return this$1.upload_file(file, i); }; }
					)
				);
			},
			upload_via_file_browser: function upload_via_file_browser() {
				var selected_file = this.$refs.file_browser.selected_node;
				if (!selected_file.value) {
					frappe.msgprint(__('Click on a file to select it.'));
					return Promise.reject();
				}

				return this.upload_file({
					file_url: selected_file.file_url
				});
			},
			upload_via_web_link: function upload_via_web_link() {
				var file_url = this.$refs.web_link.url;
				if (!file_url) {
					frappe.msgprint(__('Invalid URL'));
					return Promise.reject();
				}

				return this.upload_file({
					file_url: file_url
				});
			},
			return_as_dataurl: function return_as_dataurl() {
				var this$1 = this;

				var promises = this.files.map(function (file) { return frappe.dom.file_to_base64(file.file_obj)
						.then(function (dataurl) {
							file.dataurl = dataurl;
							this$1.on_success && this$1.on_success(file);
						}); }
				);
				return Promise.all(promises);
			},
			upload_file: function upload_file(file, i) {
				var this$1 = this;

				this.currently_uploading = i;

				return new Promise(function (resolve, reject) {
					var xhr = new XMLHttpRequest();
					xhr.upload.addEventListener('loadstart', function (e) {
						file.uploading = true;
					});
					xhr.upload.addEventListener('progress', function (e) {
						if (e.lengthComputable) {
							file.progress = e.loaded;
							file.total = e.total;
						}
					});
					xhr.upload.addEventListener('load', function (e) {
						file.uploading = false;
						resolve();
					});
					xhr.addEventListener('error', function (e) {
						file.failed = true;
						reject();
					});
					xhr.onreadystatechange = function () {
						if (xhr.readyState == XMLHttpRequest.DONE) {
							if (xhr.status === 200) {
								var r = null;
								var file_doc = null;
								try {
									r = JSON.parse(xhr.responseText);
									if (r.message.doctype === 'File') {
										file_doc = r.message;
									}
								} catch(e) {
									r = xhr.responseText;
								}

								file.doc = file_doc;

								if (this$1.on_success) {
									this$1.on_success(file_doc, r);
								}
							} else {
								file.failed = true;
								var error = null;
								try {
									error = JSON.parse(xhr.responseText);
								} catch(e) {
									// pass
								}
								frappe.request.cleanup({}, error);
							}
						}
					};
					xhr.open('POST', '/api/method/upload_file', true);
					xhr.setRequestHeader('Accept', 'application/json');
					xhr.setRequestHeader('X-Frappe-CSRF-Token', frappe.csrf_token);

					var form_data = new FormData();
					if (file.file_obj) {
						form_data.append('file', file.file_obj, file.name);
					}
					form_data.append('is_private', +file.private);
					form_data.append('folder', this$1.folder);

					if (file.file_url) {
						form_data.append('file_url', file.file_url);
					}

					if (this$1.doctype && this$1.docname) {
						form_data.append('doctype', this$1.doctype);
						form_data.append('docname', this$1.docname);
					}

					if (this$1.method) {
						form_data.append('method', this$1.method);
					}

					xhr.send(form_data);
				});
			}
		}
	};

	/* script */
	            var __vue_script__$4 = script$4;
	            
	/* template */
	var __vue_render__$4 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    {
	      staticClass: "file-uploader",
	      on: {
	        dragover: function($event) {
	          $event.preventDefault();
	          return _vm.dragover($event)
	        },
	        dragleave: function($event) {
	          $event.preventDefault();
	          return _vm.dragleave($event)
	        },
	        drop: function($event) {
	          $event.preventDefault();
	          return _vm.dropfiles($event)
	        }
	      }
	    },
	    [
	      _c(
	        "div",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value:
	                _vm.files.length === 0 &&
	                !_vm.show_file_browser &&
	                !_vm.show_web_link,
	              expression:
	                "files.length === 0 && !show_file_browser && !show_web_link"
	            }
	          ],
	          staticClass:
	            "file-upload-area padding border rounded text-center cursor-pointer flex align-center justify-center",
	          on: { click: _vm.browse_files }
	        },
	        [
	          !_vm.is_dragging
	            ? _c("div", [
	                _c("div", [
	                  _vm._v(
	                    "\n\t\t\t\t" +
	                      _vm._s(_vm.__("Drag and drop files, ")) +
	                      "\n\t\t\t\t"
	                  ),
	                  _c("label", { staticStyle: { margin: "0" } }, [
	                    _c(
	                      "a",
	                      {
	                        staticClass: "text-primary",
	                        attrs: { href: "#" },
	                        on: {
	                          click: function($event) {
	                            $event.preventDefault();
	                          }
	                        }
	                      },
	                      [_vm._v(_vm._s(_vm.__("browse,")))]
	                    ),
	                    _vm._v(" "),
	                    _c("input", {
	                      ref: "file_input",
	                      staticClass: "hidden",
	                      attrs: {
	                        type: "file",
	                        multiple: _vm.allow_multiple,
	                        accept: _vm.restrictions.allowed_file_types.join(", ")
	                      },
	                      on: { change: _vm.on_file_input }
	                    })
	                  ]),
	                  _vm._v(
	                    "\n\t\t\t\t" + _vm._s(_vm.__("choose an")) + "\n\t\t\t\t"
	                  ),
	                  _c(
	                    "a",
	                    {
	                      staticClass: "text-primary bold",
	                      attrs: { href: "#" },
	                      on: {
	                        click: function($event) {
	                          $event.stopPropagation();
	                          $event.preventDefault();
	                          _vm.show_file_browser = true;
	                        }
	                      }
	                    },
	                    [
	                      _vm._v(
	                        "\n\t\t\t\t\t" +
	                          _vm._s(_vm.__("uploaded file")) +
	                          "\n\t\t\t\t"
	                      )
	                    ]
	                  ),
	                  _vm._v(
	                    "\n\t\t\t\t" + _vm._s(_vm.__("or attach a")) + "\n\t\t\t\t"
	                  ),
	                  _c(
	                    "a",
	                    {
	                      staticClass: "text-primary bold",
	                      attrs: { href: "" },
	                      on: {
	                        click: function($event) {
	                          $event.stopPropagation();
	                          $event.preventDefault();
	                          _vm.show_web_link = true;
	                        }
	                      }
	                    },
	                    [
	                      _vm._v(
	                        "\n\t\t\t\t\t" +
	                          _vm._s(_vm.__("web link")) +
	                          "\n\t\t\t\t"
	                      )
	                    ]
	                  )
	                ]),
	                _vm._v(" "),
	                _c("div", { staticClass: "text-muted text-medium" }, [
	                  _vm._v("\n\t\t\t\t" + _vm._s(_vm.upload_notes) + "\n\t\t\t")
	                ])
	              ])
	            : _c("div", [
	                _vm._v(
	                  "\n\t\t\t" + _vm._s(_vm.__("Drop files here")) + "\n\t\t"
	                )
	              ])
	        ]
	      ),
	      _vm._v(" "),
	      _c(
	        "div",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value:
	                _vm.files.length &&
	                !_vm.show_file_browser &&
	                !_vm.show_web_link,
	              expression: "files.length && !show_file_browser && !show_web_link"
	            }
	          ],
	          staticClass: "file-preview-area"
	        },
	        [
	          !_vm.upload_complete
	            ? _c("div", { staticClass: "margin-bottom" }, [
	                _c("label", [
	                  _c("input", {
	                    staticClass: "input-with-feedback",
	                    attrs: { type: "checkbox" },
	                    on: {
	                      change: function(e) {
	                        return _vm.toggle_all_private(e.target.checked)
	                      }
	                    }
	                  }),
	                  _vm._v(" "),
	                  _c(
	                    "span",
	                    {
	                      staticClass: "text-medium",
	                      staticStyle: { "font-weight": "normal" }
	                    },
	                    [
	                      _vm._v(
	                        "\n\t\t\t\t\t" +
	                          _vm._s(_vm.__("Make all attachments private")) +
	                          "\n\t\t\t\t"
	                      )
	                    ]
	                  )
	                ])
	              ])
	            : _vm._e(),
	          _vm._v(" "),
	          _c(
	            "div",
	            { staticClass: "flex flex-wrap" },
	            _vm._l(_vm.files, function(file, i) {
	              return _c("FilePreview", {
	                key: file.name,
	                attrs: { file: file },
	                on: {
	                  remove: function($event) {
	                    return _vm.remove_file(i)
	                  },
	                  toggle_private: function($event) {
	                    return _vm.toggle_private(i)
	                  }
	                }
	              })
	            }),
	            1
	          ),
	          _vm._v(" "),
	          _vm.show_upload_button && _vm.currently_uploading === -1
	            ? _c("div", { staticClass: "flex align-center" }, [
	                _c(
	                  "button",
	                  {
	                    staticClass: "btn btn-primary btn-sm margin-right",
	                    on: { click: _vm.upload_files }
	                  },
	                  [
	                    _vm.files.length === 1
	                      ? _c("span", [
	                          _vm._v(
	                            "\n\t\t\t\t\t" +
	                              _vm._s(_vm.__("Upload file")) +
	                              "\n\t\t\t\t"
	                          )
	                        ])
	                      : _c("span", [
	                          _vm._v(
	                            "\n\t\t\t\t\t" +
	                              _vm._s(
	                                _vm.__("Upload {0} files", [_vm.files.length])
	                              ) +
	                              "\n\t\t\t\t"
	                          )
	                        ])
	                  ]
	                ),
	                _vm._v(" "),
	                _c("div", { staticClass: "text-muted text-medium" }, [
	                  _vm._v(
	                    "\n\t\t\t\t" +
	                      _vm._s(
	                        _vm.__(
	                          "Click on the lock icon to toggle public/private"
	                        )
	                      ) +
	                      "\n\t\t\t"
	                  )
	                ])
	              ])
	            : _vm._e()
	        ]
	      ),
	      _vm._v(" "),
	      _vm.currently_uploading !== -1 &&
	      !_vm.upload_complete &&
	      !_vm.show_file_browser &&
	      !_vm.show_web_link
	        ? _c(
	            "div",
	            { staticClass: "upload-progress" },
	            [
	              _c("span", {
	                staticClass: "text-medium",
	                domProps: {
	                  innerHTML: _vm._s(
	                    _vm.__("Uploading {0} of {1}", [
	                      String(_vm.currently_uploading + 1).bold(),
	                      String(_vm.files.length).bold()
	                    ])
	                  )
	                }
	              }),
	              _vm._v(" "),
	              _vm._l(_vm.files, function(file, i) {
	                return _c(
	                  "div",
	                  {
	                    directives: [
	                      {
	                        name: "show",
	                        rawName: "v-show",
	                        value: _vm.currently_uploading === i,
	                        expression: "currently_uploading===i"
	                      }
	                    ],
	                    key: i,
	                    staticClass: "progress"
	                  },
	                  [
	                    _c("div", {
	                      staticClass: "progress-bar",
	                      class: [
	                        file.total - file.progress < 20
	                          ? "progress-bar-success"
	                          : "progress-bar-warning"
	                      ],
	                      style: {
	                        width: (file.progress * 100) / file.total + "%"
	                      },
	                      attrs: {
	                        role: "progressbar",
	                        "aria-valuenow": (file.progress * 100) / file.total,
	                        "aria-valuemin": "0",
	                        "aria-valuemax": "100"
	                      }
	                    })
	                  ]
	                )
	              })
	            ],
	            2
	          )
	        : _vm._e(),
	      _vm._v(" "),
	      _vm.show_file_browser
	        ? _c("FileBrowser", {
	            ref: "file_browser",
	            on: {
	              "hide-browser": function($event) {
	                _vm.show_file_browser = false;
	              }
	            }
	          })
	        : _vm._e(),
	      _vm._v(" "),
	      _vm.show_web_link
	        ? _c("WebLink", {
	            ref: "web_link",
	            on: {
	              "hide-web-link": function($event) {
	                _vm.show_web_link = false;
	              }
	            }
	          })
	        : _vm._e()
	    ],
	    1
	  )
	};
	var __vue_staticRenderFns__$4 = [];
	__vue_render__$4._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$4 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-92134840_0", { source: "\n.file-upload-area {\n\tmin-height: 100px;\n}\n", map: {"version":3,"sources":["/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FileUploader.vue"],"names":[],"mappings":";AAuZA;CACA,iBAAA;AACA","file":"FileUploader.vue","sourcesContent":["<template>\n\t<div class=\"file-uploader\"\n\t\t@dragover.prevent=\"dragover\"\n\t\t@dragleave.prevent=\"dragleave\"\n\t\t@drop.prevent=\"dropfiles\"\n\t>\n\t\t<div\n\t\t\tclass=\"file-upload-area padding border rounded text-center cursor-pointer flex align-center justify-center\"\n\t\t\t@click=\"browse_files\"\n\t\t\tv-show=\"files.length === 0 && !show_file_browser && !show_web_link\"\n\t\t>\n\t\t\t<div v-if=\"!is_dragging\">\n\t\t\t\t<div>\n\t\t\t\t\t{{ __('Drag and drop files, ') }}\n\t\t\t\t\t<label style=\"margin: 0\">\n\t\t\t\t\t\t<a href=\"#\" class=\"text-primary\" @click.prevent>{{ __('browse,') }}</a>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype=\"file\"\n\t\t\t\t\t\t\tclass=\"hidden\"\n\t\t\t\t\t\t\tref=\"file_input\"\n\t\t\t\t\t\t\t@change=\"on_file_input\"\n\t\t\t\t\t\t\t:multiple=\"allow_multiple\"\n\t\t\t\t\t\t\t:accept=\"restrictions.allowed_file_types.join(', ')\"\n\t\t\t\t\t\t>\n\t\t\t\t\t</label>\n\t\t\t\t\t{{ __('choose an') }}\n\t\t\t\t\t<a href=\"#\" class=\"text-primary bold\"\n\t\t\t\t\t\t@click.stop.prevent=\"show_file_browser = true\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{{ __('uploaded file') }}\n\t\t\t\t\t</a>\n\t\t\t\t\t{{ __('or attach a') }}\n\t\t\t\t\t<a class=\"text-primary bold\" href\n\t\t\t\t\t\t@click.stop.prevent=\"show_web_link = true\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{{ __('web link') }}\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"text-muted text-medium\">\n\t\t\t\t\t{{ upload_notes }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div v-else>\n\t\t\t\t{{ __('Drop files here') }}\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"file-preview-area\" v-show=\"files.length && !show_file_browser && !show_web_link\">\n\t\t\t<div class=\"margin-bottom\" v-if=\"!upload_complete\">\n\t\t\t\t<label>\n\t\t\t\t\t<input type=\"checkbox\" class=\"input-with-feedback\" @change=\"e => toggle_all_private(e.target.checked)\">\n\t\t\t\t\t<span class=\"text-medium\" style=\"font-weight: normal;\">\n\t\t\t\t\t\t{{ __('Make all attachments private') }}\n\t\t\t\t\t</span>\n\t\t\t\t</label>\n\t\t\t</div>\n\t\t\t<div class=\"flex flex-wrap\">\n\t\t\t\t<FilePreview\n\t\t\t\t\tv-for=\"(file, i) in files\"\n\t\t\t\t\t:key=\"file.name\"\n\t\t\t\t\t:file=\"file\"\n\t\t\t\t\t@remove=\"remove_file(i)\"\n\t\t\t\t\t@toggle_private=\"toggle_private(i)\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t\t<div class=\"flex align-center\" v-if=\"show_upload_button && currently_uploading === -1\">\n\t\t\t\t<button\n\t\t\t\t\tclass=\"btn btn-primary btn-sm margin-right\"\n\t\t\t\t\t@click=\"upload_files\"\n\t\t\t\t>\n\t\t\t\t\t<span v-if=\"files.length === 1\">\n\t\t\t\t\t\t{{ __('Upload file') }}\n\t\t\t\t\t</span>\n\t\t\t\t\t<span v-else>\n\t\t\t\t\t\t{{ __('Upload {0} files', [files.length]) }}\n\t\t\t\t\t</span>\n\t\t\t\t</button>\n\t\t\t\t<div class=\"text-muted text-medium\">\n\t\t\t\t\t{{ __('Click on the lock icon to toggle public/private') }}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"upload-progress\" v-if=\"currently_uploading !== -1 && !upload_complete && !show_file_browser && !show_web_link\">\n\t\t\t<span\n\t\t\t\tclass=\"text-medium\"\n\t\t\t\tv-html=\"__('Uploading {0} of {1}', [String(currently_uploading + 1).bold(), String(files.length).bold()])\"\n\t\t\t>\n\t\t\t</span>\n\t\t\t<div\n\t\t\t\tclass=\"progress\"\n\t\t\t\t:key=\"i\"\n\t\t\t\tv-for=\"(file, i) in files\"\n\t\t\t\tv-show=\"currently_uploading===i\"\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tclass=\"progress-bar\"\n\t\t\t\t\t:class=\"[file.total - file.progress < 20 ? 'progress-bar-success' : 'progress-bar-warning']\"\n\t\t\t\t\trole=\"progressbar\"\n\t\t\t\t\t:aria-valuenow=\"(file.progress * 100 / file.total)\"\n\t\t\t\t\taria-valuemin=\"0\"\n\t\t\t\t\taria-valuemax=\"100\"\n\t\t\t\t\t:style=\"{'width': (file.progress * 100 / file.total) + '%' }\"\n\t\t\t\t>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<FileBrowser\n\t\t\tref=\"file_browser\"\n\t\t\tv-if=\"show_file_browser\"\n\t\t\t@hide-browser=\"show_file_browser = false\"\n\t\t/>\n\t\t<WebLink\n\t\t\tref=\"web_link\"\n\t\t\tv-if=\"show_web_link\"\n\t\t\t@hide-web-link=\"show_web_link = false\"\n\t\t/>\n\t</div>\n</template>\n\n<script>\nimport FilePreview from './FilePreview.vue';\nimport FileBrowser from './FileBrowser.vue';\nimport WebLink from './WebLink.vue';\n\nexport default {\n\tname: 'FileUploader',\n\tprops: {\n\t\tshow_upload_button: {\n\t\t\tdefault: true\n\t\t},\n\t\tallow_multiple: {\n\t\t\tdefault: true\n\t\t},\n\t\tas_dataurl: {\n\t\t\tdefault: false\n\t\t},\n\t\tdoctype: {\n\t\t\tdefault: null\n\t\t},\n\t\tdocname: {\n\t\t\tdefault: null\n\t\t},\n\t\tfolder: {\n\t\t\tdefault: 'Home'\n\t\t},\n\t\tmethod: {\n\t\t\tdefault: null\n\t\t},\n\t\ton_success: {\n\t\t\tdefault: null\n\t\t},\n\t\trestrictions: {\n\t\t\tdefault: () => ({\n\t\t\t\tmax_file_size: null, // 2048 -> 2KB\n\t\t\t\tmax_number_of_files: null,\n\t\t\t\tallowed_file_types: [] // ['image/*', 'video/*', '.jpg', '.gif', '.pdf']\n\t\t\t})\n\t\t},\n\t\tupload_notes: {\n\t\t\tdefault: null // \"Images or video, upto 2MB\"\n\t\t}\n\t},\n\tcomponents: {\n\t\tFilePreview,\n\t\tFileBrowser,\n\t\tWebLink\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tfiles: [],\n\t\t\tis_dragging: false,\n\t\t\tcurrently_uploading: -1,\n\t\t\tshow_file_browser: false,\n\t\t\tshow_web_link: false,\n\t\t}\n\t},\n\twatch: {\n\t\tfiles(newvalue, oldvalue) {\n\t\t\tif (!this.allow_multiple && newvalue.length > 1) {\n\t\t\t\tthis.files = [newvalue[newvalue.length - 1]];\n\t\t\t}\n\t\t}\n\t},\n\tcomputed: {\n\t\tupload_complete() {\n\t\t\treturn this.files.length > 0\n\t\t\t\t&& this.files.every(\n\t\t\t\t\tfile => file.total !== 0 && file.progress === file.total);\n\t\t},\n\t},\n\tmethods: {\n\t\tdragover() {\n\t\t\tthis.is_dragging = true;\n\t\t},\n\t\tdragleave() {\n\t\t\tthis.is_dragging = false;\n\t\t},\n\t\tdropfiles(e) {\n\t\t\tthis.is_dragging = false;\n\t\t\tthis.add_files(e.dataTransfer.files);\n\t\t},\n\t\tbrowse_files() {\n\t\t\tthis.$refs.file_input.click();\n\t\t},\n\t\ton_file_input(e) {\n\t\t\tthis.add_files(this.$refs.file_input.files);\n\t\t},\n\t\tremove_file(i) {\n\t\t\tthis.files = this.files.filter((file, j) => i !== j);\n\t\t},\n\t\ttoggle_private(i) {\n\t\t\tthis.files[i].private = !this.files[i].private;\n\t\t},\n\t\ttoggle_all_private(flag) {\n\t\t\tthis.files = this.files.map(file => {\n\t\t\t\tfile.private = flag;\n\t\t\t\treturn file;\n\t\t\t});\n\t\t},\n\t\tadd_files(file_array) {\n\t\t\tlet files = Array.from(file_array)\n\t\t\t\t.filter(this.check_restrictions)\n\t\t\t\t.map(file => {\n\t\t\t\t\tlet is_image = file.type.startsWith('image');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfile_obj: file,\n\t\t\t\t\t\tname: file.name,\n\t\t\t\t\t\tdoc: null,\n\t\t\t\t\t\tprogress: 0,\n\t\t\t\t\t\ttotal: 0,\n\t\t\t\t\t\tfailed: false,\n\t\t\t\t\t\tuploading: false,\n\t\t\t\t\t\tprivate: !is_image\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tthis.files = this.files.concat(files);\n\t\t},\n\t\tcheck_restrictions(file) {\n\t\t\tlet { max_file_size, allowed_file_types } = this.restrictions;\n\n\t\t\tlet mime_type = file.type;\n\t\t\tlet extension = '.' + file.name.split('.').pop();\n\n\t\t\tlet is_correct_type = true;\n\t\t\tlet valid_file_size = true;\n\n\t\t\tif (allowed_file_types.length) {\n\t\t\t\tis_correct_type = allowed_file_types.some((type) => {\n\t\t\t\t\t// is this is a mime-type\n\t\t\t\t\tif (type.includes('/')) {\n\t\t\t\t\t\tif (!file.type) return false;\n\t\t\t\t\t\treturn file.type.match(type);\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise this is likely an extension\n\t\t\t\t\tif (type[0] === '.') {\n\t\t\t\t\t\treturn file.name.endsWith(type);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (max_file_size && file.size != null) {\n\t\t\t\tvalid_file_size = file.size < max_file_size;\n\t\t\t}\n\n\t\t\tif (!is_correct_type) {\n\t\t\t\tconsole.warn('File skipped because of invalid file type', file);\n\t\t\t}\n\t\t\tif (!valid_file_size) {\n\t\t\t\tconsole.warn('File skipped because of invalid file size', file.size, file);\n\t\t\t}\n\n\t\t\treturn is_correct_type && valid_file_size;\n\t\t},\n\t\tupload_files() {\n\t\t\tif (this.show_file_browser) {\n\t\t\t\treturn this.upload_via_file_browser();\n\t\t\t}\n\t\t\tif (this.show_web_link) {\n\t\t\t\treturn this.upload_via_web_link();\n\t\t\t}\n\t\t\tif (this.as_dataurl) {\n\t\t\t\treturn this.return_as_dataurl();\n\t\t\t}\n\t\t\treturn frappe.run_serially(\n\t\t\t\tthis.files.map(\n\t\t\t\t\t(file, i) =>\n\t\t\t\t\t\t() => this.upload_file(file, i)\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\tupload_via_file_browser() {\n\t\t\tlet selected_file = this.$refs.file_browser.selected_node;\n\t\t\tif (!selected_file.value) {\n\t\t\t\tfrappe.msgprint(__('Click on a file to select it.'));\n\t\t\t\treturn Promise.reject();\n\t\t\t}\n\n\t\t\treturn this.upload_file({\n\t\t\t\tfile_url: selected_file.file_url\n\t\t\t});\n\t\t},\n\t\tupload_via_web_link() {\n\t\t\tlet file_url = this.$refs.web_link.url;\n\t\t\tif (!file_url) {\n\t\t\t\tfrappe.msgprint(__('Invalid URL'));\n\t\t\t\treturn Promise.reject();\n\t\t\t}\n\n\t\t\treturn this.upload_file({\n\t\t\t\tfile_url\n\t\t\t});\n\t\t},\n\t\treturn_as_dataurl() {\n\t\t\tlet promises = this.files.map(file =>\n\t\t\t\tfrappe.dom.file_to_base64(file.file_obj)\n\t\t\t\t\t.then(dataurl => {\n\t\t\t\t\t\tfile.dataurl = dataurl;\n\t\t\t\t\t\tthis.on_success && this.on_success(file);\n\t\t\t\t\t})\n\t\t\t);\n\t\t\treturn Promise.all(promises);\n\t\t},\n\t\tupload_file(file, i) {\n\t\t\tthis.currently_uploading = i;\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tlet xhr = new XMLHttpRequest();\n\t\t\t\txhr.upload.addEventListener('loadstart', (e) => {\n\t\t\t\t\tfile.uploading = true;\n\t\t\t\t})\n\t\t\t\txhr.upload.addEventListener('progress', (e) => {\n\t\t\t\t\tif (e.lengthComputable) {\n\t\t\t\t\t\tfile.progress = e.loaded;\n\t\t\t\t\t\tfile.total = e.total;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\txhr.upload.addEventListener('load', (e) => {\n\t\t\t\t\tfile.uploading = false;\n\t\t\t\t\tresolve();\n\t\t\t\t})\n\t\t\t\txhr.addEventListener('error', (e) => {\n\t\t\t\t\tfile.failed = true;\n\t\t\t\t\treject();\n\t\t\t\t})\n\t\t\t\txhr.onreadystatechange = () => {\n\t\t\t\t\tif (xhr.readyState == XMLHttpRequest.DONE) {\n\t\t\t\t\t\tif (xhr.status === 200) {\n\t\t\t\t\t\t\tlet r = null;\n\t\t\t\t\t\t\tlet file_doc = null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tr = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\t\tif (r.message.doctype === 'File') {\n\t\t\t\t\t\t\t\t\tfile_doc = r.message;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\t\tr = xhr.responseText;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfile.doc = file_doc;\n\n\t\t\t\t\t\t\tif (this.on_success) {\n\t\t\t\t\t\t\t\tthis.on_success(file_doc, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfile.failed = true;\n\t\t\t\t\t\t\tlet error = null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\terror = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\t\t// pass\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfrappe.request.cleanup({}, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txhr.open('POST', '/api/method/upload_file', true);\n\t\t\t\txhr.setRequestHeader('Accept', 'application/json');\n\t\t\t\txhr.setRequestHeader('X-Frappe-CSRF-Token', frappe.csrf_token);\n\n\t\t\t\tlet form_data = new FormData();\n\t\t\t\tif (file.file_obj) {\n\t\t\t\t\tform_data.append('file', file.file_obj, file.name);\n\t\t\t\t}\n\t\t\t\tform_data.append('is_private', +file.private);\n\t\t\t\tform_data.append('folder', this.folder);\n\n\t\t\t\tif (file.file_url) {\n\t\t\t\t\tform_data.append('file_url', file.file_url);\n\t\t\t\t}\n\n\t\t\t\tif (this.doctype && this.docname) {\n\t\t\t\t\tform_data.append('doctype', this.doctype);\n\t\t\t\t\tform_data.append('docname', this.docname);\n\t\t\t\t}\n\n\t\t\t\tif (this.method) {\n\t\t\t\t\tform_data.append('method', this.method);\n\t\t\t\t}\n\n\t\t\t\txhr.send(form_data);\n\t\t\t});\n\t\t}\n\t}\n}\n</script>\n<style>\n.file-upload-area {\n\tmin-height: 100px;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$4 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$4 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$4 = false;
	  /* component normalizer */
	  function __vue_normalize__$4(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/file_uploader/FileUploader.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$3() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var FileUploaderComponent = __vue_normalize__$4(
	    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
	    __vue_inject_styles__$4,
	    __vue_script__$4,
	    __vue_scope_id__$4,
	    __vue_is_functional_template__$4,
	    __vue_module_identifier__$4,
	    __vue_create_injector__$3,
	    undefined
	  );

	class FileUploader {
		constructor(ref) {
		var this$1 = this;
		if ( ref === void 0 ) ref = {};
		var wrapper = ref.wrapper;
		var method = ref.method;
		var on_success = ref.on_success;
		var doctype = ref.doctype;
		var docname = ref.docname;
		var files = ref.files;
		var folder = ref.folder;
		var restrictions = ref.restrictions;
		var upload_notes = ref.upload_notes;
		var allow_multiple = ref.allow_multiple;
		var as_dataurl = ref.as_dataurl;

			if (!wrapper) {
				this.make_dialog();
			} else {
				this.wrapper = wrapper.get ? wrapper.get(0) : wrapper;
			}

			this.$fileuploader = new Vue({
				el: this.wrapper,
				render: function (h) { return h(FileUploaderComponent, {
					props: {
						show_upload_button: !Boolean(this$1.dialog),
						doctype: doctype,
						docname: docname,
						method: method,
						folder: folder,
						on_success: on_success,
						restrictions: restrictions,
						upload_notes: upload_notes,
						allow_multiple: allow_multiple,
						as_dataurl: as_dataurl
					}
				}); }
			});

			this.uploader = this.$fileuploader.$children[0];

			if (files && files.length) {
				this.uploader.add_files(files);
			}
		}

		upload_files() {
			var this$1 = this;

			this.dialog && this.dialog.get_primary_btn().prop('disabled', true);
			return this.uploader.upload_files()
				.then(function () {
					this$1.dialog && this$1.dialog.hide();
				});
		}

		make_dialog() {
			var this$1 = this;

			this.dialog = new frappe.ui.Dialog({
				title: 'Upload',
				fields: [
					{
						fieldtype: 'HTML',
						fieldname: 'upload_area'
					}
				],
				primary_action_label: __('Upload'),
				primary_action: function () { return this$1.upload_files(); }
			});

			this.wrapper = this.dialog.fields_dict.upload_area.$wrapper[0];
			this.dialog.show();
			this.dialog.$wrapper.on('hidden.bs.modal', function() {
				$(this).data('bs.modal', null);
				$(this).remove();
			});
		}
	}

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide('frappe.ui');
	frappe.ui.FileUploader = FileUploader;

	frappe.provide("frappe.integration_service");

	frappe.integration_service.gsuite = {
		create_gsuite_file: function(args, opts) {
			return frappe.call({
				type:'POST',
				method: 'frappe.integrations.doctype.gsuite_templates.gsuite_templates.create_gsuite_doc',
				args: args,
				callback: function(r) {
					var attachment = r.message;
					opts.callback && opts.callback(attachment, r);
				}
			});
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.ui');

	frappe.ui.Tree = class {
		constructor(ref) {
		var parent = ref.parent;
		var label = ref.label;
		var icon_set = ref.icon_set;
		var toolbar = ref.toolbar;
		var expandable = ref.expandable;
		var with_skeleton = ref.with_skeleton; if ( with_skeleton === void 0 ) with_skeleton = 1;
		var args = ref.args;
		var method = ref.method;
		var get_label = ref.get_label;
		var on_render = ref.on_render;
		var on_click = ref.on_click;

			$.extend(this, arguments[0]);
			this.setup_treenode_class();
			this.nodes = {};
			this.wrapper = $('<div class="tree">').appendTo(this.parent);
			if(with_skeleton) { this.wrapper.addClass('with-skeleton'); }

			if(!icon_set) {
				this.icon_set = {
					open: 'fa fa-fw fa-folder-open',
					closed: 'fa fa-fw fa-folder',
					leaf: 'octicon octicon-primitive-dot'
				};
			}

			this.setup_root_node();
		}

		get_nodes(value, is_root) {
			var this$1 = this;

			var args = Object.assign({}, this.args);
			args.parent = value;
			args.is_root = is_root;

			return new Promise(function (resolve) {
				frappe.call({
					method: this$1.method,
					args: args,
					callback: function (r) {
						resolve(r.message);
					}
				});
			});
		}

		get_all_nodes(value, is_root) {
			var args = Object.assign({}, this.args);
			args.parent = value;
			args.is_root = is_root;

			args.tree_method = this.method;

			return new Promise(function (resolve) {
				frappe.call({
					method: 'frappe.desk.treeview.get_all_nodes',
					args: args,
					callback: function (r) {
						resolve(r.message);
					}
				});
			});
		}

		setup_treenode_class() {
			var tree = this;
			this.TreeNode = class {
				constructor(ref) {
				var parent = ref.parent;
				var label = ref.label;
				var parent_label = ref.parent_label;
				var expandable = ref.expandable;
				var is_root = ref.is_root;
				var data = ref.data;

					$.extend(this, arguments[0]);
					this.loaded = 0;
					this.expanded = 0;
					if(this.parent_label){
						this.parent_node = tree.nodes[this.parent_label];
					}

					tree.nodes[this.label] = this;
					tree.make_node_element(this);
					tree.on_render && tree.on_render(this);
				}
			};
		}

		setup_root_node() {
			this.root_node = new this.TreeNode({
				parent: this.wrapper,
				label: this.label,
				parent_label: null,
				expandable: true,
				is_root: true,
				data: {
					value: this.label
				}
			});
			this.expand_node(this.root_node, false);
		}

		refresh() {
			this.selected_node.parent_node &&
				this.load_children(this.selected_node.parent_node, true);
		}

		make_node_element(node) {
			node.$tree_link = $('<span class="tree-link">')
				.attr('data-label', node.label)
				.data('node', node)
				.appendTo(node.parent);

			node.$ul = $('<ul class="tree-children">')
				.hide().appendTo(node.parent);

			this.make_icon_and_label(node);
			if(this.toolbar) {
				node.$toolbar = this.get_toolbar(node).insertAfter(node.$tree_link);
			}
		}

		add_node(node, data) {
			var $li = $('<li class="tree-node">');

			return new this.TreeNode({
				parent: $li.appendTo(node.$ul),
				parent_label: node.label,
				label: data.value,
				title: data.title,
				expandable: data.expandable,
				data: data
			});
		}

		reload_node(node) {
			this.load_children(node);
		}

		toggle() {
			this.get_selected_node().toggle();
		}

		get_selected_node() {
			return this.selected_node;
		}

		set_selected_node(node) {
			this.selected_node = node;
		}

		load_children(node, deep) {
			var this$1 = this;
			if ( deep === void 0 ) deep=false;

			var value = node.data.value, is_root = node.is_root;

			if(!deep) {
				frappe.run_serially([
					function () {return this$1.get_nodes(value, is_root);},
					function (data_set) { this$1.render_node_children(node, data_set); },
					function () { this$1.set_selected_node(node); }
				]);
			} else {
				frappe.run_serially([
					function () {return this$1.get_all_nodes(value, is_root);},
					function (data_list) { this$1.render_children_of_all_nodes(data_list); },
					function () { this$1.set_selected_node(node); }
				]);
			}
		}

		render_children_of_all_nodes(data_list) {
			var this$1 = this;

			data_list.map(function (d) { this$1.render_node_children(this$1.nodes[d.parent], d.data); });
		}

		render_node_children(node, data_set) {
			var this$1 = this;

			node.$ul.empty();
			if (data_set) {
				$.each(data_set, function (i, data) {
					var child_node = this$1.add_node(node, data);
					child_node.$tree_link
						.data('node-data', data)
						.data('node', child_node);
				});
			}

			node.expanded = false;

			// As children loaded
			node.loaded = true;
			this.expand_node(node);
		}

		on_node_click(node) {
			this.expand_node(node);
			frappe.dom.activate(this.wrapper, node.$tree_link, 'tree-link');
			if(node.$toolbar) { this.show_toolbar(node); }
		}

		expand_node(node, click) {
			if ( click === void 0 ) click = true;

			this.set_selected_node(node);

			if(click) {
				this.on_click && this.on_click(node);
			}

			if(node.expandable) {
				this.toggle_node(node);
			}
			this.select_link(node);

			node.expanded = !node.expanded;
			node.parent.toggleClass('opened', node.expanded);
		}

		toggle_node(node) {
			if(node.expandable && this.get_nodes && !node.loaded) {
				return this.load_children(node);
			}

			// expand children
			if(node.$ul) {
				if(node.$ul.children().length) {
					node.$ul.toggle(!node.expanded);
				}

				// open close icon
				if(this.icon_set) {
					node.$tree_link.find('i').removeClass();
					if(!node.expanded) {
						node.$tree_link.find('i').addClass(((this.icon_set.open) + " node-parent"));
					} else {
						node.$tree_link.find('i').addClass(((this.icon_set.closed) + " node-parent"));
					}
				}
			}
		}

		select_link(node) {
			this.wrapper.find('.selected')
				.removeClass('selected');
			node.$tree_link.toggleClass('selected');
		}

		show_toolbar(node) {
			if(this.cur_toolbar)
				{ $(this.cur_toolbar).hide(); }
			this.cur_toolbar = node.$toolbar;
			node.$toolbar.show();
		}

		get_node_label(node) {
			if(this.get_label) {
				return this.get_label(node);
			}
			if (node.title && node.title != node.label) {
				return __(node.title) + " <span class='text-muted'>(" + (node.label) + ")</span>";
			} else {
				return __(node.title || node.label);
			}
		}

		make_icon_and_label(node) {
			var this$1 = this;

			var icon_html = '';
			if(this.icon_set) {
				if(node.expandable) {
					icon_html = "<i class=\"" + (this.icon_set.closed) + " node-parent\"></i>";
				} else {
					icon_html = "<i class=\"" + (this.icon_set.leaf) + " node-leaf\"></i>";
				}
			}

			$(icon_html).appendTo(node.$tree_link);
			$(("<a class=\"tree-label grey h6\"> " + (this.get_node_label(node)) + "</a>")).appendTo(node.$tree_link);

			node.$tree_link.on('click', function () {
				setTimeout(function () {this$1.on_node_click(node);}, 100);
			});
		}

		get_toolbar(node) {
			var this$1 = this;

			var $toolbar = $('<span class="tree-node-toolbar btn-group"></span>').hide();

			Object.keys(this.toolbar).map(function (key) {
				var obj = this$1.toolbar[key];
				if(!obj.label) { return; }
				if(obj.condition && !obj.condition(node)) { return; }

				var label = obj.get_label ? obj.get_label() : obj.label;
				var $link = $("<button class='btn btn-default btn-xs'></button>")
					.html(label)
					.addClass('tree-toolbar-button ' + (obj.btnClass || ''))
					.appendTo($toolbar);
				$link.on('click', function () {
					obj.click(node);
					this$1.refresh();
				});
			});

			return $toolbar;
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	// page container
	frappe.provide('frappe.pages');
	frappe.provide('frappe.views');

	window.cur_page = null;
	frappe.views.Container = Class.extend({
		_intro: "Container contains pages inside `#container` and manages \
			page creation, switching",
		init: function() {
			this.container = $('#body_div').get(0);
			this.page = null; // current page
			this.pagewidth = $(this.container).width();
			this.pagemargin = 50;

			var me = this;

			$(document).on("page-change", function() {
				// set data-route in body
				var route_str = frappe.get_route_str();
				$("body").attr("data-route", route_str);
				$("body").attr("data-sidebar", me.has_sidebar() ? 1 : 0);
			});

			$(document).bind('rename', function(event, dt, old_name, new_name) {
				frappe.breadcrumbs.rename(dt, old_name, new_name);
			});
		},
		add_page: function(label) {
			var page = $('<div class="content page-container"></div>')
				.attr('id', "page-" + label)
				.attr("data-page-route", label)
				.hide()
				.appendTo(this.container).get(0);
			page.label = label;
			frappe.pages[label] = page;

			return page;
		},
		change_to: function(label) {
			cur_page = this;
			if(this.page && this.page.label === label) {
				$(this.page).trigger('show');
				return;
			}
			if(label.tagName) {
				// if sent the div, get the table
				var page = label;
			} else {
				var page = frappe.pages[label];
			}
			if(!page) {
				console.log(__('Page not found')+ ': ' + label);
				return;
			}

			// hide dialog
			if(window.cur_dialog && cur_dialog.display && !cur_dialog.keep_open) {
				if (!cur_dialog.minimizable) {
					cur_dialog.hide();
				} else if (!cur_dialog.is_minimized) {
					cur_dialog.toggle_minimize();
				}
			}

			// hide current
			if(this.page && this.page != page) {
				$(this.page).hide();
				$(this.page).trigger('hide');
			}

			// show new
			if(!this.page || this.page != page) {
				this.page = page;
				// $(this.page).fadeIn(300);
				$(this.page).show();
			}

			$(document).trigger("page-change");

			this.page._route = window.location.hash;
			$(this.page).trigger('show');
			frappe.utils.scroll_to(0);
			frappe.breadcrumbs.update();

			return this.page;
		},
		has_sidebar: function() {
			var flag = 0;
			var route_str = frappe.get_route_str();
			// check in frappe.ui.pages
			flag = frappe.ui.pages[route_str] && !frappe.ui.pages[route_str].single_column;

			// sometimes frappe.ui.pages is updated later,
			// so check the dom directly
			if(!flag) {
				var page_route = route_str.split('/').slice(0, 2).join('/');
				flag = $((".page-container[data-page-route=\"" + page_route + "\"] .layout-side-section")).length ? 1 : 0;
			}

			return flag;
		},
	});

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.breadcrumbs = {
		all: {},

		preferred: {
			"File": "",
			"Dashboard": "Customization",
			"Dashboard Chart": "Customization",
			"Dashboard Chart Source": "Customization",
		},

		set_doctype_module: function(doctype, module) {
			localStorage["preferred_breadcrumbs:" + doctype] = module;
		},

		get_doctype_module: function(doctype) {
			return localStorage["preferred_breadcrumbs:" + doctype];
		},

		add: function(module, doctype, type) {
			var obj;
			if (typeof module === 'object') {
				obj = module;
			} else {
				obj = {
					module:module,
					doctype:doctype,
					type:type
				};
			}

			frappe.breadcrumbs.all[frappe.breadcrumbs.current_page()] = obj;
			frappe.breadcrumbs.update();
		},

		current_page: function() {
			return frappe.get_route_str();
		},

		update: function() {
			var breadcrumbs = frappe.breadcrumbs.all[frappe.breadcrumbs.current_page()];

			if(!frappe.visible_modules) {
				frappe.visible_modules = $.map(frappe.boot.allowed_modules, function (m) {
					return m.module_name;
				});
			}

			var $breadcrumbs = $("#navbar-breadcrumbs").empty();

			if(!breadcrumbs) {
				$("body").addClass("no-breadcrumbs");
				return;
			}

			if (breadcrumbs.type === 'Custom') {
				var html = "<li><a href=\"" + (breadcrumbs.route) + "\">" + (breadcrumbs.label) + "</a></li>";
				$breadcrumbs.append(html);
				$("body").removeClass("no-breadcrumbs");
				return;
			}

			// get preferred module for breadcrumbs, based on sent via module
			var from_module = frappe.breadcrumbs.get_doctype_module(breadcrumbs.doctype);

			if(from_module) {
				breadcrumbs.module = from_module;
			} else if(frappe.breadcrumbs.preferred[breadcrumbs.doctype]!==undefined) {
				// get preferred module for breadcrumbs
				breadcrumbs.module = frappe.breadcrumbs.preferred[breadcrumbs.doctype];
			}

			if(breadcrumbs.module) {
				if(in_list(["Core", "Email", "Custom", "Workflow", "Print"], breadcrumbs.module)) {
					breadcrumbs.module = "Setup";
				}

				if(frappe.get_module(breadcrumbs.module)) {
					// if module access exists
					var module_info = frappe.get_module(breadcrumbs.module),
						icon = module_info && module_info.icon,
						label = module_info ? module_info.label : breadcrumbs.module;


					if(module_info && !module_info.blocked && frappe.visible_modules.includes(module_info.module_name)) {
						$(repl('<li><a href="#modules/%(module)s">%(label)s</a></li>',
							{ module: breadcrumbs.module, label: __(label) }))
							.appendTo($breadcrumbs);
					}
				}
			}
			if(breadcrumbs.doctype && frappe.get_route()[0]==="Form") {
				if(breadcrumbs.doctype==="User"
					|| frappe.get_doc('DocType', breadcrumbs.doctype).issingle) ; else {
					var route;
					if(frappe.boot.treeviews.indexOf(breadcrumbs.doctype) !== -1) {
						var view = frappe.model.user_settings[breadcrumbs.doctype].last_view || 'Tree';
						route = view + '/' + breadcrumbs.doctype;
					} else {
						route = 'List/' + breadcrumbs.doctype;
					}
					$(repl('<li><a href="#%(route)s">%(label)s</a></li>',
						{route: route, label: __(breadcrumbs.doctype)}))
						.appendTo($breadcrumbs);
				}
			}

			$("body").removeClass("no-breadcrumbs");
		},

		rename: function(doctype, old_name, new_name) {
			var old_route_str = ["Form", doctype, old_name].join("/");
			var new_route_str = ["Form", doctype, new_name].join("/");
			frappe.breadcrumbs.all[new_route_str] = frappe.breadcrumbs.all[old_route_str];
			delete frappe.breadcrumbs.all[old_route_str];
		}

	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.pages');
	frappe.provide('frappe.views');

	frappe.views.Factory = class Factory {
		constructor(opts) {
			$.extend(this, opts);
		}

		show() {
			var page_name = frappe.get_route_str(),
				me = this;

			if(frappe.pages[page_name] && !page_name.includes("Form/")) {
				frappe.container.change_to(page_name);
				if(me.on_show) {
					me.on_show();
				}
			} else {
				var route = frappe.get_route();
				if(route[1]) {
					me.make(route);
				} else {
					frappe.show_not_found(route);
				}
			}
		}

		make_page(double_column, page_name) {
			return frappe.make_page(double_column, page_name);
		}
	};

	frappe.make_page = function(double_column, page_name) {
		if(!page_name) {
			var page_name = frappe.get_route_str();
		}
		var page = frappe.container.add_page(page_name);

		frappe.ui.make_app_page({
			parent: page,
			single_column: !double_column
		});
		frappe.container.change_to(page_name);
		return page;
	};

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	var instances = [];

	function onDocumentClick(e, el, fn) {
	  var target = e.target;
	  if (el !== target && !el.contains(target)) {
	    fn(e);
	  }
	}

	var script$5 = {
	  name: "Popover",
	  props: {
	    align: {
	      default: "left"
	    },
	    fullwidth: {
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      isOpen: false
	    };
	  },
	  directives: {
	    outside: {
	      bind: function bind(el, binding) {
	        el.dataset.outsideClickIndex = instances.length;

	        var fn = binding.value;
	        var click = function(e) {
	          onDocumentClick(e, el, fn);
	        };

	        document.addEventListener("click", click);
	        instances.push(click);
	      },
	      unbind: function unbind(el) {
	        var index = el.dataset.outsideClickIndex;
	        var handler = instances[index];
	        document.addEventListener("click", handler);
	        instances.splice(index, 1);
	      }
	    }
	  },
	  computed: {
	    popoverClasses: function popoverClasses() {
	      return {
	        "pin-r": this.align === "right",
	        "pin-l": this.align === "left",
	        "w-full": this.fullwidth === true
	      };
	    }
	  },
	  methods: {
	    togglePopover: function togglePopover() {
	      this.isOpen = !this.isOpen;
	    },
	    closePopover: function closePopover() {
	      this.isOpen = false;
	    }
	  }
	};

	/* script */
	            var __vue_script__$5 = script$5;
	            
	/* template */
	var __vue_render__$5 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    {
	      directives: [
	        {
	          name: "outside",
	          rawName: "v-outside",
	          value: _vm.closePopover,
	          expression: "closePopover"
	        }
	      ],
	      staticClass: "inline-block relative",
	      class: { "w-full": this.fullwidth }
	    },
	    [
	      _c(
	        "div",
	        { on: { click: _vm.togglePopover } },
	        [
	          _vm._t("default", null, {
	            togglePopover: _vm.togglePopover,
	            closePopover: _vm.closePopover
	          })
	        ],
	        2
	      ),
	      _vm._v(" "),
	      _c(
	        "div",
	        {
	          directives: [
	            {
	              name: "show",
	              rawName: "v-show",
	              value: _vm.isOpen,
	              expression: "isOpen"
	            }
	          ],
	          staticClass: "absolute mt-default z-20",
	          class: _vm.popoverClasses
	        },
	        [_vm._t("popover-content")],
	        2
	      )
	    ]
	  )
	};
	var __vue_staticRenderFns__$5 = [];
	__vue_render__$5._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$5 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-eeaa6c10_0", { source: "\n.relative[data-v-eeaa6c10] {\n  position: relative;\n}\n.inline-block[data-v-eeaa6c10] {\n  display: inline-block;\n}\n.w-full[data-v-eeaa6c10] {\n  width: 100%;\n}\n.pin-r[data-v-eeaa6c10] {\n  right: 0;\n}\n.pin-l[data-v-eeaa6c10] {\n  left: 0;\n}\n.absolute[data-v-eeaa6c10] {\n  position: absolute;\n}\n.mt-default[data-v-eeaa6c10] {\n  margin-top: 25px;\n}\n.z-20[data-v-eeaa6c10] {\n  z-index: 20;\n}\n", map: {"version":3,"sources":["/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/views/components/Popover.vue"],"names":[],"mappings":";AA4EA;EACA,kBAAA;AACA;AACA;EACA,qBAAA;AACA;AACA;EACA,WAAA;AACA;AACA;EACA,QAAA;AACA;AACA;EACA,OAAA;AACA;AACA;EACA,kBAAA;AACA;AACA;EACA,gBAAA;AACA;AACA;EACA,WAAA;AACA","file":"Popover.vue","sourcesContent":["<template>\n  <div class=\"inline-block relative\" :class=\"{ 'w-full': this.fullwidth }\" v-outside=\"closePopover\">\n    <div @click=\"togglePopover\">\n      <slot :togglePopover=\"togglePopover\" :closePopover=\"closePopover\"></slot>\n    </div>\n    <div v-show=\"isOpen\" class=\"absolute mt-default z-20\" :class=\"popoverClasses\">\n      <slot name=\"popover-content\"></slot>\n    </div>\n  </div>\n</template>\n<script>\nlet instances = [];\n\nfunction onDocumentClick(e, el, fn) {\n  let target = e.target;\n  if (el !== target && !el.contains(target)) {\n    fn(e);\n  }\n}\n\nexport default {\n  name: \"Popover\",\n  props: {\n    align: {\n      default: \"left\"\n    },\n    fullwidth: {\n      default: false\n    }\n  },\n  data() {\n    return {\n      isOpen: false\n    };\n  },\n  directives: {\n    outside: {\n      bind(el, binding) {\n        el.dataset.outsideClickIndex = instances.length;\n\n        const fn = binding.value;\n        const click = function(e) {\n          onDocumentClick(e, el, fn);\n        };\n\n        document.addEventListener(\"click\", click);\n        instances.push(click);\n      },\n      unbind(el) {\n        const index = el.dataset.outsideClickIndex;\n        const handler = instances[index];\n        document.addEventListener(\"click\", handler);\n        instances.splice(index, 1);\n      }\n    }\n  },\n  computed: {\n    popoverClasses() {\n      return {\n        \"pin-r\": this.align === \"right\",\n        \"pin-l\": this.align === \"left\",\n        \"w-full\": this.fullwidth === true\n      };\n    }\n  },\n  methods: {\n    togglePopover() {\n      this.isOpen = !this.isOpen;\n    },\n    closePopover() {\n      this.isOpen = false;\n    }\n  }\n};\n</script>\n<style scoped>\n.relative {\n  position: relative;\n}\n.inline-block {\n  display: inline-block;\n}\n.w-full {\n  width: 100%;\n}\n.pin-r {\n  right: 0;\n}\n.pin-l {\n  left: 0;\n}\n.absolute {\n  position: absolute;\n}\n.mt-default {\n  margin-top: 25px;\n}\n.z-20 {\n  z-index: 20;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$5 = "data-v-eeaa6c10";
	  /* module identifier */
	  var __vue_module_identifier__$5 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$5 = false;
	  /* component normalizer */
	  function __vue_normalize__$5(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/views/components/Popover.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$4() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$4.styles || (__vue_create_injector__$4.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var Popover = __vue_normalize__$5(
	    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
	    __vue_inject_styles__$5,
	    __vue_script__$5,
	    __vue_scope_id__$5,
	    __vue_is_functional_template__$5,
	    __vue_module_identifier__$5,
	    __vue_create_injector__$4,
	    undefined
	  );

	//

	var script$6 = {
	  name: "Dropdown",
	  components: {
	    Popover: Popover
	  },
	  props: {
	    items: {
	      type: Array,
	      default: function () { return []; }
	    },
	    label: {
	      type: String,
	      default: "Dropdown"
	    },
	    align: {
	      type: String,
	      default: "right"
	    }
	  },
	  data: function data() {
	    return {
	      isOpen: false
	    };
	  },
	  computed: {
	    dropdownItems: function dropdownItems() {
	      var this$1 = this;

	      return (this.items || []).map(function (item) {
	        if (typeof item === "string") {
	          return {
	            label: item,
	            action: console.log
	          };
	        }
	        if (!item.action && item.route) {
	          item.action = this$1.setRoute.bind(this$1, item.route);
	        }
	        return item;
	      });
	    }
	  },
	  methods: {
	    setRoute: function setRoute(route) {
	      this.$router.push(route);
	    }
	  }
	};

	/* script */
	            var __vue_script__$6 = script$6;
	            
	/* template */
	var __vue_render__$6 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "Popover",
	    { attrs: { align: _vm.align } },
	    [
	      _vm._t("default"),
	      _vm._v(" "),
	      _c(
	        "ul",
	        {
	          staticClass: "list-reset border",
	          attrs: { slot: "popover-content" },
	          slot: "popover-content"
	        },
	        _vm._l(_vm.dropdownItems, function(item) {
	          return _c("li", { key: item.label, class: item.class || null }, [
	            item.route
	              ? _c(
	                  "a",
	                  { staticClass: "list-item", attrs: { href: item.route } },
	                  [_vm._v(_vm._s(item.label))]
	                )
	              : _c(
	                  "div",
	                  { staticClass: "list-item", on: { click: item.action } },
	                  [_vm._v(_vm._s(item.label))]
	                )
	          ])
	        }),
	        0
	      )
	    ],
	    2
	  )
	};
	var __vue_staticRenderFns__$6 = [];
	__vue_render__$6._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$6 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-6a6a243c_0", { source: "\n.list-reset[data-v-6a6a243c] {\n  list-style: none;\n  padding: 0;\n  cursor: pointer;\n  background-color: #fff;\n  width: 16rem;\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.12), 0 2px 4px 0 rgba(0, 0, 0, 0.08);\n  border-bottom-right-radius: 0.25rem;\n  border-bottom-left-radius: 0.25rem;\n}\n.list-item[data-v-6a6a243c]:hover {\n  background-color: #f0f4f7;\n}\n.list-item[data-v-6a6a243c] {\n  padding: 14px;\n  transition: all 0.1s ease-in;\n}\na[data-v-6a6a243c] {\n  font-size: 12px;\n  text-decoration: none;\n}\n", map: {"version":3,"sources":["/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/views/components/Dropdown.vue"],"names":[],"mappings":";AA8DA;EACA,gBAAA;EACA,UAAA;EACA,eAAA;EACA,sBAAA;EACA,YAAA;EACA,4EAAA;EACA,mCAAA;EACA,kCAAA;AACA;AACA;EACA,yBAAA;AACA;AACA;EACA,aAAA;EACA,4BAAA;AACA;AACA;EACA,eAAA;EACA,qBAAA;AACA","file":"Dropdown.vue","sourcesContent":["<template>\n  <Popover :align=\"align\">\n    <slot></slot>\n    <ul slot=\"popover-content\" class=\"list-reset border\">\n      <li v-for=\"item of dropdownItems\" :key=\"item.label\" :class=\"item.class || null\">\n        <a v-if=\"item.route\" class=\"list-item\" :href=\"item.route\">{{ item.label }}</a>\n        <div v-else class=\"list-item\" @click=\"item.action\">{{ item.label }}</div>\n      </li>\n    </ul>\n  </Popover>\n</template>\n<script>\nimport Popover from \"./Popover.vue\";\n\nexport default {\n  name: \"Dropdown\",\n  components: {\n    Popover\n  },\n  props: {\n    items: {\n      type: Array,\n      default: () => []\n    },\n    label: {\n      type: String,\n      default: \"Dropdown\"\n    },\n    align: {\n      type: String,\n      default: \"right\"\n    }\n  },\n  data() {\n    return {\n      isOpen: false\n    };\n  },\n  computed: {\n    dropdownItems() {\n      return (this.items || []).map(item => {\n        if (typeof item === \"string\") {\n          return {\n            label: item,\n            action: console.log\n          };\n        }\n        if (!item.action && item.route) {\n          item.action = this.setRoute.bind(this, item.route);\n        }\n        return item;\n      });\n    }\n  },\n  methods: {\n    setRoute(route) {\n      this.$router.push(route);\n    }\n  }\n};\n</script>\n<style scoped>\n.list-reset {\n  list-style: none;\n  padding: 0;\n  cursor: pointer;\n  background-color: #fff;\n  width: 16rem;\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.12), 0 2px 4px 0 rgba(0, 0, 0, 0.08);\n  border-bottom-right-radius: 0.25rem;\n  border-bottom-left-radius: 0.25rem;\n}\n.list-item:hover {\n  background-color: #f0f4f7;\n}\n.list-item {\n  padding: 14px;\n  transition: all 0.1s ease-in;\n}\na {\n  font-size: 12px;\n  text-decoration: none;\n}\n</style>\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$6 = "data-v-6a6a243c";
	  /* module identifier */
	  var __vue_module_identifier__$6 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$6 = false;
	  /* component normalizer */
	  function __vue_normalize__$6(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/views/components/Dropdown.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$5() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$5.styles || (__vue_create_injector__$5.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var Dropdown = __vue_normalize__$6(
	    { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
	    __vue_inject_styles__$6,
	    __vue_script__$6,
	    __vue_scope_id__$6,
	    __vue_is_functional_template__$6,
	    __vue_module_identifier__$6,
	    __vue_create_injector__$5,
	    undefined
	  );

	//

	var script$7 = {
	  props: [
	    "index",
	    "name",
	    "label",
	    "category",
	    "type",
	    "module_name",
	    "link",
	    "count",
	    "onboard_present",
	    "links",
	    "description",
	    "hidden",
	    "icon"
	  ],
	  components: {
	    Dropdown: Dropdown
	  },
	  data: function data() {
	    return {
	      hovered: 0
	    };
	  },
	  computed: {
	    iconClass: function iconClass() {
	      if (this.icon) {
	        return this.icon;
	      } else {
	        return "octicon octicon-file-text";
	      }
		},
		dropdown_links: function dropdown_links() {
			var this$1 = this;

			return this.links.length > 0 ? this.links
				.filter(function (link) { return !link.hidden; })
				.concat([
					{ label: __('Customize'), action: function () { return this$1.$emit('customize'); }, class: 'border-top' }
				]) : [];
		}
	  },
	};

	/* script */
	            var __vue_script__$7 = script$7;
	            
	/* template */
	var __vue_render__$7 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return !_vm.hidden
	    ? _c(
	        "div",
	        {
	          staticClass: "border module-box",
	          class: { "hovered-box": _vm.hovered }
	        },
	        [
	          _c("div", { staticClass: "flush-top" }, [
	            _c("div", { staticClass: "module-box-content" }, [
	              _c(
	                "div",
	                { staticClass: "level" },
	                [
	                  _c(
	                    "a",
	                    {
	                      staticClass: "module-box-link",
	                      attrs: {
	                        href:
	                          _vm.type === "module"
	                            ? "#modules/" + _vm.module_name
	                            : _vm.link
	                      }
	                    },
	                    [
	                      _c("h4", { staticClass: "h4" }, [
	                        _c("div", [
	                          _c("i", {
	                            class: _vm.iconClass,
	                            staticStyle: {
	                              color: "#8d99a6",
	                              "font-size": "18px",
	                              "margin-right": "6px"
	                            }
	                          }),
	                          _vm._v(
	                            "\n              " +
	                              _vm._s(_vm.label) +
	                              "\n            "
	                          )
	                        ])
	                      ])
	                    ]
	                  ),
	                  _vm._v(" "),
	                  _vm.dropdown_links && _vm.dropdown_links.length
	                    ? _c("dropdown", { attrs: { items: _vm.dropdown_links } }, [
	                        _c("span", { staticClass: "pull-right" }, [
	                          _c("i", {
	                            staticClass:
	                              "octicon octicon-chevron-down text-muted"
	                          })
	                        ])
	                      ])
	                    : _vm._e()
	                ],
	                1
	              )
	            ])
	          ])
	        ]
	      )
	    : _vm._e()
	};
	var __vue_staticRenderFns__$7 = [];
	__vue_render__$7._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$7 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-052ddd9a_0", { source: "/* palette colors*/\n.module-box[data-v-052ddd9a] {\n  border-radius: 4px;\n  padding: 5px 15px;\n  display: block;\n  background-color: #ffffff;\n}\n.module-box[data-v-052ddd9a]:hover {\n  border-color: #8d99a6;\n}\n.hovered-box[data-v-052ddd9a] {\n  background-color: #fafbfc;\n}\n.octicon-chevron-down[data-v-052ddd9a] {\n  font-size: 14px;\n  padding: 4px 6px 2px 6px;\n  border-radius: 4px;\n}\n.octicon-chevron-down[data-v-052ddd9a]:hover {\n  background: #f0f4f7;\n}\n.octicon-chevron-down[data-v-052ddd9a]:hover {\n  cursor: pointer;\n}\n.module-box-content[data-v-052ddd9a] {\n  width: 100%;\n}\n.module-box-content p[data-v-052ddd9a] {\n  margin-top: 5px;\n  font-size: 80%;\n  display: flex;\n  overflow: hidden;\n}\n.module-box-link[data-v-052ddd9a] {\n  flex: 1;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  text-decoration: none;\n  --moz-text-decoration-line: none;\n}\n.icon-box[data-v-052ddd9a] {\n  padding: 15px;\n  width: 54px;\n  display: flex;\n  justify-content: center;\n}\n.icon[data-v-052ddd9a] {\n  font-size: 24px;\n}\n.open-notification[data-v-052ddd9a] {\n  top: -2px;\n}\n.shortcut-tag[data-v-052ddd9a] {\n  margin-right: 5px;\n}\n.drag-handle[data-v-052ddd9a] {\n  font-size: 12px;\n}\n", map: {"version":3,"sources":["DeskModuleBox.vue"],"names":[],"mappings":"AAAA,kBAAkB;AAClB;EACE,kBAAkB;EAClB,iBAAiB;EACjB,cAAc;EACd,yBAAyB;AAC3B;AACA;EACE,qBAAqB;AACvB;AACA;EACE,yBAAyB;AAC3B;AACA;EACE,eAAe;EACf,wBAAwB;EACxB,kBAAkB;AACpB;AACA;EACE,mBAAmB;AACrB;AACA;EACE,eAAe;AACjB;AACA;EACE,WAAW;AACb;AACA;EACE,eAAe;EACf,cAAc;EACd,aAAa;EACb,gBAAgB;AAClB;AACA;EACE,OAAO;EACP,gBAAgB;EAChB,mBAAmB;EACnB,qBAAqB;EACrB,gCAAgC;AAClC;AACA;EACE,aAAa;EACb,WAAW;EACX,aAAa;EACb,uBAAuB;AACzB;AACA;EACE,eAAe;AACjB;AACA;EACE,SAAS;AACX;AACA;EACE,iBAAiB;AACnB;AACA;EACE,eAAe;AACjB","file":"DeskModuleBox.vue","sourcesContent":["/* palette colors*/\n.module-box {\n  border-radius: 4px;\n  padding: 5px 15px;\n  display: block;\n  background-color: #ffffff;\n}\n.module-box:hover {\n  border-color: #8d99a6;\n}\n.hovered-box {\n  background-color: #fafbfc;\n}\n.octicon-chevron-down {\n  font-size: 14px;\n  padding: 4px 6px 2px 6px;\n  border-radius: 4px;\n}\n.octicon-chevron-down:hover {\n  background: #f0f4f7;\n}\n.octicon-chevron-down:hover {\n  cursor: pointer;\n}\n.module-box-content {\n  width: 100%;\n}\n.module-box-content p {\n  margin-top: 5px;\n  font-size: 80%;\n  display: flex;\n  overflow: hidden;\n}\n.module-box-link {\n  flex: 1;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  text-decoration: none;\n  --moz-text-decoration-line: none;\n}\n.icon-box {\n  padding: 15px;\n  width: 54px;\n  display: flex;\n  justify-content: center;\n}\n.icon {\n  font-size: 24px;\n}\n.open-notification {\n  top: -2px;\n}\n.shortcut-tag {\n  margin-right: 5px;\n}\n.drag-handle {\n  font-size: 12px;\n}\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$7 = "data-v-052ddd9a";
	  /* module identifier */
	  var __vue_module_identifier__$7 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$7 = false;
	  /* component normalizer */
	  function __vue_normalize__$7(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/views/components/DeskModuleBox.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$6() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$6.styles || (__vue_create_injector__$6.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var DeskModuleBox = __vue_normalize__$7(
	    { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
	    __vue_inject_styles__$7,
	    __vue_script__$7,
	    __vue_scope_id__$7,
	    __vue_is_functional_template__$7,
	    __vue_module_identifier__$7,
	    __vue_create_injector__$6,
	    undefined
	  );

	//

	var script$8 = {
		props: ['category', 'modules'],
		components: {
			DeskModuleBox: DeskModuleBox
		},
		methods: {
			show_module_card_customize_dialog: function show_module_card_customize_dialog(module) {
				var this$1 = this;

				var d = new frappe.ui.Dialog({
					title: __('Customize Shortcuts'),
					fields: [
						{
							label: __('Shortcuts'),
							fieldname: 'links',
							fieldtype: 'MultiSelectPills',
							get_data: function get_data() {
								return frappe.call('frappe.desk.moduleview.get_links', {
									app: module.app,
									module: module.module_name,
								}).then(function (r) { return r.message; });
							},
							default: module.links.filter(function (l) { return !l.hidden; }).map(function (l) { return l.name; })
						}
					],
					primary_action_label: __('Save'),
					primary_action: function (ref) {
						var links = ref.links;

						frappe.call('frappe.desk.moduleview.update_links_for_module', {
							module_name: module.module_name,
							links: links
						}).then(function (r) {
							this$1.$emit('update_home_settings', r.message);
						});
						d.hide();
					}
				});

				d.show();
			},
		}
	};

	/* script */
	            var __vue_script__$8 = script$8;
	            
	/* template */
	var __vue_render__$8 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", [
	    _c("div", { staticClass: "section-header level text-muted" }, [
	      _c("div", { staticClass: "module-category h6 uppercase" }, [
	        _vm._v(_vm._s(_vm.category))
	      ])
	    ]),
	    _vm._v(" "),
	    _c(
	      "div",
	      { staticClass: "modules-container" },
	      _vm._l(_vm.modules, function(module, index) {
	        return _c(
	          "desk-module-box",
	          _vm._b(
	            {
	              key: module.name,
	              attrs: { index: index },
	              on: {
	                customize: function($event) {
	                  return _vm.show_module_card_customize_dialog(module)
	                }
	              }
	            },
	            "desk-module-box",
	            module,
	            false
	          )
	        )
	      }),
	      1
	    )
	  ])
	};
	var __vue_staticRenderFns__$8 = [];
	__vue_render__$8._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$8 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-588a8d1d_0", { source: ".modules-container[data-v-588a8d1d] {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n  grid-auto-rows: minmax(62px, 1fr);\n  column-gap: 15px;\n  row-gap: 15px;\n  align-items: center;\n}\n", map: {"version":3,"sources":["DeskSection.vue"],"names":[],"mappings":"AAAA;EACE,aAAa;EACb,4DAA4D;EAC5D,iCAAiC;EACjC,gBAAgB;EAChB,aAAa;EACb,mBAAmB;AACrB","file":"DeskSection.vue","sourcesContent":[".modules-container {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n  grid-auto-rows: minmax(62px, 1fr);\n  column-gap: 15px;\n  row-gap: 15px;\n  align-items: center;\n}\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$8 = "data-v-588a8d1d";
	  /* module identifier */
	  var __vue_module_identifier__$8 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$8 = false;
	  /* component normalizer */
	  function __vue_normalize__$8(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/views/components/DeskSection.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$7() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$7.styles || (__vue_create_injector__$7.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var DeskSection = __vue_normalize__$8(
	    { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
	    __vue_inject_styles__$8,
	    __vue_script__$8,
	    __vue_scope_id__$8,
	    __vue_is_functional_template__$8,
	    __vue_module_identifier__$8,
	    __vue_create_injector__$7,
	    undefined
	  );

	function generate_route(item) {
		if(item.type==="doctype") {
			item.doctype = item.name;
		}
		var route = '';
		if(!item.route) {
			if(item.link) {
				route=strip(item.link, "#");
			} else if(item.type==="doctype") {
				if(frappe.model.is_single(item.doctype)) {
					route = 'Form/' + item.doctype;
				} else {
					if (item.filters) {
						frappe.route_options=item.filters;
					}
					route="List/" + item.doctype;
				}
			} else if(item.type==="report" && item.is_query_report) {
				route="query-report/" + item.name;
			} else if(item.type==="report") {
				route="List/" + item.doctype + "/Report/" + item.name;
			} else if(item.type==="page") {
				route=item.name;
			}

			route = '#' + route;
		} else {
			route = item.route;
		}

		if(item.route_options) {
			route += "?" + $.map(item.route_options, function(value, key) {
				return encodeURIComponent(key) + "=" + encodeURIComponent(value); }).join('&');
		}

		// if(item.type==="page" || item.type==="help" || item.type==="report" ||
		// (item.doctype && frappe.model.can_read(item.doctype))) {
		//     item.shown = true;
		// }
		return route;
	}

	//

	var script$9 = {
		components: {
			DeskSection: DeskSection
		},
		data: function data() {
			var modules_list = frappe.boot.allowed_modules
				.filter(function (d) { return (d.type==='module' || d.category==='Places') && !d.blocked; })
				.map(function (d) {
					d.links = (d.links || []).map(function (link) {
						link.route = generate_route(link);
						return link;
					});
					return d;
				});

			return {
				module_categories: ['Modules', 'Domains', 'Places', 'Administration'],
				modules: modules_list,
				home_settings_fetched: false
			};
		},
		created: function created() {
			this.fetch_home_settings();
		},
		methods: {
			fetch_home_settings: function fetch_home_settings() {
				var this$1 = this;

				return frappe.db.get_value('User', user, 'home_settings')
					.then(function (r) {
						var home_settings = JSON.parse(r.message.home_settings || '{}');
						this$1.update_modules_with_home_settings(home_settings);
						this$1.home_settings_fetched = true;
					});
			},
			update_modules_with_home_settings: function update_modules_with_home_settings(home_settings) {
				this.modules = this.modules.map(function (m) {
					var hidden_modules = home_settings.hidden_modules || [];
					m.hidden = hidden_modules.includes(m.module_name);

					var links = home_settings.links && home_settings.links[m.module_name];

					if (links) {
						links = JSON.parse(links);

						var default_links = m.links.map(function (link) { return link.name; });
						m.links = m.links.map(function (link) {
							link.hidden = !links.includes(link.name);
							return link;
						});
						var new_links = links
							.filter(function (link) { return !default_links.includes(link); })
							.filter(Boolean)
							.map(function (link) {
								var new_link = { name: link, label: link, type: 'doctype' };
								new_link.route = generate_route(new_link);
								return new_link;
							});
						m.links = m.links.concat(new_links);
					}

					return m;
				});
			},
			get_modules_for_category: function get_modules_for_category(category) {
				return this.modules.filter(function (m) { return m.category === category && !m.hidden; });
			},
			show_hide_cards_dialog: function show_hide_cards_dialog() {
				var this$1 = this;

				var fields = this.module_categories.map(function (category) {
					var modules = this$1.modules.filter(function (m) { return m.category === category; });
					var options = modules.map(
						function (m) { return ({ label: m.label, value: m.module_name, checked: !m.hidden }); }
					);
					return {
						label: category,
						fieldname: category,
						fieldtype: 'MultiCheck',
						options: options,
						columns: 2
					}
				});
				var d = new frappe.ui.Dialog({
					title: __('Show / Hide Cards'),
					fields: fields.filter(function (f) { return f.options.length > 0; }),
					primary_action_label: __('Save'),
					primary_action: function (values) {
						var all_modules = this$1.modules.map(function (m) { return m.module_name; });
						var modules_to_show = Object.keys(values).map(function (k) { return values[k]; }).flatMap(function (m) { return m; });
						var modules_to_hide = all_modules.filter(function (m) { return !modules_to_show.includes(m); });
						d.hide();

						frappe.call('frappe.desk.moduleview.hide_modules_from_desktop', {
							modules: modules_to_hide
						})
						.then(function (r) { return r.message; })
						.then(function (hs) { return this$1.update_modules_with_home_settings(hs); });
					}
				});

				d.show();
			}
		}
	};

	/* script */
	            var __vue_script__$9 = script$9;
	            
	/* template */
	var __vue_render__$9 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _vm.home_settings_fetched
	    ? _c(
	        "div",
	        { staticClass: "modules-page-container" },
	        [
	          _c(
	            "a",
	            {
	              staticClass: "btn-show-hide text-muted text-medium",
	              on: { click: _vm.show_hide_cards_dialog }
	            },
	            [_vm._v("\n\t\t" + _vm._s(_vm.__("Show / Hide Cards")) + "\n\t")]
	          ),
	          _vm._v(" "),
	          _vm._l(_vm.module_categories, function(category, i) {
	            return _c(
	              "div",
	              { key: category, staticClass: "modules-section" },
	              [
	                _vm.get_modules_for_category(category).length
	                  ? _c("desk-section", {
	                      attrs: {
	                        category: category,
	                        modules: _vm.get_modules_for_category(category)
	                      },
	                      on: {
	                        update_home_settings: function(hs) {
	                          return _vm.update_modules_with_home_settings(hs)
	                        }
	                      }
	                    })
	                  : _vm._e()
	              ],
	              1
	            )
	          })
	        ],
	        2
	      )
	    : _vm._e()
	};
	var __vue_staticRenderFns__$9 = [];
	__vue_render__$9._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$9 = function (inject) {
	    if (!inject) { return }
	    inject("data-v-8d8fb888_0", { source: ".modules-page-container[data-v-8d8fb888] {\n  position: relative;\n  margin-top: 40px;\n  margin-bottom: 30px;\n  padding-top: 1px;\n}\n.modules-section[data-v-8d8fb888] {\n  position: relative;\n  margin-top: 30px;\n}\n.btn-show-hide[data-v-8d8fb888] {\n  position: absolute;\n  right: 0;\n  top: 39px;\n  z-index: 1;\n}\n.toolbar-underlay[data-v-8d8fb888] {\n  margin: 70px;\n}\n", map: {"version":3,"sources":["Desktop.vue"],"names":[],"mappings":"AAAA;EACE,kBAAkB;EAClB,gBAAgB;EAChB,mBAAmB;EACnB,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;AACZ;AACA;EACE,YAAY;AACd","file":"Desktop.vue","sourcesContent":[".modules-page-container {\n  position: relative;\n  margin-top: 40px;\n  margin-bottom: 30px;\n  padding-top: 1px;\n}\n.modules-section {\n  position: relative;\n  margin-top: 30px;\n}\n.btn-show-hide {\n  position: absolute;\n  right: 0;\n  top: 39px;\n  z-index: 1;\n}\n.toolbar-underlay {\n  margin: 70px;\n}\n"]}, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$9 = "data-v-8d8fb888";
	  /* module identifier */
	  var __vue_module_identifier__$9 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$9 = false;
	  /* component normalizer */
	  function __vue_normalize__$9(
	    template, style, script,
	    scope, functional, moduleIdentifier,
	    createInjector, createInjectorSSR
	  ) {
	    var component = (typeof script === 'function' ? script.options : script) || {};

	    // For security concerns, we use only base name in production mode.
	    component.__file = "/home/frappe/frappe-bench/apps/frappe/frappe/public/js/frappe/views/components/Desktop.vue";

	    if (!component.render) {
	      component.render = template.render;
	      component.staticRenderFns = template.staticRenderFns;
	      component._compiled = true;

	      if (functional) { component.functional = true; }
	    }

	    component._scopeId = scope;

	    {
	      var hook;
	      if (style) {
	        hook = function(context) {
	          style.call(this, createInjector(context));
	        };
	      }

	      if (hook !== undefined) {
	        if (component.functional) {
	          // register for functional component in vue file
	          var originalRender = component.render;
	          component.render = function renderWithStyleInjection(h, context) {
	            hook.call(context);
	            return originalRender(h, context)
	          };
	        } else {
	          // inject component registration as beforeCreate hook
	          var existing = component.beforeCreate;
	          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	      }
	    }

	    return component
	  }
	  /* style inject */
	  function __vue_create_injector__$8() {
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var styles = __vue_create_injector__$8.styles || (__vue_create_injector__$8.styles = {});
	    var isOldIE =
	      typeof navigator !== 'undefined' &&
	      /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	    return function addStyle(id, css) {
	      if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) { return } // SSR styles are present.

	      var group = isOldIE ? css.media || 'default' : id;
	      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

	      if (!style.ids.includes(id)) {
	        var code = css.source;
	        var index = style.ids.length;

	        style.ids.push(id);

	        if (isOldIE) {
	          style.element = style.element || document.querySelector('style[data-group=' + group + ']');
	        }

	        if (!style.element) {
	          var el = style.element = document.createElement('style');
	          el.type = 'text/css';

	          if (css.media) { el.setAttribute('media', css.media); }
	          if (isOldIE) {
	            el.setAttribute('data-group', group);
	            el.setAttribute('data-next-index', '0');
	          }

	          head.appendChild(el);
	        }

	        if (isOldIE) {
	          index = parseInt(style.element.getAttribute('data-next-index'));
	          style.element.setAttribute('data-next-index', index + 1);
	        }

	        if (style.element.styleSheet) {
	          style.parts.push(code);
	          style.element.styleSheet.cssText = style.parts
	            .filter(Boolean)
	            .join('\n');
	        } else {
	          var textNode = document.createTextNode(code);
	          var nodes = style.element.childNodes;
	          if (nodes[index]) { style.element.removeChild(nodes[index]); }
	          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }
	          else { style.element.appendChild(textNode); }
	        }
	      }
	    }
	  }
	  /* style inject SSR */
	  

	  
	  var Desktop = __vue_normalize__$9(
	    { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
	    __vue_inject_styles__$9,
	    __vue_script__$9,
	    __vue_scope_id__$9,
	    __vue_is_functional_template__$9,
	    __vue_module_identifier__$9,
	    __vue_create_injector__$8,
	    undefined
	  );

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors

	frappe.provide('frappe.views.pageview');
	frappe.provide("frappe.standard_pages");

	frappe.views.pageview = {
		with_page: function(name, callback) {
			if(in_list(Object.keys(frappe.standard_pages), name)) {
				if(!frappe.pages[name]) {
					frappe.standard_pages[name]();
				}
				callback();
				return;
			}

			if((locals.Page && locals.Page[name] && locals.Page[name].script) || name==window.page_name) {
				// already loaded
				callback();
			} else if(localStorage["_page:" + name] && frappe.boot.developer_mode!=1) {
				// cached in local storage
				frappe.model.sync(JSON.parse(localStorage["_page:" + name]));
				callback();
			} else {
				// get fresh
				return frappe.call({
					method: 'frappe.desk.desk_page.getpage',
					args: {'name':name },
					callback: function(r) {
						if(!r.docs._dynamic_page) {
							localStorage["_page:" + name] = JSON.stringify(r.docs);
						}
						callback();
					},
					freeze: true,
				});
			}
		},
		show: function(name) {
			if(!name) {
				name = (frappe.boot ? frappe.boot.home_page : window.page_name);

				if(name === "desktop") {
					if(!frappe.pages.desktop) {
						var page = frappe.container.add_page('desktop');
						var container = $('<div class="container"></div>').appendTo(page);
						container = $('<div></div>').appendTo(container);

						new Vue({
							el: container[0],
							render: function (h) { return h(Desktop); }
						});
					}

					frappe.container.change_to('desktop');
					frappe.utils.set_title(__('Home'));
					return;
				}
			}
			frappe.model.with_doctype("Page", function() {
				frappe.views.pageview.with_page(name, function(r) {
					if(r && r.exc) {
						if(!r['403'])
							{ frappe.show_not_found(name); }
					} else if(!frappe.pages[name]) {
						new frappe.views.Page(name);
					}
					frappe.container.change_to(name);
				});
			});
		}
	};

	frappe.views.Page = Class.extend({
		init: function(name) {
			this.name = name;
			var me = this;
			// web home page
			if(name==window.page_name) {
				this.wrapper = document.getElementById('page-' + name);
				this.wrapper.label = document.title || window.page_name;
				this.wrapper.page_name = window.page_name;
				frappe.pages[window.page_name] = this.wrapper;
			} else {
				this.pagedoc = locals.Page[this.name];
				if(!this.pagedoc) {
					frappe.show_not_found(name);
					return;
				}
				this.wrapper = frappe.container.add_page(this.name);
				this.wrapper.label = this.pagedoc.title || this.pagedoc.name;
				this.wrapper.page_name = this.pagedoc.name;

				// set content, script and style
				if(this.pagedoc.content)
					{ this.wrapper.innerHTML = this.pagedoc.content; }
				frappe.dom.eval(this.pagedoc.__script || this.pagedoc.script || '');
				frappe.dom.set_style(this.pagedoc.style || '');
			}

			this.trigger_page_event('on_page_load');
			// set events
			$(this.wrapper).on('show', function() {
				window.cur_frm = null;
				me.trigger_page_event('on_page_show');
				me.trigger_page_event('refresh');
			});
		},
		trigger_page_event: function(eventname) {
			var me = this;
			if(me.wrapper[eventname]) {
				me.wrapper[eventname](me.wrapper);
			}
		}
	});

	frappe.show_not_found = function(page_name) {
		frappe.show_message_page({
			page_name: page_name,
			message: __("Sorry! I could not find what you were looking for."),
			img: "/assets/frappe/images/ui/bubble-tea-sorry.svg"
		});
	};

	frappe.show_not_permitted = function(page_name) {
		frappe.show_message_page({
			page_name: page_name,
			message: __("Sorry! You are not permitted to view this page."),
			img: "/assets/frappe/images/ui/bubble-tea-sorry.svg",
			// icon: "octicon octicon-circle-slash"
		});
	};

	frappe.show_message_page = function(opts) {
		// opts can include `page_name`, `message`, `icon` or `img`
		if(!opts.page_name) {
			opts.page_name = frappe.get_route_str();
		}

		if(opts.icon) {
			opts.img = repl('<span class="%(icon)s message-page-icon"></span> ', opts);
		} else if (opts.img) {
			opts.img = repl('<img src="%(img)s" class="message-page-image">', opts);
		}

		var page = frappe.pages[opts.page_name] || frappe.container.add_page(opts.page_name);
		$(page).html(
			repl('<div class="page message-page">\
			<div class="text-center message-page-content">\
				%(img)s\
				<p class="lead">%(message)s</p>\
				<a class="btn btn-default btn-sm btn-home" href="#">%(home)s</a>\
			</div>\
		</div>', {
					img: opts.img || "",
					message: opts.message || "",
					home: __("Home")
				})
		);

		frappe.container.change_to(opts.page_name);
	};

	frappe.views.ModulesFactory = class ModulesFactory extends frappe.views.Factory {
		show() {
			if (frappe.pages.modules) {
				frappe.container.change_to('modules');
			} else {
				this.make('modules');
			}
		}

		make(page_name) {
			var this$1 = this;

			var assets = [
				'/assets/js/modules.min.js'
			];

			frappe.require(assets, function () {
				frappe.modules.home = new frappe.modules.Home({
					parent: this$1.make_page(true, page_name)
				});
			});
		}
	};

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt
	frappe.provide('frappe.search');

	frappe.search.AwesomeBar = Class.extend({
		setup: function(element) {
			var me = this;

			var $input = $(element);
			var input = $input.get(0);

			this.options = [];
			this.global_results = [];

			var awesomplete = new Awesomplete(input, {
				minChars: 0,
				maxItems: 99,
				autoFirst: true,
				list: [],
				filter: function(text, term) {
					return true;
				},
				data: function(item, input) {
					return {
						label: (item.index || ""),
						value: item.value
					};
				},
				item: function(item, term) {
					var d = this.get_item(item.value);
					var name = __(d.label || d.value);
					var html = '<span>' + name + '</span>';
					if(d.description && d.value!==d.description) {
						html += '<br><span class="text-muted ellipsis">' + __(d.description) + '</span>';
					}
					return $('<li></li>')
						.data('item.autocomplete', d)
						.html('<a style="font-weight:normal"><p>' + html + '</p></a>')
						.get(0);
				},
				sort: function(a, b) {
					return (b.label - a.label);
				}
			});

			// Added to aid UI testing of global search
			input.awesomplete = awesomplete;

			$input.on("input", function(e) {
				var value = e.target.value;
				var txt = value.trim().replace(/\s\s+/g, ' ');
				var last_space = txt.lastIndexOf(' ');
				me.global_results = [];
				// if(txt && txt.length > 1) {
				// 	me.global.get_awesome_bar_options(txt.toLowerCase(), me);
				// }

				var $this = $(this);
				clearTimeout($this.data('timeout'));

				$this.data('timeout', setTimeout(function(){
					me.options = [];
					if(txt && txt.length > 1) {
						if(last_space !== -1) {
							me.set_specifics(txt.slice(0,last_space), txt.slice(last_space+1));
						}
						me.add_defaults(txt);
						me.options = me.options.concat(me.build_options(txt));
						me.options = me.options.concat(me.global_results);
					} else {
						me.options = me.options.concat(
							me.deduplicate(frappe.search.utils.get_recent_pages(txt || "")));
						me.options = me.options.concat(frappe.search.utils.get_frequent_links());
					}
					me.add_help();

					awesomplete.list = me.deduplicate(me.options);
				}, 100));

			});

			var open_recent = function() {
				if (!this.autocomplete_open) {
					$(this).trigger("input");
				}
			};
			$input.on("focus", open_recent);

			$input.on("awesomplete-open", function(e) {
				me.autocomplete_open = e.target;
			});

			$input.on("awesomplete-close", function(e) {
				me.autocomplete_open = false;
			});

			$input.on("awesomplete-select", function(e) {
				var o = e.originalEvent;
				var value = o.text.value;
				var item = awesomplete.get_item(value);

				if(item.route_options) {
					frappe.route_options = item.route_options;
				}

				if(item.onclick) {
					item.onclick(item.match);
				} else {
					var previous_hash = window.location.hash;
					frappe.set_route(item.route);

					// hashchange didn't fire!
					if (window.location.hash == previous_hash) {
						frappe.route();
					}
				}
				$input.val("");
			});

			$input.on("awesomplete-selectcomplete", function(e) {
				$input.val("");
			});
			frappe.search.utils.setup_recent();
		},

		add_help: function() {
			this.options.push({
				value: __("Help on Search"),
				index: -10,
				default: "Help",
				onclick: function() {
					var txt = '<table class="table table-bordered">\
					<tr><td style="width: 50%">'+__('Create a new record')+'</td><td>'+
							__("new type of document")+'</td></tr>\
					<tr><td>'+__("List a document type")+'</td><td>'+
							__("document type..., e.g. customer")+'</td></tr>\
					<tr><td>'+__("Search in a document type")+'</td><td>'+
							__("text in document type")+'</td></tr>\
					<tr><td>'+__("Open a module or tool")+'</td><td>'+
							__("module name...")+'</td></tr>\
					<tr><td>'+__("Calculate")+'</td><td>'+
							__("e.g. (55 + 434) / 4 or =Math.sin(Math.PI/2)...")+'</td></tr>\
				</table>';
					frappe.msgprint(txt, __("Search Help"));
				}
			});
		},

		set_specifics: function(txt, end_txt) {
			var me = this;
			var results = this.build_options(txt);
			results.forEach(function(r) {
				if(r.type && (r.type).toLowerCase().indexOf(end_txt.toLowerCase()) === 0) {
					me.options.push(r);
				}
			});
		},

		add_defaults: function(txt) {
			this.make_global_search(txt);
			this.make_search_in_current(txt);
			this.make_calculator(txt);
		},

		build_options: function(txt) {
			var options = frappe.search.utils.get_creatables(txt).concat(
				frappe.search.utils.get_search_in_list(txt),
				frappe.search.utils.get_doctypes(txt),
				frappe.search.utils.get_reports(txt),
				frappe.search.utils.get_pages(txt),
				frappe.search.utils.get_modules(txt),
				frappe.search.utils.get_recent_pages(txt || ""),
				frappe.search.utils.get_executables(txt)
			);
			var out = this.deduplicate(options);
			return out.sort(function(a, b) {
				return b.index - a.index;
			});
		},

		deduplicate: function(options) {
			var out = [], routes = [];
			options.forEach(function(option) {
				if(option.route) {
					if(option.route[0] === "List" && option.route[2] !== 'Report') {
						option.route.splice(2);
					}
					var str_route = (typeof option.route==='string') ?
						option.route : option.route.join('/');
					if(routes.indexOf(str_route)===-1) {
						out.push(option);
						routes.push(str_route);
					} else {
						var old = routes.indexOf(str_route);
						if(out[old].index < option.index && !option.recent) {
							out[old] = option;
						}
					}
				} else {
					out.push(option);
					routes.push("");
				}
			});
			return out;
		},

		set_global_results: function(global_results, txt) {
			this.global_results = this.global_results.concat(global_results);
		},

		make_global_search: function(txt) {
			this.options.push({
				label: __("Search for '{0}'", [txt.bold()]),
				value: __("Search for '{0}'", [txt]),
				match: txt,
				index: 100,
				default: "Search",
				onclick: function() {
					frappe.searchdialog.search.init_search(txt, "global_search");
				}
			});
		},

		make_search_in_current: function(txt) {
			var route = frappe.get_route();
			if(route[0]==="List" && txt.indexOf(" in") === -1) {
				// search in title field
				var meta = frappe.get_meta(frappe.container.page.list_view.doctype);
				var search_field = meta.title_field || "name";
				var options = {};
				options[search_field] = ["like", "%" + txt + "%"];
				this.options.push({
					label: __('Find {0} in {1}', [txt.bold(), __(route[1]).bold()]),
					value: __('Find {0} in {1}', [txt, __(route[1])]),
					route_options: options,
					onclick: function() {
						cur_list.show();
					},
					index: 90,
					default: "Current",
					match: txt
				});
			}
		},

		make_calculator: function(txt) {
			var first = txt.substr(0,1);
			if(first==parseInt(first) || first==="(" || first==="=") {
				if(first==="=") {
					txt = txt.substr(1);
				}
				try {
					var val = eval(txt);
					var formatted_value = __('{0} = {1}', [txt, (val + '').bold()]);
					this.options.push({
						label: formatted_value,
						value: __('{0} = {1}', [txt, val]),
						match: val,
						index: 80,
						default: "Calculator",
						onclick: function() {
							frappe.msgprint(formatted_value, "Result");
						}
					});
				} catch(e) {
					// pass
				}
			}
		},
	});

	frappe.provide('frappe.search');

	frappe.search.SearchDialog = Class.extend({
		init: function(opts) {
			$.extend(this, opts);
			this.make();
		},

		make: function() {
			var d = new frappe.ui.Dialog();
			$(d.header).html($(frappe.render_template("search_header")));
			this.search_dialog = d;
			this.$search_modal = $(d.$wrapper).addClass('search-dialog');
			this.$modal_body = $(d.body);
			this.$input = this.$search_modal.find(".search-input");
			this.setup();
		},

		setup: function() {
			this.modal_state = 0;
			this.current_keyword = "";
			this.more_count = 20;
			this.full_lists = {};
			this.nav_lists = {};
			this.bind_input();
			this.bind_events();
		},

		update: function($r) {
			this.$search_modal.find('.loading-state').addClass('hide');
			this.$modal_body.append($r);
			if(this.$modal_body.find('.search-results').length > 1) {
				this.$modal_body.find('.search-results').first().addClass("hide");
				$r.removeClass("hide");
				this.$modal_body.find('.search-results').first().remove();
			} else {
				$r.removeClass("hide");
			}
		},

		put_placeholder: function(status_text) {
			var $placeholder = $('<div class="row search-results hide">' +
					'<div class="empty-state"><span style="margin-top: -100px">' +
					'<i class="mega-octicon octicon-telescope status-icon">' +
					'<i class="fa fa-square cover twinkle-one hide" style="left:0px;"></i>'+
					'<i class="fa fa-square cover twinkle-two hide" style="left:8px; top:5px;"></i>'+
					'<i class="fa fa-square cover twinkle-three hide" style="left:13px; top:-3px;"></i></i>'+
					'<p>' + status_text + '</p></span></div>' +
				'</div>');
			this.update($placeholder);
		},

		bind_input: function() {
			var me = this;
			this.$input.on("input", function() {
				var $this = $(this);
				clearTimeout($this.data('timeout'));
				$this.data('timeout', setTimeout(function() {
					if(me.$input.val() === me.current_keyword) { return; }
					var keywords = me.$input.val();
					if(keywords.length > 1) {
						me.get_results(keywords);
					} else {
						me.current_keyword = "";
						me.put_placeholder(me.search.empty_state_text);
					}
				}, 300));
			});
		},

		bind_events: function() {
			var me = this;

			// Sidebar
			this.$modal_body.on('click', '.list-link',  function() {
				var link = $(this);
				me.$modal_body.find('.search-sidebar').find(".list-link").removeClass("active select");
				link.addClass("active select");
				var type = link.attr('data-category');
				me.$modal_body.find('.results-area').empty().html(me.full_lists[type]);
				me.$modal_body.find('.module-section-link').first().focus();
				me.current_type = type;
			});

			// Summary more links
			this.$modal_body.on('click', '.section-more', function() {
				var type = $(this).attr('data-category');
				me.$modal_body.find('.search-sidebar').find('*[data-category="'+ type +'"]').trigger('click');
			});

			// Back-links (mobile-view)
			this.$modal_body.on('click', '.all-results-link', function() {
				me.$modal_body.find('.search-sidebar').find('*[data-category="All Results"]').trigger('click');
			});

			// Full list more links
			this.$modal_body.on('click', '.list-more', function() {
				var type = $(this).attr('data-category');
				var fetch_type = $(this).attr('data-search');
				var current_count = me.$modal_body.find('.result').length;
				if(fetch_type === "Global") {
					frappe.search.utils.get_global_results(me.current_keyword,
						current_count, me.more_count, type)
						.then(function(doctype_results) {
							me.add_more_results(doctype_results);
						}, function (err) {
							console.error(err);
						});
				} else {
					var results = me.nav_lists[type].slice(0, me.more_count);
					me.nav_lists[type].splice(0, me.more_count);
					me.add_more_results([{title: type, results: results}]);
				}
			});

			// Switch to global search link
			this.$modal_body.on('click', '.switch-to-global-search', function() {
				me.search = me.searches['global_search'];
				me.$input.attr("placeholder", me.search.input_placeholder);
				me.put_placeholder(me.search.empty_state_text);
				me.get_results(me.current_keyword);
			});

			// Help results
			// this.$modal_body.on('click', 'a[data-path]', frappe.help.show_results);
			this.bind_keyboard_events();
		},

		bind_keyboard_events: function() {
			var me = this;
			this.$search_modal.on('keydown', function(e) {

				if(me.$modal_body.find('.list-link').length > 1) {
					if(me.modal_state === 0) {
						// DOWN and UP keys navigate sidebar
						var ref = frappe.ui.keyCode;
						var UP_ARROW = ref.UP_ARROW;
						var DOWN_ARROW = ref.DOWN_ARROW;
						var TAB = ref.TAB;
						if(e.which === DOWN_ARROW || e.which === TAB) {
							e.preventDefault();
							var $link = me.$modal_body.find('.list-link.select').next();
							if($link.length > 0) {
								// me.$modal_body.find('.list-link').removeClass('select');
								// $link.addClass('select');
								$link.trigger('click');
							}
						} else if(e.which === UP_ARROW) {
							e.preventDefault();
							var $link = me.$modal_body.find('.list-link.select').prev();
							if($link.length > 0) {
								$link.trigger('click');
							}
						}
					}
				}

				if(!me.$input.is(":focus")) {
					me.$input.focus();
				}
			});

		},

		init_search: function(keywords, search_type) {
			var me = this;
			this.search = this.searches[search_type];
			this.$input.attr("placeholder", this.search.input_placeholder);
			this.put_placeholder(this.search.empty_state_text);
			this.get_results(keywords);
			this.search_dialog.show();
			this.$input.val(keywords);
			setTimeout(function() { me.$input.select(); }, 500);
		},

		get_results: function(keywords) {
			this.current_keyword = keywords;
			if(this.$modal_body.find('.empty-state').length > 0) {
				this.put_placeholder(__("Searching ..."));
				this.$modal_body.find('.cover').removeClass('hide');
			} else {
				this.$search_modal.find('.loading-state').removeClass('hide');
			}
			this.search.get_results(keywords, this.parse_results.bind(this));
		},

		parse_results: function(result_sets, keyword) {
			result_sets = result_sets.filter(function(set) {
				return set.results.length > 0;
			});
			if(result_sets.length > 0) {
				this.render_data(result_sets);
			} else {
				this.put_placeholder(this.search.no_results_status(keyword));
			}
		},

		render_data: function(result_sets) {
			var me = this;
			var $search_results = $(frappe.render_template("search")).addClass('hide');
			var $sidebar = $search_results.find(".search-sidebar").empty();
			var sidebar_item_html = '<li class="module-sidebar-item list-link" data-category="{0}">' +
				'<a><span class="ellipsis">{0}</span><i class="octicon octicon-chevron-right"' +
				'></a></li>';

			this.modal_state = 0;
			this.full_lists = {	'All Results': $('<div class="module-body results-summary"></div>') };
			this.nav_lists = {};

			result_sets.forEach(function(set) {
				$sidebar.append($(__(sidebar_item_html, [set.title])));
				me.add_section_to_summary(set.title, set.results);
				me.full_lists[set.title] = me.render_full_list(set.title, set.results, set.fetch_type);
			});

			if(result_sets.length > 1) {
				$sidebar.prepend($(__(sidebar_item_html, ["All Results"])));
			}

			this.update($search_results.clone());
			this.$modal_body.find('.list-link').first().trigger('click');
		},

		render_full_list: function(type, results, fetch_type) {
			var me = this, max_length = 20;
			var $results_list = $(' <div class="module-body"><div class="row module-section full-list '+
				type+'-section">'+'<div class="col-sm-12 module-section-column">' +
				'<div class="back-link"><a class="all-results-link small"> All Results</a></div>' +
				'<div class="h4 section-head">'+type+'</div>' +
				'<div class="section-body"></div></div></div></div>');

			var $results_col = $results_list.find('.module-section-column');
			for(var i = 0; i < max_length && results.length > 0; i++) {
				$results_col.append(me.render_result(type, results.shift()));
			}
			if(results.length > 0) {
				if(fetch_type === "Nav") { this.nav_lists[type] = results; }
				$results_col.append('<a class="list-more small" data-search="'+ fetch_type +
					'" data-category="'+ type + '" data-count="' + max_length +
					'" style="margin-top:10px">'+__("More...")+'</a>');
			}
			return $results_list;
		},

		add_section_to_summary: function(type, results) {
			var me = this;
			var are_expansive = false;
			var margin_more = "10px";
			for(var i = 0; i < results.length; i++) {
				if(results[i]["description"] || false) {
					are_expansive = true;
					break;
				}
			}
			if(results[0].image) { margin_more = "20px"; }
			var ref = are_expansive ? [3, "12"] : [4, "6"];
			var section_length = ref[0];
			var col_width = ref[1];

			// check state of last summary section
			if(this.full_lists['All Results'].find('.module-section').last().find('.col-sm-6').length !== 1
				|| are_expansive) {
				this.full_lists['All Results'].append($('<div class="row module-section"></div>'));
			}
			var $results_col = $(("<div class=\"col-sm-" + col_width + " module-section-column\" data-type=\"" + type + "\">\n\t\t\t<div class=\"h4 section-head\">" + type + "</div>\n\t\t\t<div class=\"section-body\"></div>\n\t\t\t</div>"));
			results.slice(0, section_length).forEach(function(result) {
				$results_col.append(me.render_result(type, result));
			});
			if(results.length > section_length) {
				$results_col.append(("<div style=\"margin-top:" + margin_more + "\"><a class=\"section-more small\"\n\t\t\t\tdata-category=\"" + type + "\">" + (__("More...")) + "</a></div>"));
			}

			this.full_lists['All Results'].find('.module-section').last().append($results_col);
		},

		render_result: function(type, result) {
			var this$1 = this;

			var $result = $('<div class="result '+ type +'-result"></div>');

			function get_link(result) {
				var link;
				if(result.route) {
					link = 'href="#'+result.route.join('/')+'" ';
				} else if (result.data_path) {
					link = 'data-path="'+result.data_path+'"';
				} else {
					link = "";
				}
				return link;
			}

			if(result.image) {
				$result.append('<a '+ get_link(result) +
					'><div class="result-image"><img data-name="' + result.label
						+ '" src="'+ result.image +'" alt="' + result.label + '"></div></a>');
			} else if (result.image === null) {
				$result.append('<a '+ get_link(result) +
					'><div class="result-image"><div class="flex-text"><span>'
						+ frappe.get_abbr(result.label) +'</span></div></div></a>');
			}

			var title_html = '<a '+ get_link(result) +' class="module-section-link small">'+ result.label +'</a>';
			var $result_text = $('<div style="display: inline-block;"></div>');
			if(result.description) {
				$result_text.append($('<b>' + title_html + '</b>'));
				$result_text.append('<p class="small">'+ result.description +'</p>');
			} else {
				$result_text.append($(title_html));
				if(result.route_options) {
					frappe.route_options = result.route_options;
				}
				$result.on('click', function (e) {
					this$1.search_dialog.hide();
					if(result.onclick) {
						result.onclick(result.match);
					} else {
						var previous_hash = window.location.hash;
						frappe.set_route(result.route);

						// hashchange didn't fire!
						if (window.location.hash == previous_hash) {
							frappe.route();
						}
					}
				});
			}

			$result.append($result_text);

			if(result.subtypes) {
				result.subtypes.forEach(function(subtype) {
					$result.append(subtype);
				});
			}

			return $result;
		},

		add_more_results: function(results_set) {
			var me = this;
			var more_results = $('<div class="more-results last"></div>');
			results_set[0].results.forEach(function(result) {
				more_results.append(me.render_result(results_set[0].title, result));
			});
			this.$modal_body.find('.list-more').before(more_results);

			if(results_set[0].results.length < this.more_count) {
				// hide more button and add a result count
				this.$modal_body.find('.list-more').hide();
				var no_of_results = this.$modal_body.find('.result').length;
				var no_of_results_cue = $('<p class="results-status text-muted small">'+
					no_of_results +' results found</p>');
				this.$modal_body.find(".more-results:last").append(no_of_results_cue);
			}
			this.$modal_body.find('.more-results.last').slideDown(200, function() {});
		},

		// Search objects
		searches: {
			global_search: {
				input_placeholder: __("Global Search"),
				empty_state_text: __("Search for anything"),
				no_results_status: function (keyword) { return __("<p>No results found for '" + keyword + "' in Global Search</p>"); },

				get_results: function(keywords, callback) {
					var start = 0, limit = 1000;
					var results = frappe.search.utils.get_nav_results(keywords);
					frappe.search.utils.get_global_results(keywords, start, limit)
						.then(function(global_results) {
							results = results.concat(global_results);
							callback(results, keywords);
						}, function (err) {
							console.error(err);
						});
				}
			},
		},

	});

	frappe.templates['search'] = '<div class="row search-results">     <div class="col-md-2 col-sm-2 hidden-xs layout-side-section">         <ul class="module-sidebar-nav overlay-sidebar nav nav-pills nav-stacked search-sidebar"></ul>     </div>     <div class="col-md-10 col-sm-10 layout-main-section results-area"></div> </div>';

	frappe.templates['search_header'] = '<div class="search-header">     <i class="octicon octicon-search"></i>     <input type="text" class="form-control search-input" style="padding-left: 15px">     <p class="loading-state hide" style="margin: 0px 20px; color:#d4d9dd">{%= __("Searching")%}&nbsp...</p>     <a type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</a> </div>';

	frappe.provide('frappe.search');

	frappe.search.utils = {
		setup_recent: function() {
			this.recent = JSON.parse(frappe.boot.user.recent || "[]") || [];
		},

		get_recent_pages: function(keywords) {
			if (keywords === null) { keywords = ''; }
			var me = this, values = [], options = [];

			function find(list, keywords, process) {
				list.forEach(function(item, i) {
					var _item = ($.isArray(item)) ? item[0] : item;
					_item = __(_item || '').toLowerCase().replace(/-/g, " ");

					if(keywords===_item || _item.indexOf(keywords) !== -1) {
						var option = process(item);

						if(option) {
							if($.isPlainObject(option)) {
								option = [option];
							}
							option.forEach(function(o) {
								o.match = item; o.recent = true;
							});

							options = option.concat(options);
						}
					}
				});
			}

			me.recent.forEach(function(doctype, i) {
				values.push([doctype[1], ['Form', doctype[0], doctype[1]]]);
			});

			values = values.reverse();

			frappe.route_history.forEach(function(route, i) {
				if(route[0]==='Form') {
					values.push([route[2], route]);
				} else if(['List', 'Tree', 'modules', 'query-report'].includes(route[0]) || route[2]==='Report') {
					if(route[1]) {
						values.push([route[1], route]);
					}
				} else if(route[0]) {
					values.push([frappe.route_titles[route.join('/')] || route[0], route]);
				}
			});

			find(values, keywords, function(match) {
				var out = {
					route: match[1]
				};
				if (match[1][0]==='Form') {
					if (match[1].length > 2 && match[1][1] !== match[1][2]) {
						out.label = __(match[1][1]) + " " + match[1][2].bold();
						out.value = __(match[1][1]) + " " + match[1][2];
					} else {
						out.label = __(match[1][1]).bold();
						out.value = __(match[1][1]);
					}
				} else if (['List', 'Tree', 'modules', 'query-report'].includes(match[1][0]) && (match[1].length > 1)) {
					var type = match[1][0], label = type;
					if(type==='modules') { label = 'Module'; }
					else if(type==='query-report' || match[1][2] ==='Report') { label = 'Report'; }
					out.label = __(match[1][1]).bold() + " " + __(label);
					out.value = __(match[1][1]) + " " + __(label);
				} else if (match[0]) {
					out.label = match[0].bold();
					out.value = match[0];
				} else {
					// eslint-disable-next-line
					console.log('Illegal match', match);
				}
				out.index = 80;
				return out;
			});

			return options;
		},

		get_frequent_links: function get_frequent_links() {
			var options = [];
			frappe.boot.frequently_visited_links.forEach(function (link) {
				var label = frappe.utils.get_route_label(link.route);
				options.push({
					'route': link.route,
					'label': label,
					'value': label,
					'index': link.count,
				});
			});
			if (!options.length) {
				return this.get_recent_pages('');
			}
			return options;
		},

		get_search_in_list: function(keywords) {
			var me = this;
			var out = [];
			if(in_list(keywords.split(" "), "in") && (keywords.slice(-2) !== "in")) {
				var parts = keywords.split(" in ");
				frappe.boot.user.can_read.forEach(function(item) {
					if(frappe.boot.user.can_search.includes(item)) {
						var level = me.fuzzy_search(parts[1], item);
						if(level) {
							out.push({
								type: "In List",
								label: __('Find {0} in {1}', [__(parts[0]), me.bolden_match_part(__(item), parts[1])]),
								value: __('Find {0} in {1}', [__(parts[0]), __(item)]),
								route_options: {"name": ["like", "%" + parts[0] + "%"]},
								index: 1 + level,
								route: ["List", item]
							});
						}
					}
				});
			}
			return out;
		},

		get_creatables: function(keywords) {
			var me = this;
			var out = [];
			var firstKeyword = keywords.split(" ")[0];
			if(firstKeyword.toLowerCase() === __("new")) {
				frappe.boot.user.can_create.forEach(function(item) {
					var level = me.fuzzy_search(keywords.substr(4), item);
					if(level) {
						out.push({
							type: "New",
							label: __("New {0}", [me.bolden_match_part(__(item), keywords.substr(4))]),
							value: __("New {0}", [__(item)]),
							index: 1 + level,
							match: item,
							onclick: function() {
								frappe.new_doc(item, true);
							}
						});
					}
				});
			}
			return out;
		},

		get_doctypes: function(keywords) {
			var me = this;
			var out = [];

			var level, target;
			var option = function(type, route, order) {
				return {
					type: type,
					label: me.bolden_match_part(__(target), keywords) + " " + __(type),
					value: __(target + " " + type),
					index: level + order,
					match: target,
					route: route,
				};
			};
			frappe.boot.user.can_read.forEach(function(item) {
				level = me.fuzzy_search(keywords, item);
				if (level) {
					target = item;
					if (in_list(frappe.boot.single_types, item)) {
						out.push(option("", ["Form", item, item], 0.05));

					} else if (frappe.boot.user.can_search.includes(item)) {
						// include 'making new' option
						if (in_list(frappe.boot.user.can_create, item)) {
							var match = item;
							out.push({
								type: "New",
								label: __("New {0}", [me.bolden_match_part(__(item), keywords)]),
								value: __("New {0}", [__(item)]),
								index: level + 0.015,
								match: item,
								onclick: function() {
									frappe.new_doc(match, true);
								}
							});
						}
						if (in_list(frappe.boot.treeviews, item)) {
							out.push(option("Tree", ["Tree", item], 0.05));

						} else {
							out.push(option("List", ["List", item], 0.05));
							if (frappe.model.can_get_report(item)) {
								out.push(option("Report", ["List", item, "Report"], 0.04));
							}
						}
					}
				}
			});
			return out;
		},

		get_reports: function(keywords) {
			var me = this;
			var out = [];
			var route;
			Object.keys(frappe.boot.user.all_reports).forEach(function(item) {
				var level = me.fuzzy_search(keywords, item);
				if(level > 0) {
					var report = frappe.boot.user.all_reports[item];
					if(report.report_type == "Report Builder")
						{ route = ["List", report.ref_doctype, "Report", item]; }
					else
						{ route = ["query-report",  item]; }
					out.push({
						type: "Report",
						label: __("Report {0}" , [me.bolden_match_part(__(item), keywords)]),
						value: __("Report {0}" , [__(item)]),
						index: level,
						route: route
					});
				}
			});
			return out;
		},

		get_pages: function(keywords) {
			var me = this;
			var out = [];
			this.pages = {};
			$.each(frappe.boot.page_info, function(name, p) {
				me.pages[p.title] = p;
				p.name = name;
			});
			Object.keys(this.pages).forEach(function(item) {
				if(item == "Hub" || item == "hub") { return; }
				var level = me.fuzzy_search(keywords, item);
				if(level) {
					var page = me.pages[item];
					out.push({
						type: "Page",
						label: __("Open {0}", [me.bolden_match_part(__(item), keywords)]),
						value: __("Open {0}", [__(item)]),
						match: item,
						index: level,
						route: [page.route || page.name]
					});
				}
			});
			var target = 'Calendar';
			if(__('calendar').indexOf(keywords.toLowerCase()) === 0) {
				out.push({
					type: "Calendar",
					value: __("Open {0}", [__(target)]),
					index: me.fuzzy_search(keywords, 'Calendar'),
					match: target,
					route: ['List', 'Event', target],
				});
			}
			target = 'Hub';
			if(__('hub').indexOf(keywords.toLowerCase()) === 0) {
				out.push({
					type: "Hub",
					value: __("Open {0}", [__(target)]),
					index: me.fuzzy_search(keywords, 'Hub'),
					match: target,
					route: [target, 'Item'],
				});
			}
			if(__('email inbox').indexOf(keywords.toLowerCase()) === 0) {
				out.push({
					type: "Inbox",
					value: __("Open {0}", [__('Email Inbox')]),
					index: me.fuzzy_search(keywords, 'email inbox'),
					match: target,
					route: ['List', 'Communication', 'Inbox'],
				});
			}
			return out;
		},

		get_modules: function(keywords) {
			var me = this;
			var out = [];
			Object.keys(frappe.modules).forEach(function(item) {
				var level = me.fuzzy_search(keywords, item);
				if(level > 0) {
					var module = frappe.modules[item];
					if (module._doctype) { return; }

					// disallow restricted modules
					if (frappe.boot.user.allow_modules &&
						!frappe.boot.user.allow_modules.includes(module.module_name)) {
						return;
					}
					var ret = {
						type: "Module",
						label: __("Open {0}", [me.bolden_match_part(__(item), keywords)]),
						value: __("Open {0}", [__(item)]),
						index: level,
					};
					if(module.link) {
						ret.route = [module.link];
					} else {
						ret.route = ["Module", item];
					}
					out.push(ret);
				}
			});
			return out;
		},

		get_global_results: function(keywords, start, limit, doctype) {
			if ( doctype === void 0 ) doctype = "";

			var me = this;
			function get_results_sets(data) {
				var results_sets = [], result, set;
				function get_existing_set(doctype) {
					return results_sets.find(function(set) {
						return set.title === doctype;
					});
				}

				function make_description(content, doc_name) {
					var parts = content.split(" ||| ");
					var result_max_length = 300;
					var field_length = 120;
					var fields = [];
					var result_current_length = 0;
					var field_text = "";
					for(var i = 0; i < parts.length; i++) {
						var part = parts[i];
						if(part.toLowerCase().indexOf(keywords) !== -1) {
							// If the field contains the keyword
							if(part.indexOf(' &&& ') !== -1) {
								var colon_index = part.indexOf(' &&& ');
								var field_value = part.slice(colon_index + 5);
							} else {
								var colon_index = part.indexOf(' : ');
								var field_value = part.slice(colon_index + 3);
							}
							if(field_value.length > field_length) {
								// If field value exceeds field_length, find the keyword in it
								// and trim field value by half the field_length at both sides
								// ellipsify if necessary
								var field_data = "";
								var index = field_value.indexOf(keywords);
								field_data += index < field_length/2 ? field_value.slice(0, index)
									: '...' + field_value.slice(index - field_length/2, index);
								field_data += field_value.slice(index, index + field_length/2);
								field_data += index + field_length/2 < field_value.length ? "..." : "";
								field_value = field_data;
							}
							var field_name = part.slice(0, colon_index);

							// Find remaining result_length and add field length to result_current_length
							var remaining_length = result_max_length - result_current_length;
							result_current_length += field_name.length + field_value.length + 2;
							if(result_current_length < result_max_length) {
								// We have room, push the entire field
								field_text = '<span class="field-name text-muted">' +
									me.bolden_match_part(field_name, keywords) + ': </span> ' +
									me.bolden_match_part(field_value, keywords);
								if(fields.indexOf(field_text) === -1 && doc_name !== field_value) {
									fields.push(field_text);
								}
							} else {
								// Not enough room
								if(field_name.length < remaining_length){
									// Ellipsify (trim at word end) and push
									remaining_length -= field_name.length;
									field_text = '<span class="field-name text-muted">' +
										me.bolden_match_part(field_name, keywords) + ': </span> ';
									field_value = field_value.slice(0, remaining_length);
									field_value = field_value.slice(0, field_value.lastIndexOf(' ')) + ' ...';
									field_text += me.bolden_match_part(field_value, keywords);
									fields.push(field_text);
								} else {
									// No room for even the field name, skip
									fields.push('...');
								}
								break;
							}
						}
					}
					return fields.join(', ');
				}

				data.forEach(function(d) {
					// more properties
					result = {
						label: d.name,
						value: d.name,
						description: make_description(d.content, d.name),
						route: ['Form', d.doctype, d.name],
					};
					if(d.image || d.image === null){
						result.image = d.image;
					}
					set = get_existing_set(d.doctype);
					if(set) {
						set.results.push(result);
					} else {
						set = {
							title: d.doctype,
							results: [result],
							fetch_type: "Global"
						};
						results_sets.push(set);
					}

				});
				return results_sets;
			}
			return new Promise(function(resolve, reject) {
				frappe.call({
					method: "frappe.utils.global_search.search",
					args: {
						text: keywords,
						start: start,
						limit: limit,
						doctype: doctype
					},
					callback: function(r) {
						if(r.message) {
							resolve(get_results_sets(r.message));
						} else {
							resolve([]);
						}
					}
				});
			});
		},

		get_nav_results: function(keywords) {
			function sort_uniques(array) {
				var routes = [], out = [];
				array.forEach(function(d) {
					if(d.route) {
						if(d.route[0] === "List" && d.route[2]) {
							d.route.splice(2);
						}
						var str_route = d.route.join('/');
						if(routes.indexOf(str_route) === -1) {
							routes.push(str_route);
							out.push(d);
						} else {
							var old = routes.indexOf(str_route);
							if(out[old].index > d.index) {
								out[old] = d;
							}
						}
					} else {
						out.push(d);
					}
				});
				return out.sort(function(a, b) {
					return b.index - a.index;
				});
			}
			var lists = [], setup = [];
			var all_doctypes = sort_uniques(this.get_doctypes(keywords));
			all_doctypes.forEach(function(d) {
				if(d.type === "") {
					setup.push(d);
				} else {
					lists.push(d);
				}
			});
			var in_keyword = keywords.split(" in ")[0];
			return [{
				title: "Recents",
				fetch_type: "Nav",
				results: sort_uniques(this.get_recent_pages(keywords))
			},
			{
				title: "Create a new ...",
				fetch_type: "Nav",
				results: sort_uniques(this.get_creatables(keywords))
			},
			{
				title: "Lists",
				fetch_type: "Nav",
				results: lists
			},
			{
				title: "Reports",
				fetch_type: "Nav",
				results: sort_uniques(this.get_reports(keywords))
			},
			{
				title: "Administration",
				fetch_type: "Nav",
				results: sort_uniques(this.get_pages(keywords))
			},
			{
				title: "Modules",
				fetch_type: "Nav",
				results: sort_uniques(this.get_modules(keywords))
			},
			{
				title: "Setup",
				fetch_type: "Nav",
				results: setup
			},
			{
				title: "Find '" + in_keyword + "' in ... ",
				fetch_type: "Nav",
				results: sort_uniques(this.get_search_in_list(keywords))
			}];
		},

		fuzzy_search: function(keywords, _item) {
			// Returns 10 for case-perfect contain, 0 for not found
			//  	9 for perfect contain,
			//  	0 - 6 for fuzzy contain

			// **Specific use-case step**
			keywords = keywords || '';

			var item = __(_item || '').replace(/-/g, " ");

			var ilen = item.length;
			var klen = keywords.length;
			var length_ratio = klen/ilen;
			var max_skips = 3, max_mismatch_len = 2;

			if (klen > ilen) {
				return 0;
			}

			if(keywords === item || item.toLowerCase().indexOf(keywords) === 0) {
				return 10 + length_ratio;
			}

			if (item.indexOf(keywords) !== -1 && keywords !== keywords.toLowerCase()) {
				return 9 + length_ratio;
			}

			item = item.toLowerCase();
			keywords = keywords.toLowerCase();

			if (item.indexOf(keywords) !== -1) {
				return 8 + length_ratio;
			}

			var skips = 0, mismatches = 0;
			outer: for (var i = 0, j = 0; i < klen; i++) {
				if(mismatches !== 0) { skips++; }
				if(skips > max_skips) { return 0; }
				var k_ch = keywords.charCodeAt(i);
				mismatches = 0;
				while (j < ilen) {
					if (item.charCodeAt(j++) === k_ch) {
						continue outer;
					}
					if(++mismatches > max_mismatch_len)  { return 0 ; }
				}
				return 0;
			}

			// Since indexOf didn't pass, there will be atleast 1 skip
			// hence no divide by zero, but just to be safe
			if((skips + mismatches) > 0) {
				return (5 + length_ratio)/(skips + mismatches);
			} else {
				return 0;
			}
		},

		bolden_match_part: function(str, subseq) {
			var rendered = "";
			if(this.fuzzy_search(subseq, str) === 0) {
				return str;
			} else if(this.fuzzy_search(subseq, str) > 6) {
				var regEx = new RegExp("("+ subseq +")", "ig");
				return str.replace(regEx, '<b>$1</b>');
			} else {
				var str_orig = str;
				var str = str.toLowerCase();
				var str_len = str.length;
				var subseq = subseq.toLowerCase();

				outer: for(var i = 0, j = 0; i < subseq.length; i++) {
					var sub_ch = subseq.charCodeAt(i);
					while(j < str_len) {
						if(str.charCodeAt(j) === sub_ch) {
							var str_char = str_orig.charAt(j);
							if(str_char === str_char.toLowerCase()) {
								rendered += '<b>' + subseq.charAt(i) + '</b>';
							} else {
								rendered += '<b>' + subseq.charAt(i).toUpperCase() + '</b>';
							}
							j++;
							continue outer;
						}
						rendered += str_orig.charAt(j);
						j++;
					}
					return str_orig;
				}
				rendered += str_orig.slice(j);
				return rendered;
			}

		},

		get_executables: function get_executables(keywords) {
			var this$1 = this;

			var results = [];
			this.searchable_functions.forEach(function (item) {
				var target = item.label.toLowerCase();
				var txt = keywords.toLowerCase();
				if (txt === target || target.indexOf(txt) === 0) {
					results.push({
						type: "Executable",
						value:  this$1.bolden_match_part(__(item.label), txt),
						index: this$1.fuzzy_search(txt, target),
						match: item.label,
						onclick: item.action,
					});
				}
			});
			return results;
		},
		make_function_searchable: function make_function_searchable(_function, label) {
			if ( label === void 0 ) label=null;

			if (typeof _function !== 'function') {
				throw new Error('First argument should be a function');
			}

			this.searchable_functions.push({
				'label': label || _function.name,
				'action': _function
			});
		},
		searchable_functions: [],
	};

	frappe.provide('frappe.ui.misc');
	frappe.ui.misc.about = function() {
		if(!frappe.ui.misc.about_dialog) {
			var d = new frappe.ui.Dialog({title: __('Frappe Framework')});

			$(d.body).html(repl("<div>\
		<p>"+__("Open Source Applications for the Web")+"</p>  \
		<p><i class='fa fa-globe fa-fw'></i>\
			Website: <a href='https://frappe.io' target='_blank'>https://frappe.io</a></p>\
		<p><i class='fa fa-github fa-fw'></i>\
			Source: <a href='https://github.com/frappe' target='_blank'>https://github.com/frappe</a></p>\
		<hr>\
		<h4>Installed Apps</h4>\
		<div id='about-app-versions'>Loading versions...</div>\
		<hr>\
		<p class='text-muted'>&copy; Frappe Technologies Pvt. Ltd and contributors </p> \
		</div>", frappe.app));

			frappe.ui.misc.about_dialog = d;

			frappe.ui.misc.about_dialog.on_page_show = function() {
				if(!frappe.versions) {
					frappe.call({
						method: "frappe.utils.change_log.get_versions",
						callback: function(r) {
							show_versions(r.message);
						}
					});
				}
			};

			var show_versions = function(versions) {
				var $wrap = $("#about-app-versions").empty();
				$.each(Object.keys(versions).sort(), function(i, key) {
					var v = versions[key];
					if(v.branch) {
						var text = $.format('<p><b>{0}:</b> v{1} ({2})<br></p>',
							[v.title, v.branch_version || v.version, v.branch]);
					} else {
						var text = $.format('<p><b>{0}:</b> v{1}<br></p>',
							[v.title, v.version]);
					}
					$(text).appendTo($wrap);
				});

				frappe.versions = versions;
			};

		}

		frappe.ui.misc.about_dialog.show();

	};

	frappe.templates['navbar'] = '<div class="navbar navbar-default navbar-fixed-top" role="navigation">  <div class="container">   <div class="navbar-header navbar-desk">    <a class="navbar-brand toggle-sidebar visible-xs visible-sm">     <i class="octicon octicon-three-bars"></i>    </a>    <a class="navbar-brand navbar-home hidden-xs hidden-sm" href="#">     <img src="/assets/frappe/images/frappe-framework-logo.png">    </a>    <ul class="nav navbar-nav" id="navbar-breadcrumbs">    </ul>   </div>   <div class="navbar-center ellipsis" style="display: none;"></div>    <ul class="nav navbar-nav navbar-right">    <li class="visible-xs">     <a class="navbar-search-button" href="#" data-toggle="modal" data-target="#search-modal"><i class="octicon octicon-search"></i></a>    </li>    <li class="dropdown dropdown-navbar-user dropdown-mobile">     <a class="dropdown-toggle" data-toggle="dropdown" href="#"      onclick="return false;">     {{ avatar }}     <span class="ellipsis toolbar-user-fullname hidden-xs hidden-sm">      {%= __("Settings") %}</span>     <b class="caret hidden-xs hidden-sm"></b></a>     <ul class="dropdown-menu" id="toolbar-user" role="menu">      <li><a href="#Form/User/{%= encodeURIComponent(frappe.session.user) %}">       {%= __("My Settings") %}</a></li>      <li class="navbar-reload">       <a href="#" onclick="return frappe.ui.toolbar.clear_cache();">       {%= __("Reload") %}</a></li>      <li><a href="/index" target="_blank" rel="noopener noreferrer">       {%= __("View Website") %}</a></li>      <li class="navbar-toggle-full-width">       <a href="#" onclick="return false">{%= __("Toggle Full Width") %}</a>      </li>      <li><a href="#background_jobs">       {%= __("Background Jobs") %}</a></li>      <li class="divider"></li>      <li><a href="#" onclick="return frappe.app.logout();">       {%= __("Logout") %}</a></li>     </ul>    </li>     <li class="dropdown dropdown-help dropdown-mobile">     <a class="dropdown-toggle" data-toggle="dropdown" href="#"      onclick="return false;"  style="height: 40px;">      <span class="hidden-xs hidden-sm" style="line-height: 24px;">{{ __("Help") }} <b class="caret"></b></span>      <span class="visible-xs visible-sm standard-image"       style="padding: 50% 7px; font-size: 17px; background-color: #fafbfc; font-weight: 100;">?</span>     </a>     <ul class="dropdown-menu" role="menu">      <li id="help-links"></li>      <li class="divider"></li>      <li class="divider documentation-links"></li>      <li><a href="#" onclick="return frappe.ui.toolbar.show_about();">       {%= __("About") %}</a></li>     </ul>    </li>             <li class="frappe-chat-dropdown"></li>         <li class="dropdown dropdown-navbar-new-comments dropdown-mobile">     <a class="btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">      <span class="navbar-new-comments">0</span>     </a>     <ul class="dropdown-menu" id="dropdown-notification" role="menu" style="max-height: 480px; overflow-y: auto;">     </ul>    </li>   </ul>    <div id="search-modal" class="modal fade" role="dialog">    <div class="modal-dialog" style="height: 50px;">     <div class="modal-content">      <div class="modal-header">       <form role="search" onsubmit="return false;">        <div class="input-group" style="width: 100%">         <input id="modal-search" type="text" class="form-control"         placeholder="{%= __("Search or type a command") %}" aria-haspopup="true">         <button type="reset" class="close"><i class="octicon octicon-x"></i></button>        </div>       </form>      </div>     </div>    </div>   </div>    <div class="hidden-xs">    <form class="navbar-form navbar-right" role="search" onsubmit="return false;">      <div class="form-group form-group-sm ui-front">     <input id="navbar-search" type="text" class="form-control"      placeholder="{%= __("Search or type a command") %} {%= __("(Ctrl + G)") %}" aria-haspopup="true">     <span class="octicon octicon-search navbar-search-icon"></span>      </div>    </form>   </div>  </div> </div> ';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide("frappe.ui.toolbar");
	frappe.provide('frappe.search');

	frappe.ui.toolbar.Toolbar = Class.extend({
		init: function() {
			$('header').append(frappe.render_template("navbar", {
				avatar: frappe.avatar(frappe.session.user)
			}));
			$('.dropdown-toggle').dropdown();

			var awesome_bar = new frappe.search.AwesomeBar();
			awesome_bar.setup("#navbar-search");
			awesome_bar.setup("#modal-search");

			this.make();
		},

		make: function() {
			this.setup_sidebar();
			this.setup_help();

			this.bind_events();

			$(document).trigger('toolbar_setup');
		},

		bind_events: function() {
			$(document).on("notification-update", function() {
				frappe.ui.notifications.update_notifications();
			});

			// clear all custom menus on page change
			$(document).on("page-change", function() {
				$("header .navbar .custom-menu").remove();
			});

			//focus search-modal on show in mobile view
			$('#search-modal').on('shown.bs.modal', function() {
				var search_modal = $(this);
				setTimeout(function() {
					search_modal.find('#modal-search').focus();
				}, 300);
			});
			$('.navbar-toggle-full-width').click(function () {
				frappe.ui.toolbar.toggle_full_width();
			});
		},

		setup_sidebar: function() {
			var header = $('header');
			header.find(".toggle-sidebar").on("click", function() {
				var layout_side_section = $('.layout-side-section');
				var overlay_sidebar = layout_side_section.find('.overlay-sidebar');

				overlay_sidebar.addClass('opened');
				overlay_sidebar.find('.reports-dropdown')
					.removeClass('dropdown-menu')
					.addClass('list-unstyled');
				overlay_sidebar.find('.dropdown-toggle')
					.addClass('text-muted').find('.caret')
					.addClass('hidden-xs hidden-sm');

				$('<div class="close-sidebar">').hide().appendTo(layout_side_section).fadeIn();

				var scroll_container = $('html');
				scroll_container.css("overflow-y", "hidden");

				layout_side_section.find(".close-sidebar").on('click', close_sidebar);
				layout_side_section.on("click", "a", close_sidebar);

				function close_sidebar(e) {
					scroll_container.css("overflow-y", "");

					layout_side_section.find("div.close-sidebar").fadeOut(function() {
						overlay_sidebar.removeClass('opened')
							.find('.dropdown-toggle')
							.removeClass('text-muted');
						overlay_sidebar.find('.reports-dropdown')
							.addClass('dropdown-menu');
					});
				}
			});
		},

		setup_help: function() {
			frappe.provide('frappe.help');
			frappe.help.show_results = show_results;

			this.search = new frappe.search.SearchDialog();
			frappe.provide('frappe.searchdialog');
			frappe.searchdialog.search = this.search;

			$(".dropdown-help .dropdown-toggle").on("click", function() {
				$(".dropdown-help input").focus();
			});

			$(".dropdown-help .dropdown-menu").on("click", "input, button", function(e) {
				e.stopPropagation();
			});

			$("#input-help").on("keydown", function(e) {
				if(e.which == 13) {
					$(this).val("");
				}
			});

			$(document).on("page-change", function () {
				var $help_links = $(".dropdown-help #help-links");
				$help_links.html("");

				var route = frappe.get_route_str();
				var breadcrumbs = route.split("/");

				var links = [];
				for (var i = 0; i < breadcrumbs.length; i++) {
					var r = route.split("/", i + 1);
					var key = r.join("/");
					var help_links = frappe.help.help_links[key] || [];
					links = $.merge(links, help_links);
				}

				if(links.length === 0) {
					$help_links.next().hide();
				} else {
					$help_links.next().show();
				}

				for (var i = 0; i < links.length; i++) {
					var link = links[i];
					var url = link.url;
					$("<a>", {
						href: link.url,
						text: link.label,
						target: "_blank"
					}).appendTo($help_links);
				}

				$('.dropdown-help .dropdown-menu').on('click', 'a', show_results);
			});

			var $result_modal = frappe.get_modal("", "");
			$result_modal.addClass("help-modal");

			$(document).on("click", ".help-modal a", show_results);

			function show_results(e) {
				//edit links
				var href = e.target.href;
				if(href.indexOf('blob') > 0) {
					window.open(href, '_blank');
				}
				var path = $(e.target).attr("data-path");
				if(path) {
					e.preventDefault();
				}
			}
		}
	});

	$.extend(frappe.ui.toolbar, {
		add_dropdown_button: function(parent, label, click, icon) {
			var menu = frappe.ui.toolbar.get_menu(parent);
			if(menu.find("li:not(.custom-menu)").length && !menu.find(".divider").length) {
				frappe.ui.toolbar.add_menu_divider(menu);
			}

			return $('<li class="custom-menu"><a><i class="fa-fw '
				+icon+'"></i> '+label+'</a></li>')
				.insertBefore(menu.find(".divider"))
				.find("a")
				.click(function() {
					click.apply(this);
				});
		},
		get_menu: function(label) {
			return $("#navbar-" + label.toLowerCase());
		},
		add_menu_divider: function(menu) {
			menu = typeof menu == "string" ?
				frappe.ui.toolbar.get_menu(menu) : menu;

			$('<li class="divider custom-menu"></li>').prependTo(menu);
		},
		add_icon_link: function add_icon_link(route, icon, index, class_name) {
			var parent_element = $(".navbar-right").get(0);
			var new_element = $(("<li class=\"" + class_name + "\">\n\t\t\t<a class=\"btn\" href=\"" + route + "\" title=\"" + (frappe.utils.to_title_case(class_name, true)) + "\" aria-haspopup=\"true\" aria-expanded=\"true\">\n\t\t\t\t<div>\n\t\t\t\t\t<i class=\"octicon " + icon + "\"></i>\n\t\t\t\t</div>\n\t\t\t</a>\n\t\t</li>")).get(0);

			parent_element.insertBefore(new_element, parent_element.children[index]);
		},
		toggle_full_width: function toggle_full_width() {
			var fullwidth = JSON.parse(localStorage.container_fullwidth || 'false');
			fullwidth = !fullwidth;
			localStorage.container_fullwidth = fullwidth;
			frappe.ui.toolbar.set_fullwidth_if_enabled();
		},
		set_fullwidth_if_enabled: function set_fullwidth_if_enabled() {
			var fullwidth = JSON.parse(localStorage.container_fullwidth || 'false');
			$(document.body).toggleClass('full-width', fullwidth);
		},
	});

	frappe.ui.toolbar.clear_cache = function() {
		frappe.assets.clear_local_storage();
		frappe.call({
			method: 'frappe.sessions.clear',
			callback: function(r) {
				if(!r.exc) {
					frappe.show_alert({message:r.message, indicator:'green'});
					location.reload(true);
				}
			}
		});
		return false;
	};

	frappe.ui.toolbar.show_about = function() {
		try {
			frappe.ui.misc.about();
		} catch(e) {
			console.log(e);
		}
		return false;
	};

	frappe.provide("frappe.ui.notifications");

	frappe.ui.notifications = {
		config: {
			"ToDo": { label: __("To Do") },
			"Event": { label: __("Calendar"), route: "List/Event/Calendar" },
			"Email": { label: __("Email"), route: "List/Communication/Inbox" }
		},

		update_notifications: function() {
			this.total = 0;
			this.dropdown = $("#dropdown-notification").empty();
			this.boot_info = frappe.boot.notification_info;
			var defaults = ["Comment", "ToDo", "Event"];

			this.get_counts(this.boot_info.open_count_doctype, 1, defaults);
			this.get_counts(this.boot_info.open_count_other, 1);

			// Target counts are stored for docs per doctype
			var targets = { doctypes : {} }, map = this.boot_info.targets;
			Object.keys(map).map(function (doctype) {
				Object.keys(map[doctype]).map(function (doc) {
					targets[doc] = map[doctype][doc];
					targets.doctypes[doc] = doctype;
				});
			});
			this.get_counts(targets, 1, null, ["doctypes"], true);
			this.get_counts(this.boot_info.open_count_doctype,
				0, null, defaults);

			this.bind_list();

			// switch colour on the navbar and disable if no notifications
			$(".navbar-new-comments")
				.html(this.total > 99 ? '99+' : this.total)
				.toggleClass("navbar-new-comments-true", this.total ? true : false)
				.parent().toggleClass("disabled", this.total ? false : true);
		},

		get_counts: function(map, divide, keys, excluded, target) {
			var this$1 = this;
			if ( excluded === void 0 ) excluded = [];
			if ( target === void 0 ) target = false;

			var empty_map = 1;
			keys = keys ? keys
				: Object.keys(map).sort().filter(function (e) { return !excluded.includes(e); });
			keys.map(function (key) {
				var doc_dt = (map.doctypes) ? map.doctypes[key] : undefined;
				if(map[key] > 0 || target) {
					this$1.add_notification(key, map[key], doc_dt, target);
					empty_map = 0;
				}
			});
			if(divide && !empty_map) {
				this.dropdown.append($('<li class="divider"></li>'));
			}
		},

		add_notification: function(name, value, doc_dt, target) {
			if ( target === void 0 ) target = false;

			var label = this.config[name] ? this.config[name].label : name;
			var title = target ? "title=\"Your Target\"" : '';
			var $list_item = !target
				? $(("<li><a class=\"badge-hover\" data-doctype=\"" + name + "\" " + title + ">" + (__(label)) + "\n\t\t\t\t<span class=\"badge pull-right\">" + value + "</span>\n\t\t\t</a></li>"))
				: $(("<li><a class=\"progress-small\" " + title + " data-doctype=\"" + doc_dt + "\"\n\t\t\t\tdata-doc=\"" + name + "\"><span class=\"dropdown-item-label\">" + (__(label)) + "<span>\n\t\t\t\t<div class=\"progress-chart\"><div class=\"progress\">\n\t\t\t\t\t<div class=\"progress-bar\" style=\"width: " + value + "%\"></div>\n\t\t\t\t</div></div>\n\t\t\t</a></li>"));
			this.dropdown.append($list_item);
			if(!target) { this.total += value; }
		},

		bind_list: function() {
			var me = this;
			$("#dropdown-notification a").on("click", function() {
				var doctype = $(this).attr("data-doctype");
				var doc = $(this).attr("data-doc");
				if(!doc) {
					var config = me.config[doctype] || {};
					if (config.route) {
						frappe.set_route(config.route);
					} else if (config.click) {
						config.click();
					} else {
						frappe.ui.notifications.show_open_count_list(doctype);
					}
				} else {
					frappe.set_route("Form", doctype, doc);
				}
			});
		},

		show_open_count_list: function(doctype) {
			var filters = this.boot_info.conditions[doctype];
			if(filters && $.isPlainObject(filters)) {
				if (!frappe.route_options) {
					frappe.route_options = {};
				}
				$.extend(frappe.route_options, filters);
			}
			frappe.set_route("List", doctype);
		},
	};

	// Copyright (c) 2018, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.last_edited_communication = {};
	frappe.standard_replies = {};

	frappe.views.CommunicationComposer = Class.extend({
		init: function(opts) {
			$.extend(this, opts);
			this.make();
		},
		make: function() {
			var this$1 = this;

			var me = this;

			this.dialog = new frappe.ui.Dialog({
				title: (this.title || this.subject || __("New Email")),
				no_submit_on_enter: true,
				fields: this.get_fields(),
				primary_action_label: __("Send"),
				primary_action: function() {
					me.delete_saved_draft();
					me.send_action();
				}
			});

			['recipients', 'cc', 'bcc'].forEach(function (field) {
				this$1.dialog.fields_dict[field].get_data = function() {
					var data = me.dialog.fields_dict[field].get_value();
					var txt = data.match(/[^,\s*]*$/)[0] || '';
					var options = [];

					frappe.call({
						method: "frappe.email.get_contact_list",
						args: {
							txt: txt,
						},
						callback: function (r) {
							options = r.message;
							me.dialog.fields_dict[field].set_data(options);
						}
					});
					return options;
				};
			});

			$(document).on("upload_complete", function(event, attachment) {
				if(me.dialog.display) {
					var wrapper = $(me.dialog.fields_dict.select_attachments.wrapper);

					// find already checked items
					var checked_items = wrapper.find('[data-file-name]:checked').map(function() {
						return $(this).attr("data-file-name");
					});

					// reset attachment list
					me.render_attach();

					// check latest added
					checked_items.push(attachment.name);

					$.each(checked_items, function(i, filename) {
						wrapper.find('[data-file-name="'+ filename +'"]').prop("checked", true);
					});
				}
			});
			this.prepare();
			this.dialog.show();
		},

		get_fields: function() {
			var contactList = [];
			var fields= [
				{label:__("To"), fieldtype:"MultiSelect", reqd: 0, fieldname:"recipients",options:contactList},
				{fieldtype: "Section Break", collapsible: 1, label: __("CC, BCC & Email Template")},
				{label:__("CC"), fieldtype:"MultiSelect", fieldname:"cc",options:contactList},
				{label:__("BCC"), fieldtype:"MultiSelect", fieldname:"bcc",options:contactList},
				{label:__("Email Template"), fieldtype:"Link", options:"Email Template",
					fieldname:"email_template"},
				{fieldtype: "Section Break"},
				{label:__("Subject"), fieldtype:"Data", reqd: 1,
					fieldname:"subject", length:524288},
				{fieldtype: "Section Break"},
				{
					label:__("Message"),
					fieldtype:"Text Editor", reqd: 1,
					fieldname:"content",
					onchange: frappe.utils.debounce(this.save_as_draft.bind(this), 300)
				},

				{fieldtype: "Section Break"},
				{fieldtype: "Column Break"},
				{label:__("Send me a copy"), fieldtype:"Check",
					fieldname:"send_me_a_copy", 'default': frappe.boot.user.send_me_a_copy},
				{label:__("Send Read Receipt"), fieldtype:"Check",
					fieldname:"send_read_receipt"},
				{label:__("Attach Document Print"), fieldtype:"Check",
					fieldname:"attach_document_print"},
				{label:__("Select Print Format"), fieldtype:"Select",
					fieldname:"select_print_format"},
				{label:__("Select Languages"), fieldtype:"Select",
					fieldname:"language_sel"},
				{fieldtype: "Column Break"},
				{label:__("Select Attachments"), fieldtype:"HTML",
					fieldname:"select_attachments"}
			];

			// add from if user has access to multiple email accounts
			var email_accounts = frappe.boot.email_accounts.filter(function(account, idx){
				return !in_list(["All Accounts", "Sent", "Spam", "Trash"], account.email_account) &&
					account.enable_outgoing
			});
			if(frappe.boot.email_accounts && email_accounts.length > 1) {
				fields = [
					{label: __("From"), fieldtype: "Select", reqd: 1, fieldname: "sender",
						options: email_accounts.map(function(e) { return e.email_id; }) }
				].concat(fields);
			}

			return fields;
		},
		prepare: function() {
			this.setup_subject_and_recipients();
			this.setup_print_language();
			this.setup_print();
			this.setup_attach();
			this.setup_email();
			this.setup_last_edited_communication();
			this.setup_email_template();

			this.dialog.fields_dict.recipients.set_value(this.recipients || '');
			this.dialog.fields_dict.cc.set_value(this.cc || '');
			this.dialog.fields_dict.bcc.set_value(this.bcc || '');

			if(this.dialog.fields_dict.sender) {
				this.dialog.fields_dict.sender.set_value(this.sender || '');
			}
			this.dialog.fields_dict.subject.set_value(this.subject || '');

			this.setup_earlier_reply();
		},

		setup_subject_and_recipients: function() {
			this.subject = this.subject || "";

			if(!this.forward && !this.recipients && this.last_email) {
				this.recipients = this.last_email.sender;
				this.cc = this.last_email.cc;
				this.bcc = this.last_email.bcc;
			}

			if(!this.forward && !this.recipients) {
				this.recipients = this.frm && this.frm.timeline.get_recipient();
			}

			if(!this.subject && this.frm) {
				// get subject from last communication
				var last = this.frm.timeline.get_last_email();

				if(last) {
					this.subject = last.subject;
					if(!this.recipients) {
						this.recipients = last.sender;
					}

					// prepend "Re:"
					if(strip(this.subject.toLowerCase().split(":")[0])!="re") {
						this.subject = __("Re: {0}", [this.subject]);
					}
				}

				if (!this.subject) {
					if (this.frm.subject_field && this.frm.doc[this.frm.subject_field]) {
						this.subject = __("Re: {0}", [this.frm.doc[this.frm.subject_field]]);
					} else {
						var title = this.frm.doc.name;
						if(this.frm.meta.title_field && this.frm.doc[this.frm.meta.title_field]
							&& this.frm.doc[this.frm.meta.title_field] != this.frm.doc.name) {
							title = (this.frm.doc[this.frm.meta.title_field]) + " (#" + (this.frm.doc.name) + ")";
						}
						this.subject = (__(this.frm.doctype)) + ": " + title;
					}
				}
			}
		},

		setup_email_template: function() {
			var me = this;

			this.dialog.fields_dict["email_template"].df.onchange = function () {
				var email_template = me.dialog.fields_dict.email_template.get_value();

				var prepend_reply = function(reply) {
					if(me.reply_added===email_template) {
						return;
					}
					var content_field = me.dialog.fields_dict.content;
					var subject_field = me.dialog.fields_dict.subject;
					var content = content_field.get_value() || "";
					var subject = subject_field.get_value() || "";

					var parts = content.split('<!-- salutation-ends -->');

					if(parts.length===2) {
						content = [reply.message, "<br>", parts[1]];
					} else {
						content = [reply.message, "<br>", content];
					}

					content_field.set_value(content.join(''));
					if(subject === "") {
						subject_field.set_value(reply.subject);
					}

					me.reply_added = email_template;
				};

				frappe.call({
					method: 'frappe.email.doctype.email_template.email_template.get_email_template',
					args: {
						template_name: email_template,
						doc: me.frm.doc,
						_lang: me.dialog.get_value("language_sel")
					},
					callback: function(r) {
						prepend_reply(r.message);
					},
				});
			};
		},

		setup_last_edited_communication: function() {
			var me = this;
			if (!this.doc){
				if (cur_frm){
					this.doc = cur_frm.doctype;
				}else{
					this.doc = "Inbox";
				}
			}
			if (cur_frm && cur_frm.docname) {
				this.key = cur_frm.docname;
			} else {
				this.key = "Inbox";
			}
			if(this.last_email) {
				this.key = this.key + ":" + this.last_email.name;
			}
			if(this.subject){
				this.key = this.key + ":" + this.subject;
			}
			this.dialog.onhide = function() {
				var last_edited_communication = me.get_last_edited_communication();
				$.extend(last_edited_communication, {
					sender: me.dialog.get_value("sender"),
					recipients: me.dialog.get_value("recipients"),
					subject: me.dialog.get_value("subject"),
					content: me.dialog.get_value("content"),
				});
			};

			this.dialog.on_page_show = function() {
				if (!me.txt) {
					var last_edited_communication = me.get_last_edited_communication();
					if(last_edited_communication.content) {
						me.dialog.set_value("sender", last_edited_communication.sender || "");
						me.dialog.set_value("subject", last_edited_communication.subject || "");
						me.dialog.set_value("recipients", last_edited_communication.recipients || "");
						me.dialog.set_value("content", last_edited_communication.content || "");
					}
				}

			};

		},

		get_last_edited_communication: function() {
			if (!frappe.last_edited_communication[this.doc]) {
				frappe.last_edited_communication[this.doc] = {};
			}

			if(!frappe.last_edited_communication[this.doc][this.key]) {
				frappe.last_edited_communication[this.doc][this.key] = {};
			}

			return frappe.last_edited_communication[this.doc][this.key];
		},

		selected_format: function() {
			return this.dialog.fields_dict.select_print_format.input.value || (this.frm && this.frm.meta.default_print_format) || "Standard";
		},

		get_print_format: function(format) {
			if (!format) {
				format = this.selected_format();
			}

			if (locals["Print Format"] && locals["Print Format"][format]) {
				return locals["Print Format"][format];
			} else {
				return {};
			}
		},

		setup_print_language: function() {
			var me = this;
			var doc = this.doc || cur_frm.doc;
			var fields = this.dialog.fields_dict;

			//Load default print language from doctype
			this.lang_code = doc.language;

			if (this.get_print_format().default_print_language) {
				var default_print_language_code = this.get_print_format().default_print_language;
				me.lang_code = default_print_language_code;
			} else {
				var default_print_language_code = null;
			}

			//On selection of language retrieve language code
			$(fields.language_sel.input).change(function(){
				me.lang_code = this.value;
			});

			// Load all languages in the select field language_sel
			$(fields.language_sel.input)
				.empty()
				.add_options(frappe.get_languages());

			if (default_print_language_code) {
				$(fields.language_sel.input).val(default_print_language_code);
			} else {
				$(fields.language_sel.input).val(doc.language);
			}
		},

		setup_print: function() {
			// print formats
			var fields = this.dialog.fields_dict;

			// toggle print format
			$(fields.attach_document_print.input).click(function() {
				$(fields.select_print_format.wrapper).toggle($(this).prop("checked"));
			});

			// select print format
			$(fields.select_print_format.wrapper).toggle(false);

			if (cur_frm) {
				$(fields.select_print_format.input)
					.empty()
					.add_options(cur_frm.print_preview.print_formats)
					.val(cur_frm.print_preview.print_formats[0]);
			} else {
				$(fields.attach_document_print.wrapper).toggle(false);
			}

		},
		setup_attach: function() {
			var this$1 = this;

			var fields = this.dialog.fields_dict;
			var attach = $(fields.select_attachments.wrapper);

			if (!this.attachments) {
				this.attachments = [];
			}

			var args = {
				folder: 'Home/Attachments',
				on_success: function (attachment) { return this$1.attachments.push(attachment); }
			};

			if(this.frm) {
				args = {
					doctype: this.frm.doctype,
					docname: this.frm.docname,
					folder: 'Home/Attachments',
					on_success: function (attachment) {
						this$1.frm.attachments.attachment_uploaded(attachment);
						this$1.render_attach();
					}
				};
			}

			$("<h6 class='text-muted add-attachment' style='margin-top: 12px; cursor:pointer;'>"
				+__("Select Attachments")+"</h6><div class='attach-list'></div>\
			<p class='add-more-attachments'>\
			<a class='text-muted small'><i class='octicon octicon-plus' style='font-size: 12px'></i> "
				+__("Add Attachment")+"</a></p>").appendTo(attach.empty());
			attach
				.find(".add-more-attachments a")
				.on('click',function () { return new frappe.ui.FileUploader(args); });
			this.render_attach();
		},
		render_attach:function(){
			var fields = this.dialog.fields_dict;
			var attach = $(fields.select_attachments.wrapper).find(".attach-list").empty();

			var files = [];
			if (this.attachments && this.attachments.length) {
				files = files.concat(this.attachments);
			}
			if (cur_frm) {
				files = files.concat(cur_frm.get_files());
			}

			if(files.length) {
				$.each(files, function(i, f) {
					if (!f.file_name) { return; }
					f.file_url = frappe.urllib.get_full_url(f.file_url);

					$(repl('<p class="checkbox">'
						+	'<label><span><input type="checkbox" data-file-name="%(name)s"></input></span>'
						+		'<span class="small">%(file_name)s</span>'
						+	' <a href="%(file_url)s" target="_blank" class="text-muted small">'
						+		'<i class="fa fa-share" style="vertical-align: middle; margin-left: 3px;"></i>'
						+ '</label></p>', f))
						.appendTo(attach);
				});
			}
		},
		setup_email: function() {
			var fields = this.dialog.fields_dict;

			if(this.attach_document_print) {
				$(fields.attach_document_print.input).click();
				$(fields.select_print_format.wrapper).toggle(true);
			}

			$(fields.send_me_a_copy.input).on('click', function () {
				// update send me a copy (make it sticky)
				var val = fields.send_me_a_copy.get_value();
				frappe.db.set_value('User', frappe.session.user, 'send_me_a_copy', val);
				frappe.boot.user.send_me_a_copy = val;
			});

		},

		send_action: function() {
			var me = this;
			var btn = me.dialog.get_primary_btn();

			var form_values = this.get_values();
			if(!form_values) { return; }

			var selected_attachments =
				$.map($(me.dialog.wrapper).find("[data-file-name]:checked"), function (element) {
					return $(element).attr("data-file-name");
				});


			if(form_values.attach_document_print) {
				me.send_email(btn, form_values, selected_attachments, null, form_values.select_print_format || "");
			} else {
				me.send_email(btn, form_values, selected_attachments);
			}
		},

		get_values: function() {
			var form_values = this.dialog.get_values();

			// cc
			for ( var i=0, l=this.dialog.fields.length; i < l; i++ ) {
				var df = this.dialog.fields[i];

				if ( df.is_cc_checkbox ) {
					// concat in cc
					if ( form_values[df.fieldname] ) {
						form_values.cc = ( form_values.cc ? (form_values.cc + ", ") : "" ) + df.fieldname;
						form_values.bcc = ( form_values.bcc ? (form_values.bcc + ", ") : "" ) + df.fieldname;
					}

					delete form_values[df.fieldname];
				}
			}

			return form_values;
		},

		save_as_draft: function() {
			if (this.dialog) {
				try {
					var message = this.dialog.get_value('content');
					message = message.split(frappe.separator_element)[0];
					localStorage.setItem(this.frm.doctype + this.frm.docname, message);
				} catch (e) {
					// silently fail
					console.log(e);
					console.warn('[Communication] localStorage is full. Cannot save message as draft');
				}
			}
		},

		delete_saved_draft: function delete_saved_draft() {
			if (this.dialog) {
				try {
					localStorage.removeItem(this.frm.doctype + this.frm.docname);
				} catch (e) {
					console.log(e);
					console.warn('[Communication] Cannot delete localStorage item'); // eslint-disable-line
				}
			}
		},

		send_email: function(btn, form_values, selected_attachments, print_html, print_format) {
			var me = this;
			me.dialog.hide();

			if(!form_values.recipients) {
				frappe.msgprint(__("Enter Email Recipient(s)"));
				return;
			}

			if(!form_values.attach_document_print) {
				print_html = null;
				print_format = null;
			}


			if(cur_frm && !frappe.model.can_email(me.doc.doctype, cur_frm)) {
				frappe.msgprint(__("You are not allowed to send emails related to this document"));
				return;
			}


			return frappe.call({
				method:"frappe.core.doctype.communication.email.make",
				args: {
					recipients: form_values.recipients,
					cc: form_values.cc,
					bcc: form_values.bcc,
					subject: form_values.subject,
					content: form_values.content,
					doctype: me.doc.doctype,
					name: me.doc.name,
					send_email: 1,
					print_html: print_html,
					send_me_a_copy: form_values.send_me_a_copy,
					print_format: print_format,
					sender: form_values.sender,
					sender_full_name: form_values.sender?frappe.user.full_name():undefined,
					email_template: form_values.email_template,
					attachments: selected_attachments,
					_lang : me.lang_code,
					read_receipt:form_values.send_read_receipt,
					print_letterhead: me.is_print_letterhead_checked(),
				},
				btn: btn,
				callback: function(r) {
					if(!r.exc) {
						frappe.utils.play_sound("email");

						if(r.message["emails_not_sent_to"]) {
							frappe.msgprint(__("Email not sent to {0} (unsubscribed / disabled)",
								[ frappe.utils.escape_html(r.message["emails_not_sent_to"]) ]) );
						}

						if ((frappe.last_edited_communication[me.doc] || {})[me.key]) {
							delete frappe.last_edited_communication[me.doc][me.key];
						}
						if (cur_frm) {
							// clear input
							cur_frm.timeline.input && cur_frm.timeline.input.val("");
							cur_frm.reload_doc();
						}

						// try the success callback if it exists
						if (me.success) {
							try {
								me.success(r);
							} catch (e) {
								console.log(e);
							}
						}

					} else {
						frappe.msgprint(__("There were errors while sending email. Please try again."));

						// try the error callback if it exists
						if (me.error) {
							try {
								me.error(r);
							} catch (e) {
								console.log(e);
							}
						}
					}
				}
			});
		},

		is_print_letterhead_checked: function() {
			if (this.frm && $(this.frm.wrapper).find('.form-print-wrapper').is(':visible')){
				return $(this.frm.wrapper).find('.print-letterhead').prop('checked') ? 1 : 0;
			} else {
				return (frappe.model.get_doc(":Print Settings", "Print Settings") ||
					{ with_letterhead: 1 }).with_letterhead ? 1 : 0;
			}
		},

		setup_earlier_reply: function() {
			var fields = this.dialog.fields_dict;
			var signature = frappe.boot.user.email_signature || "";

			if(!frappe.utils.is_html(signature)) {
				signature = signature.replace(/\n/g, "<br>");
			}

			if(this.txt) {
				this.message = this.txt + (this.message ? ("<br><br>" + this.message) : "");
			} else {
				// saved draft in localStorage
				var ref = this.frm || {};
				var doctype = ref.doctype;
				var docname = ref.docname;
				if (doctype && docname) {
					this.message = localStorage.getItem(doctype + docname) || '';
				}
			}

			if(this.real_name) {
				this.message = '<p>'+__('Dear') +' '
					+ this.real_name + ",</p><!-- salutation-ends --><br>" + (this.message || "");
			}

			if(this.message && signature && this.message.includes(signature)) {
				signature = "";
			}

			var reply = (this.message || "") + (signature ? ("<br>" + signature) : "");
			var content = '';

			if (this.is_a_reply === 'undefined') {
				this.is_a_reply = true;
			}

			if (this.is_a_reply) {
				var last_email = this.last_email;

				if (!last_email) {
					last_email = this.frm && this.frm.timeline.get_last_email(true);
				}

				if (!last_email) { return; }

				var last_email_content = last_email.original_comment || last_email.content;

				// convert the email context to text as we are enclosing
				// this inside <blockquote>
				last_email_content = this.html2text(last_email_content).replace(/\n/g, '<br>');

				// clip last email for a maximum of 20k characters
				// to prevent the email content from getting too large
				if (last_email_content.length > 20 * 1024) {
					last_email_content += '<div>' + __('Message clipped') + '</div>' + last_email_content;
					last_email_content = last_email_content.slice(0, 20 * 1024);
				}

				var communication_date = last_email.communication_date || last_email.creation;
				content = "\n\t\t\t\t<div><br></div>\n\t\t\t\t" + reply + "\n\t\t\t\t" + (frappe.separator_element) + "\n\t\t\t\t<p>" + (__("On {0}, {1} wrote:", [frappe.datetime.global_date_format(communication_date) , last_email.sender])) + "</p>\n\t\t\t\t<blockquote>\n\t\t\t\t" + last_email_content + "\n\t\t\t\t</blockquote>\n\t\t\t";
			} else {
				content = "<div><br></div>" + reply;
			}
			fields.content.set_value(content);
		},
		html2text: function(html) {
			// convert HTML to text and try and preserve whitespace
			var d = document.createElement( 'div' );
			d.innerHTML = html.replace(/<\/div>/g, '<br></div>')  // replace end of blocks
				.replace(/<\/p>/g, '<br></p>') // replace end of paragraphs
				.replace(/<br>/g, '\n');
			var text = d.textContent;

			// replace multiple empty lines with just one
			return text.replace(/\n{3,}/g, '\n\n');
		}
	});

	frappe.views.TranslationManager = class TranslationManager {
		constructor(opts) {
			Object.assign(this, opts);
			this.make();
		}

		make() {
			var this$1 = this;

			this.data = [];
			this.dialog = new frappe.ui.Dialog({
				fields: this.get_fields(),
				title: __('Translate {0}', [this.df.label]),
				no_submit_on_enter: true,
				primary_action_label: __('Update Translations'),
				primary_action:
					function (values) { return this$1.update_translations(values)
						.then(function () {
							this$1.dialog.hide();

							this$1.data = [];

							frappe.msgprint({
								title: __('Success'),
								message: __('Successfully updated translations'),
								indicator: 'green'
							});
						}); }
			});

			this.get_translations_data()
				.then(function (data) {
					var ref;

					(ref = this$1.data).push.apply(ref, (data || []));
					this$1.dialog.refresh();
					this$1.dialog.show();
				});
		}

		get_fields() {
			var this$1 = this;

			var fields = [
				{
					label: __('Source Text'),
					fieldname: 'source',
					fieldtype: 'Data',
					read_only: 1,
					bold: 1,
					default: this.source_name
				},
				{
					label: __('Translations'),
					fieldname: 'translation_data',
					fieldtype: 'Table',
					fields: [
						{
							label: 'Language',
							fieldname: 'language',
							fieldtype: 'Link',
							options: 'Language',
							in_list_view: 1,
							columns: 3
						},
						{
							label: 'Translation',
							fieldname: 'translation',
							fieldtype: 'Text',
							in_list_view: 1,
							columns: 7
						}
					],
					data: this.data,
					get_data: function () {
						return this$1.data;
					}
				}
			];
			return fields;
		}

		get_translations_data() {
			return frappe.db.get_list('Translation', {
				fields: ['name', 'language', 'target_name as translation'],
				filters: {
					source_name: strip_html(this.source_name)
				}
			});
		}

		update_translations(ref) {
			var source = ref.source;
			var translation_data = ref.translation_data; if ( translation_data === void 0 ) translation_data = [];

			var translation_dict = {};
			translation_data.map(function (row) {
				translation_dict[row.language] = row.translation;
			});

			return frappe.call({
				method: 'frappe.translate.update_translations_for_source',
				btn: this.dialog.get_primary_btn(),
				args: {
					source: source,
					translation_dict: translation_dict
				}
			}).fail(function () {
				frappe.msgprint({
					title: __('Something went wrong'),
					message: __('Please try again'),
					indicator: 'red'
				});
			});
		}
	};

	frappe.templates['sort_selector'] = '<div class="sort-selector">  <div class="dropdown">   <a class="text-muted dropdown-toggle small"    data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">    <span class="dropdown-text">{{ __(sort_by_label) }}</span>   </a>   <ul class="dropdown-menu">    {% for value in options %}    <li>     <a class="option" data-value="{{ value.fieldname }}">      {{ __(value.label) }}     </a>    </li>    {% endfor %}   </ul>  </div>  <button class="btn btn-default btn-xs btn-order"   data-value="{{ sort_order }}">   <span class="octicon text-muted    octicon-arrow-{{ sort_order==="desc" ? "down " : "up " }}">   </span>  </button> </div>';

	frappe.ui.SortSelector = Class.extend({
		// parent:
		// change:
		// args:
		//		options: {fieldname:, label:}
		//		sort_by:
		//		sort_by_label:
		//		sort_order:
		//		doctype: (optional)
		init: function(opts) {
			$.extend(this, opts);
			this.labels = {};
			this.make();
		},
		make: function() {
			this.prepare_args();
			this.parent.find('.sort-selector').remove();
			this.wrapper = $(frappe.render_template('sort_selector', this.args)).appendTo(this.parent);
			this.bind_events();
		},
		bind_events: function() {
			var me = this;

			// order
			this.wrapper.find('.btn-order').on('click', function() {
				var btn = $(this);
				var order = $(this).attr('data-value')==='desc' ? 'asc' : 'desc';

				btn.attr('data-value', order);
				me.sort_order = order;
				btn.find('.octicon')
					.removeClass('octicon-arrow-' + (order==='asc' ? 'down' : 'up'))
					.addClass('octicon-arrow-' + (order==='desc' ? 'down' : 'up'));
				(me.onchange || me.change)(me.sort_by, me.sort_order);
			});

			// select field
			this.wrapper.find('.dropdown a.option').on('click', function() {
				me.sort_by = $(this).attr('data-value');
				me.wrapper.find('.dropdown .dropdown-text').html($(this).html());
				(me.onchange || me.change)(me.sort_by, me.sort_order);
			});

		},
		prepare_args: function() {
			var me = this;
			if(!this.args) {
				this.args = {};
			}

			// args as string
			if(this.args && typeof this.args === 'string') {
				var order_by = this.args;
				this.args = {};

				if (order_by.includes('`.`')) {
					// scrub table name (separated by dot), like `tabTime Log`.`modified` desc`
					order_by = order_by.split('.')[1];
				}

				var parts = order_by.split(' ');
				if (parts.length === 2) {
					var fieldname = strip(parts[0], '`');

					this.args.sort_by = fieldname;
					this.args.sort_order = parts[1];
				}
			}

			if(this.args.options) {
				this.args.options.forEach(function(o) {
					me.labels[o.fieldname] = o.label;
				});
			}

			this.setup_from_doctype();

			// if label is missing, add from options
			if(this.args.sort_by && !this.args.sort_by_label) {
				this.args.options.every(function(o) {
					if(o.fieldname===me.args.sort_by) {
						me.args.sort_by_label = o.label;
						return false;
					}
					return true;
				});
			}

		},
		setup_from_doctype: function() {
			var me = this;
			var meta = frappe.get_meta(this.doctype);
			if (!meta) { return; }

			var ref = this.get_meta_sort_field();
			var meta_sort_field = ref.meta_sort_field;
			var meta_sort_order = ref.meta_sort_order;

			if(!this.args.sort_by) {
				if(meta_sort_field) {
					this.args.sort_by = meta_sort_field;
					this.args.sort_order = meta_sort_order;
				} else {
					// default
					this.args.sort_by = 'modified';
					this.args.sort_order = 'desc';
				}
			}

			if(!this.args.sort_by_label) {
				this.args.sort_by_label = this.get_label(this.args.sort_by);
			}

			if(!this.args.options) {
				// default options
				var _options = [
					{'fieldname': 'modified'}
				];

				// title field
				if(meta.title_field) {
					_options.push({'fieldname': meta.title_field});
				}

				// bold or mandatory
				meta.fields.forEach(function(df) {
					if(df.mandatory || df.bold) {
						_options.push({fieldname: df.fieldname, label: df.label});
					}
				});

				// meta sort field
				if(meta_sort_field) { _options.push({ 'fieldname': meta_sort_field }); }

				// more default options
				_options.push(
					{'fieldname': 'name'},
					{'fieldname': 'creation'},
					{'fieldname': 'idx'}
				);

				// de-duplicate
				this.args.options = _options.uniqBy(function(obj) {
					return obj.fieldname;
				});

				// add missing labels
				this.args.options.forEach(function(o) {
					if(!o.label) {
						o.label = me.get_label(o.fieldname);
					}
				});
			}

			// set default
			this.sort_by = this.args.sort_by;
			this.sort_order = this.args.sort_order;
		},
		get_meta_sort_field: function() {
			var meta = frappe.get_meta(this.doctype);

			if (!meta) {
				return {
					meta_sort_field: null,
					meta_sort_order: null
				}
			}

			if(meta.sort_field && meta.sort_field.includes(',')) {
				var parts = meta.sort_field.split(',')[0].split(' ');
				return {
					meta_sort_field: parts[0],
					meta_sort_order: parts[1]
				}
			} else {
				return {
					meta_sort_field: meta.sort_field || 'modified',
					meta_sort_order: meta.sort_order ? meta.sort_order.toLowerCase() : ''
				}
			}
		},
		get_label: function(fieldname) {
			if(fieldname==='idx') {
				return __("Most Used");
			} else {
				return this.labels[fieldname]
					|| frappe.meta.get_label(this.doctype, fieldname);
			}
		},
		get_sql_string: function() {
			// build string like `tabTask`.`subject` desc
			return '`tab' + this.doctype + '`.`' + this.sort_by + '` ' +  this.sort_order;
		}
	});

	frappe.templates['change_log'] = '{% for (var i=0, l=change_log.length; i < l; i++) {     var app_info = change_log[i]; %}  {% if (i > 0) { %} <hr> {% } %}  <div class="text-left app-change-log">   <h2 style="margin-top: 10px;">             {{ app_info.title }}    <small>{{ __("updated to {0}", [app_info.version]) }}</small>   </h2>   {% for (var x=0, y=app_info.change_log.length; x < y; x++) {             var version_info = app_info.change_log[x];             if(version_info) { %}        <p>{{ frappe.markdown(version_info[1]) }}</p>       {% }         } %}  </div> {% } %} ';

	// Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt
	/* eslint-disable no-console */

	frappe.start_app = function() {
		if(!frappe.Application)
			{ return; }
		frappe.assets.check();
		frappe.provide('frappe.app');
		frappe.app = new frappe.Application();
	};

	$(document).ready(function() {
		if(!frappe.utils.supportsES6) {
			frappe.msgprint({
				indicator: 'red',
				title: __('Browser not supported'),
				message: __('Some of the features might not work in your browser. Please update your browser to the latest version.')
			});
		}
		frappe.start_app();
	});

	frappe.Application = Class.extend({
		init: function() {
			this.startup();
		},

		startup: function() {
			frappe.socketio.init();
			frappe.model.init();

			if(frappe.boot.status==='failed') {
				frappe.msgprint({
					message: frappe.boot.error,
					title: __('Session Start Failed'),
					indicator: 'red',
				});
				throw 'boot failed';
			}

			this.setup_frappe_vue();
			this.load_bootinfo();
			this.load_user_permissions();
			this.make_nav_bar();
			this.set_favicon();
			this.setup_analytics();
			this.set_fullwidth_if_enabled();

			this.setup_energy_point_listeners();

			frappe.ui.keys.setup();
			this.set_rtl();

			if(frappe.boot) {
				if(localStorage.getItem("session_last_route")) {
					window.location.hash = localStorage.getItem("session_last_route");
					localStorage.removeItem("session_last_route");
				}

			}

			// page container
			this.make_page_container();

			// route to home page
			frappe.route();

			// trigger app startup
			$(document).trigger('startup');

			this.start_notification_updates();

			$(document).trigger('app_ready');

			if (frappe.boot.messages) {
				frappe.msgprint(frappe.boot.messages);
			}

			if (frappe.boot.change_log && frappe.boot.change_log.length && !window.Cypress) {
				this.show_change_log();
			} else {
				this.show_notes();
			}

			this.show_update_available();

			if(frappe.ui.startup_setup_dialog && !frappe.boot.setup_complete) {
				frappe.ui.startup_setup_dialog.pre_show();
				frappe.ui.startup_setup_dialog.show();
			}

			// listen to csrf_update
			frappe.realtime.on("csrf_generated", function(data) {
				// handles the case when a user logs in again from another tab
				// and it leads to invalid request in the current tab
				if (data.csrf_token && data.sid===frappe.get_cookie("sid")) {
					frappe.csrf_token = data.csrf_token;
				}
			});

			frappe.realtime.on("version-update", function() {
				var dialog = frappe.msgprint({
					message:__("The application has been updated to a new version, please refresh this page"),
					indicator: 'green',
					title: __('Version Updated')
				});
				dialog.set_primary_action(__("Refresh"), function() {
					location.reload(true);
				});
				dialog.get_close_btn().toggle(false);
			});

			this.setup_social_listeners();

			// listen to build errors
			this.setup_build_error_listener();

			if (frappe.sys_defaults.email_user_password){
				var email_list =  frappe.sys_defaults.email_user_password.split(',');
				for (var u in email_list) {
					if (email_list[u]===frappe.user.name){
						this.set_password(email_list[u]);
					}
				}
			}
			this.link_preview = new frappe.ui.LinkPreview();
		},

		setup_frappe_vue: function setup_frappe_vue() {
			Vue.prototype.__ = window.__;
			Vue.prototype.frappe = window.frappe;
		},

		set_password: function(user) {
			var me=this;
			frappe.call({
				method: 'frappe.core.doctype.user.user.get_email_awaiting',
				args: {
					"user": user
				},
				callback: function(email_account) {
					email_account = email_account["message"];
					if (email_account) {
						var i = 0;
						if (i < email_account.length) {
							me.email_password_prompt( email_account, user, i);
						}
					}
				}
			});
		},

		email_password_prompt: function(email_account,user,i) {
			var me = this;
			var d = new frappe.ui.Dialog({
				title: __('Email Account setup please enter your password for: '+email_account[i]["email_id"]),
				fields: [
					{	'fieldname': 'password',
						'fieldtype': 'Password',
						'label': 'Email Account Password',
						'reqd': 1
					},
					{
						"fieldtype": "Button",
						"label": __("Submit")
					}
				]
			});
			d.get_input("submit").on("click", function() {
				//setup spinner
				d.hide();
				var s = new frappe.ui.Dialog({
					title: __("Checking one moment"),
					fields: [{
						"fieldtype": "HTML",
						"fieldname": "checking"
					}]
				});
				s.fields_dict.checking.$wrapper.html('<i class="fa fa-spinner fa-spin fa-4x"></i>');
				s.show();
				frappe.call({
					method: 'frappe.core.doctype.user.user.set_email_password',
					args: {
						"email_account": email_account[i]["email_account"],
						"user": user,
						"password": d.get_value("password")
					},
					callback: function(passed) {
						s.hide();
						d.hide();//hide waiting indication
						if (!passed["message"]) {
							frappe.show_alert("Login Failed please try again", 5);
							me.email_password_prompt(email_account, user, i);
						} else {
							if (i + 1 < email_account.length) {
								i = i + 1;
								me.email_password_prompt(email_account, user, i);
							}
						}

					}
				});
			});
			d.show();
		},
		load_bootinfo: function() {
			if(frappe.boot) {
				frappe.modules = {};
				frappe.boot.allowed_modules.forEach(function(m) {
					frappe.modules[m.module_name]=m;
				});
				frappe.model.sync(frappe.boot.docs);
				$.extend(frappe._messages, frappe.boot.__messages);
				this.check_metadata_cache_status();
				this.set_globals();
				this.sync_pages();
				moment.locale("en");
				moment.user_utc_offset = moment().utcOffset();
				if(frappe.boot.timezone_info) {
					moment.tz.add(frappe.boot.timezone_info);
				}
				if(frappe.boot.print_css) {
					frappe.dom.set_style(frappe.boot.print_css, "print-style");
				}
				frappe.user.name = frappe.boot.user.name;
			} else {
				this.set_as_guest();
			}
		},

		load_user_permissions: function() {
			frappe.defaults.update_user_permissions();

			frappe.realtime.on('update_user_permissions', frappe.utils.debounce(function () {
				frappe.defaults.update_user_permissions();
			}, 500));
		},

		check_metadata_cache_status: function() {
			if(frappe.boot.metadata_version != localStorage.metadata_version) {
				frappe.assets.clear_local_storage();
				frappe.assets.init_local_storage();
			}
		},

		start_notification_updates: function() {
			var me = this;

			// refresh_notifications will be called only once during a 1 second window
			this.refresh_notifications = frappe.utils.debounce(this.refresh_notifications.bind(this), 1000);

			// kickoff
			this.refresh_notifications();

			frappe.realtime.on('clear_notifications', function () {
				me.refresh_notifications();
			});

			// first time loaded in boot
			$(document).trigger("notification-update");

			// refresh notifications if user is back after sometime
			$(document).on("session_alive", function() {
				me.refresh_notifications();
			});
		},

		refresh_notifications: function() {
			if(frappe.session_alive && frappe.boot && frappe.boot.home_page !== 'setup-wizard') {
				if (this._refresh_notifications) {
					this._refresh_notifications.abort();
				}
				this._refresh_notifications = frappe.call({
					type: 'GET',
					method: "frappe.desk.notifications.get_notifications",
					callback: function(r) {
						if(r.message) {
							$.extend(frappe.boot.notification_info, r.message);
							$(document).trigger("notification-update");

							if(frappe.get_route()[0] != "messages") {
								if(r.message.new_messages.length) {
									frappe.utils.set_title_prefix("(" + r.message.new_messages.length + ")");
								}
							}
						}
					},
					freeze: false
				});
			}
		},

		set_globals: function() {
			frappe.session.user = frappe.boot.user.name;
			frappe.session.user_email = frappe.boot.user.email;
			frappe.session.user_fullname = frappe.user_info().fullname;

			frappe.user_defaults = frappe.boot.user.defaults;
			frappe.user_roles = frappe.boot.user.roles;
			frappe.sys_defaults = frappe.boot.sysdefaults;

			frappe.ui.py_date_format = frappe.boot.sysdefaults.date_format.replace('dd', '%d').replace('mm', '%m').replace('yyyy', '%Y');
			frappe.boot.user.last_selected_values = {};

			// Proxy for user globals
			Object.defineProperties(window, {
				'user': {
					get: function() {
						console.warn('Please use `frappe.session.user` instead of `user`. It will be deprecated soon.');
						return frappe.session.user;
					}
				},
				'user_fullname': {
					get: function() {
						console.warn('Please use `frappe.session.user_fullname` instead of `user_fullname`. It will be deprecated soon.');
						return frappe.session.user;
					}
				},
				'user_email': {
					get: function() {
						console.warn('Please use `frappe.session.user_email` instead of `user_email`. It will be deprecated soon.');
						return frappe.session.user_email;
					}
				},
				'user_defaults': {
					get: function() {
						console.warn('Please use `frappe.user_defaults` instead of `user_defaults`. It will be deprecated soon.');
						return frappe.user_defaults;
					}
				},
				'roles': {
					get: function() {
						console.warn('Please use `frappe.user_roles` instead of `roles`. It will be deprecated soon.');
						return frappe.user_roles;
					}
				},
				'sys_defaults': {
					get: function() {
						console.warn('Please use `frappe.sys_defaults` instead of `sys_defaults`. It will be deprecated soon.');
						return frappe.user_roles;
					}
				}
			});
		},
		sync_pages: function() {
			// clear cached pages if timestamp is not found
			if(localStorage["page_info"]) {
				frappe.boot.allowed_pages = [];
				var page_info = JSON.parse(localStorage["page_info"]);
				$.each(frappe.boot.page_info, function(name, p) {
					if(!page_info[name] || (page_info[name].modified != p.modified)) {
						delete localStorage["_page:" + name];
					}
					frappe.boot.allowed_pages.push(name);
				});
			} else {
				frappe.boot.allowed_pages = Object.keys(frappe.boot.page_info);
			}
			localStorage["page_info"] = JSON.stringify(frappe.boot.page_info);
		},
		set_as_guest: function() {
			frappe.session.user = 'Guest';
			frappe.session.user_email = '';
			frappe.session.user_fullname = 'Guest';

			frappe.user_defaults = {};
			frappe.user_roles = ['Guest'];
			frappe.sys_defaults = {};
		},
		make_page_container: function() {
			if($("#body_div").length) {
				$(".splash").remove();
				frappe.temp_container = $("<div id='temp-container' style='display: none;'>")
					.appendTo("body");
				frappe.container = new frappe.views.Container();
			}
		},
		make_nav_bar: function() {
			// toolbar
			if(frappe.boot && frappe.boot.home_page!=='setup-wizard') {
				frappe.frappe_toolbar = new frappe.ui.toolbar.Toolbar();
			}

		},
		logout: function() {
			var me = this;
			me.logged_out = true;
			return frappe.call({
				method:'logout',
				callback: function(r) {
					if(r.exc) {
						return;
					}
					me.redirect_to_login();
				}
			});
		},
		handle_session_expired: function() {
			if(!frappe.app.session_expired_dialog) {
				var dialog = new frappe.ui.Dialog({
					title: __('Session Expired'),
					keep_open: true,
					fields: [
						{ fieldtype:'Password', fieldname:'password',
							label: __('Please Enter Your Password to Continue') } ],
					onhide: function () {
						if (!dialog.logged_in) {
							frappe.app.redirect_to_login();
						}
					}
				});
				dialog.set_primary_action(__('Login'), function () {
					dialog.set_message(__('Authenticating...'));
					frappe.call({
						method: 'login',
						args: {
							usr: frappe.session.user,
							pwd: dialog.get_values().password
						},
						callback: function (r) {
							if (r.message==='Logged In') {
								dialog.logged_in = true;

								// revert backdrop
								$('.modal-backdrop').css({
									'opacity': '',
									'background-color': '#334143'
								});
							}
							dialog.hide();
						},
						statusCode: function () {
							dialog.hide();
						}
					});
				});
				frappe.app.session_expired_dialog = dialog;
			}
			if(!frappe.app.session_expired_dialog.display) {
				frappe.app.session_expired_dialog.show();
				// add backdrop
				$('.modal-backdrop').css({
					'opacity': 1,
					'background-color': '#4B4C9D'
				});
			}
		},
		redirect_to_login: function() {
			window.location.href = '/';
		},
		set_favicon: function() {
			var link = $('link[type="image/x-icon"]').remove().attr("href");
			$('<link rel="shortcut icon" href="' + link + '" type="image/x-icon">').appendTo("head");
			$('<link rel="icon" href="' + link + '" type="image/x-icon">').appendTo("head");
		},

		trigger_primary_action: function() {
			if(window.cur_dialog && cur_dialog.display) {
				// trigger primary
				cur_dialog.get_primary_btn().trigger("click");
			} else if(cur_frm && cur_frm.page.btn_primary.is(':visible')) {
				cur_frm.page.btn_primary.trigger('click');
			} else if(frappe.container.page.save_action) {
				frappe.container.page.save_action();
			}
		},

		set_rtl: function() {
			if (["ar", "he", "fa"].indexOf(frappe.boot.lang) >= 0) {
				var ls = document.createElement('link');
				ls.rel="stylesheet";
				ls.href= "assets/css/frappe-rtl.css";
				document.getElementsByTagName('head')[0].appendChild(ls);
				$('body').addClass('frappe-rtl');
			}
		},

		show_change_log: function() {
			var me = this;
			var d = frappe.msgprint(
				frappe.render_template("change_log", {"change_log": frappe.boot.change_log}),
				__("Updated To New Version")
			);
			d.keep_open = true;
			d.custom_onhide = function() {
				frappe.call({
					"method": "frappe.utils.change_log.update_last_known_versions"
				});
				me.show_notes();
			};
		},

		show_update_available: function () {
			frappe.call({
				"method": "frappe.utils.change_log.show_update_popup"
			});
		},

		setup_analytics: function() {
			if(window.mixpanel) {
				window.mixpanel.identify(frappe.session.user);
				window.mixpanel.people.set({
					"$first_name": frappe.boot.user.first_name,
					"$last_name": frappe.boot.user.last_name,
					"$created": frappe.boot.user.creation,
					"$email": frappe.session.user
				});
			}
		},

		set_fullwidth_if_enabled: function set_fullwidth_if_enabled() {
			frappe.ui.toolbar.set_fullwidth_if_enabled();
		},

		show_notes: function() {
			var me = this;
			if(frappe.boot.notes.length) {
				frappe.boot.notes.forEach(function(note) {
					if(!note.seen || note.notify_on_every_login) {
						var d = frappe.msgprint({message:note.content, title:note.title});
						d.keep_open = true;
						d.custom_onhide = function() {
							note.seen = true;

							// Mark note as read if the Notify On Every Login flag is not set
							if (!note.notify_on_every_login) {
								frappe.call({
									method: "frappe.desk.doctype.note.note.mark_as_seen",
									args: {
										note: note.name
									}
								});
							}

							// next note
							me.show_notes();

						};
					}
				});
			}
		},

		setup_build_error_listener: function setup_build_error_listener() {
			if (frappe.boot.developer_mode) {
				frappe.realtime.on('build_error', function (data) {
					console.log(data);
				});
			}
		},

		setup_social_listeners: function setup_social_listeners() {
			frappe.realtime.on('mention', function (message) {
				if (frappe.get_route()[0] !== 'social') {
					frappe.show_alert(message);
				}
			});
		},

		setup_energy_point_listeners: function setup_energy_point_listeners() {
			frappe.realtime.on('energy_point_alert', function (message) {
				frappe.show_alert(message);
			});
		},
	});

	frappe.get_module = function(m, default_module) {
		var module = frappe.modules[m] || default_module;
		if (!module) {
			return;
		}

		if(module._setup) {
			return module;
		}

		if(module.type==="module" && !module.link) {
			module.link = "modules/" + module.module_name;
		}

		if(module.type==="list" && !module.link) {
			module.link = "List/" + module._doctype;
		}

		if (!module.link) { module.link = ""; }

		if (!module._id) {
			// links can have complex values that range beyond simple plain text names, and so do not make for robust IDs.
			// an example from python: "link": r"javascript:eval('window.open(\'timetracking\', \'_self\')')"
			// this snippet allows a module to open a custom html page in the same window.
			module._id = module.module_name.toLowerCase();
		}


		if(!module.label) {
			module.label = m;
		}

		if(!module._label) {
			module._label = __(module.label);
		}

		if(!module._doctype) {
			module._doctype = '';
		}

		module._setup = true;

		return module;
	};

	frappe.provide('frappe.utils');

	function get_url_arg(name) {
		return get_query_params()[name] || "";
	}

	function get_query_string(url) {
		if(url.includes("?")) {
			return url.slice(url.indexOf("?")+1);
		}else {
			return "";
		}
	}

	function get_query_params(query_string) {
		var query_params = {};
		if (!query_string) {
			query_string = location.search.substring(1);
		}

		var query_list = query_string.split("&");
		for (var i=0, l=query_list.length; i < l; i++ ){
			var pair = query_list[i].split(/=(.+)/);
			var key = pair[0];
			if (!key) {
				continue;
			}

			var value = pair[1];
			if (typeof value === "string") {
				value = value.replace(/\+/g, "%20");
				try {
					value = decodeURIComponent(value);
				} catch(e) {
					// if value contains %, it fails
				}
			}

			if (key in query_params) {
				if (typeof query_params[key] === "undefined") {
					query_params[key] = [];
				} else if (typeof query_params[key] === "string") {
					query_params[key] = [query_params[key]];
				}
				query_params[key].push(value);
			} else {
				query_params[key] = value;
			}
		}
		return query_params;
	}

	function make_query_string(obj, encode) {
		if ( encode === void 0 ) encode=true;

		var query_params = [];
		for (var key in obj) {
			var value = obj[key];
			if (value === undefined || value === '' || value === null) {
				continue;
			}
			if (typeof value === 'object') {
				value = JSON.stringify(value);
			}

			if (encode) {
				key = encodeURIComponent(key);
				value = encodeURIComponent(value);
			}

			query_params.push((key + "=" + value));
		}
		return '?' + query_params.join('&');
	}

	Object.assign(frappe.utils, {
		get_url_arg: get_url_arg,
		get_query_string: get_query_string,
		get_query_params: get_query_params,
		make_query_string: make_query_string
	});

	frappe.templates['rating_icons'] = '{% if show_label %}  {{ __("Rating: ") }} {% endif %} {% for(var i=1, l=6; i<l; i++) { %}  <i class="fa fa-fw {{ i<=rating? "fa-star": "fa-star-o" }} star-icon" data-idx=1></i> {% } %}';

	var fuse = createCommonjsModule(function (module, exports) {
	/*!
	 * Fuse.js v3.4.2 - Lightweight fuzzy-search (http://fusejs.io)
	 * 
	 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
	 * All Rights Reserved. Apache Software License 2.0
	 * 
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */
	(function webpackUniversalModuleDefinition(root, factory) {
		{ module.exports = factory(); }
	})(commonjsGlobal, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId]) {
	/******/ 			return installedModules[moduleId].exports;
	/******/ 		}
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			i: moduleId,
	/******/ 			l: false,
	/******/ 			exports: {}
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.l = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// define getter function for harmony exports
	/******/ 	__webpack_require__.d = function(exports, name, getter) {
	/******/ 		if(!__webpack_require__.o(exports, name)) {
	/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
	/******/ 		}
	/******/ 	};
	/******/
	/******/ 	// define __esModule on exports
	/******/ 	__webpack_require__.r = function(exports) {
	/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
	/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	/******/ 		}
	/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
	/******/ 	};
	/******/
	/******/ 	// create a fake namespace object
	/******/ 	// mode & 1: value is a module id, require it
	/******/ 	// mode & 2: merge all properties of value into the ns
	/******/ 	// mode & 4: return value when already ns object
	/******/ 	// mode & 8|1: behave like require
	/******/ 	__webpack_require__.t = function(value, mode) {
	/******/ 		if(mode & 1) { value = __webpack_require__(value); }
	/******/ 		if(mode & 8) { return value; }
	/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) { return value; }
	/******/ 		var ns = Object.create(null);
	/******/ 		__webpack_require__.r(ns);
	/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
	/******/ 		if(mode & 2 && typeof value != 'string') { for(var key in value) { __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key)); } }
	/******/ 		return ns;
	/******/ 	};
	/******/
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/ 	__webpack_require__.n = function(module) {
	/******/ 		var getter = module && module.__esModule ?
	/******/ 			function getDefault() { return module['default']; } :
	/******/ 			function getModuleExports() { return module; };
	/******/ 		__webpack_require__.d(getter, 'a', getter);
	/******/ 		return getter;
	/******/ 	};
	/******/
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
	/******/ })
	/************************************************************************/
	/******/ ({

	/***/ "./src/bitap/bitap_matched_indices.js":
	/*!********************************************!*\
	  !*** ./src/bitap/bitap_matched_indices.js ***!
	  \********************************************/
	/*! no static exports found */
	/***/ (function(module, exports) {

	module.exports = function () {
	  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  var matchedIndices = [];
	  var start = -1;
	  var end = -1;
	  var i = 0;

	  for (var len = matchmask.length; i < len; i += 1) {
	    var match = matchmask[i];

	    if (match && start === -1) {
	      start = i;
	    } else if (!match && start !== -1) {
	      end = i - 1;

	      if (end - start + 1 >= minMatchCharLength) {
	        matchedIndices.push([start, end]);
	      }

	      start = -1;
	    }
	  } // (i-1 - start) + 1 => i - start


	  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
	    matchedIndices.push([start, i - 1]);
	  }

	  return matchedIndices;
	};

	/***/ }),

	/***/ "./src/bitap/bitap_pattern_alphabet.js":
	/*!*********************************************!*\
	  !*** ./src/bitap/bitap_pattern_alphabet.js ***!
	  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports) {

	module.exports = function (pattern) {
	  var mask = {};
	  var len = pattern.length;

	  for (var i = 0; i < len; i += 1) {
	    mask[pattern.charAt(i)] = 0;
	  }

	  for (var _i = 0; _i < len; _i += 1) {
	    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;
	  }

	  return mask;
	};

	/***/ }),

	/***/ "./src/bitap/bitap_regex_search.js":
	/*!*****************************************!*\
	  !*** ./src/bitap/bitap_regex_search.js ***!
	  \*****************************************/
	/*! no static exports found */
	/***/ (function(module, exports) {

	var SPECIAL_CHARS_REGEX = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;

	module.exports = function (text, pattern) {
	  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;
	  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\$&').replace(tokenSeparator, '|'));
	  var matches = text.match(regex);
	  var isMatch = !!matches;
	  var matchedIndices = [];

	  if (isMatch) {
	    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {
	      var match = matches[i];
	      matchedIndices.push([text.indexOf(match), match.length - 1]);
	    }
	  }

	  return {
	    // TODO: revisit this score
	    score: isMatch ? 0.5 : 1,
	    isMatch: isMatch,
	    matchedIndices: matchedIndices
	  };
	};

	/***/ }),

	/***/ "./src/bitap/bitap_score.js":
	/*!**********************************!*\
	  !*** ./src/bitap/bitap_score.js ***!
	  \**********************************/
	/*! no static exports found */
	/***/ (function(module, exports) {

	module.exports = function (pattern, _ref) {
	  var _ref$errors = _ref.errors,
	      errors = _ref$errors === void 0 ? 0 : _ref$errors,
	      _ref$currentLocation = _ref.currentLocation,
	      currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,
	      _ref$expectedLocation = _ref.expectedLocation,
	      expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,
	      _ref$distance = _ref.distance,
	      distance = _ref$distance === void 0 ? 100 : _ref$distance;
	  var accuracy = errors / pattern.length;
	  var proximity = Math.abs(expectedLocation - currentLocation);

	  if (!distance) {
	    // Dodge divide by zero error.
	    return proximity ? 1.0 : accuracy;
	  }

	  return accuracy + proximity / distance;
	};

	/***/ }),

	/***/ "./src/bitap/bitap_search.js":
	/*!***********************************!*\
	  !*** ./src/bitap/bitap_search.js ***!
	  \***********************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

	var bitapScore = __webpack_require__(/*! ./bitap_score */ "./src/bitap/bitap_score.js");

	var matchedIndices = __webpack_require__(/*! ./bitap_matched_indices */ "./src/bitap/bitap_matched_indices.js");

	module.exports = function (text, pattern, patternAlphabet, _ref) {
	  var _ref$location = _ref.location,
	      location = _ref$location === void 0 ? 0 : _ref$location,
	      _ref$distance = _ref.distance,
	      distance = _ref$distance === void 0 ? 100 : _ref$distance,
	      _ref$threshold = _ref.threshold,
	      threshold = _ref$threshold === void 0 ? 0.6 : _ref$threshold,
	      _ref$findAllMatches = _ref.findAllMatches,
	      findAllMatches = _ref$findAllMatches === void 0 ? false : _ref$findAllMatches,
	      _ref$minMatchCharLeng = _ref.minMatchCharLength,
	      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? 1 : _ref$minMatchCharLeng;
	  var expectedLocation = location; // Set starting location at beginning text and initialize the alphabet.

	  var textLen = text.length; // Highest score beyond which we give up.

	  var currentThreshold = threshold; // Is there a nearby exact match? (speedup)

	  var bestLocation = text.indexOf(pattern, expectedLocation);
	  var patternLen = pattern.length; // a mask of the matches

	  var matchMask = [];

	  for (var i = 0; i < textLen; i += 1) {
	    matchMask[i] = 0;
	  }

	  if (bestLocation !== -1) {
	    var score = bitapScore(pattern, {
	      errors: 0,
	      currentLocation: bestLocation,
	      expectedLocation: expectedLocation,
	      distance: distance
	    });
	    currentThreshold = Math.min(score, currentThreshold); // What about in the other direction? (speed up)

	    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);

	    if (bestLocation !== -1) {
	      var _score = bitapScore(pattern, {
	        errors: 0,
	        currentLocation: bestLocation,
	        expectedLocation: expectedLocation,
	        distance: distance
	      });

	      currentThreshold = Math.min(_score, currentThreshold);
	    }
	  } // Reset the best location


	  bestLocation = -1;
	  var lastBitArr = [];
	  var finalScore = 1;
	  var binMax = patternLen + textLen;
	  var mask = 1 << patternLen - 1;

	  for (var _i = 0; _i < patternLen; _i += 1) {
	    // Scan for the best match; each iteration allows for one more error.
	    // Run a binary search to determine how far from the match location we can stray
	    // at this error level.
	    var binMin = 0;
	    var binMid = binMax;

	    while (binMin < binMid) {
	      var _score3 = bitapScore(pattern, {
	        errors: _i,
	        currentLocation: expectedLocation + binMid,
	        expectedLocation: expectedLocation,
	        distance: distance
	      });

	      if (_score3 <= currentThreshold) {
	        binMin = binMid;
	      } else {
	        binMax = binMid;
	      }

	      binMid = Math.floor((binMax - binMin) / 2 + binMin);
	    } // Use the result from this iteration as the maximum for the next.


	    binMax = binMid;
	    var start = Math.max(1, expectedLocation - binMid + 1);
	    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen; // Initialize the bit array

	    var bitArr = Array(finish + 2);
	    bitArr[finish + 1] = (1 << _i) - 1;

	    for (var j = finish; j >= start; j -= 1) {
	      var currentLocation = j - 1;
	      var charMatch = patternAlphabet[text.charAt(currentLocation)];

	      if (charMatch) {
	        matchMask[currentLocation] = 1;
	      } // First pass: exact match


	      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch; // Subsequent passes: fuzzy match

	      if (_i !== 0) {
	        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
	      }

	      if (bitArr[j] & mask) {
	        finalScore = bitapScore(pattern, {
	          errors: _i,
	          currentLocation: currentLocation,
	          expectedLocation: expectedLocation,
	          distance: distance
	        }); // This match will almost certainly be better than any existing match.
	        // But check anyway.

	        if (finalScore <= currentThreshold) {
	          // Indeed it is
	          currentThreshold = finalScore;
	          bestLocation = currentLocation; // Already passed `loc`, downhill from here on in.

	          if (bestLocation <= expectedLocation) {
	            break;
	          } // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.


	          start = Math.max(1, 2 * expectedLocation - bestLocation);
	        }
	      }
	    } // No hope for a (better) match at greater error levels.


	    var _score2 = bitapScore(pattern, {
	      errors: _i + 1,
	      currentLocation: expectedLocation,
	      expectedLocation: expectedLocation,
	      distance: distance
	    }); // console.log('score', score, finalScore)


	    if (_score2 > currentThreshold) {
	      break;
	    }

	    lastBitArr = bitArr;
	  } // console.log('FINAL SCORE', finalScore)
	  // Count exact matches (those with a score of 0) to be "almost" exact


	  return {
	    isMatch: bestLocation >= 0,
	    score: finalScore === 0 ? 0.001 : finalScore,
	    matchedIndices: matchedIndices(matchMask, minMatchCharLength)
	  };
	};

	/***/ }),

	/***/ "./src/bitap/index.js":
	/*!****************************!*\
	  !*** ./src/bitap/index.js ***!
	  \****************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) { _defineProperties(Constructor.prototype, protoProps); } if (staticProps) { _defineProperties(Constructor, staticProps); } return Constructor; }

	var bitapRegexSearch = __webpack_require__(/*! ./bitap_regex_search */ "./src/bitap/bitap_regex_search.js");

	var bitapSearch = __webpack_require__(/*! ./bitap_search */ "./src/bitap/bitap_search.js");

	var patternAlphabet = __webpack_require__(/*! ./bitap_pattern_alphabet */ "./src/bitap/bitap_pattern_alphabet.js");

	var Bitap =
	/*#__PURE__*/
	function () {
	  function Bitap(pattern, _ref) {
	    var _ref$location = _ref.location,
	        location = _ref$location === void 0 ? 0 : _ref$location,
	        _ref$distance = _ref.distance,
	        distance = _ref$distance === void 0 ? 100 : _ref$distance,
	        _ref$threshold = _ref.threshold,
	        threshold = _ref$threshold === void 0 ? 0.6 : _ref$threshold,
	        _ref$maxPatternLength = _ref.maxPatternLength,
	        maxPatternLength = _ref$maxPatternLength === void 0 ? 32 : _ref$maxPatternLength,
	        _ref$isCaseSensitive = _ref.isCaseSensitive,
	        isCaseSensitive = _ref$isCaseSensitive === void 0 ? false : _ref$isCaseSensitive,
	        _ref$tokenSeparator = _ref.tokenSeparator,
	        tokenSeparator = _ref$tokenSeparator === void 0 ? / +/g : _ref$tokenSeparator,
	        _ref$findAllMatches = _ref.findAllMatches,
	        findAllMatches = _ref$findAllMatches === void 0 ? false : _ref$findAllMatches,
	        _ref$minMatchCharLeng = _ref.minMatchCharLength,
	        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? 1 : _ref$minMatchCharLeng;

	    _classCallCheck(this, Bitap);

	    this.options = {
	      location: location,
	      distance: distance,
	      threshold: threshold,
	      maxPatternLength: maxPatternLength,
	      isCaseSensitive: isCaseSensitive,
	      tokenSeparator: tokenSeparator,
	      findAllMatches: findAllMatches,
	      minMatchCharLength: minMatchCharLength
	    };
	    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();

	    if (this.pattern.length <= maxPatternLength) {
	      this.patternAlphabet = patternAlphabet(this.pattern);
	    }
	  }

	  _createClass(Bitap, [{
	    key: "search",
	    value: function search(text) {
	      if (!this.options.isCaseSensitive) {
	        text = text.toLowerCase();
	      } // Exact match


	      if (this.pattern === text) {
	        return {
	          isMatch: true,
	          score: 0,
	          matchedIndices: [[0, text.length - 1]]
	        };
	      } // When pattern length is greater than the machine word length, just do a a regex comparison


	      var _this$options = this.options,
	          maxPatternLength = _this$options.maxPatternLength,
	          tokenSeparator = _this$options.tokenSeparator;

	      if (this.pattern.length > maxPatternLength) {
	        return bitapRegexSearch(text, this.pattern, tokenSeparator);
	      } // Otherwise, use Bitap algorithm


	      var _this$options2 = this.options,
	          location = _this$options2.location,
	          distance = _this$options2.distance,
	          threshold = _this$options2.threshold,
	          findAllMatches = _this$options2.findAllMatches,
	          minMatchCharLength = _this$options2.minMatchCharLength;
	      return bitapSearch(text, this.pattern, this.patternAlphabet, {
	        location: location,
	        distance: distance,
	        threshold: threshold,
	        findAllMatches: findAllMatches,
	        minMatchCharLength: minMatchCharLength
	      });
	    }
	  }]);

	  return Bitap;
	}(); // let x = new Bitap("od mn war", {})
	// let result = x.search("Old Man's War")
	// console.log(result)


	module.exports = Bitap;

	/***/ }),

	/***/ "./src/helpers/deep_value.js":
	/*!***********************************!*\
	  !*** ./src/helpers/deep_value.js ***!
	  \***********************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(/*! ./is_array */ "./src/helpers/is_array.js");

	var deepValue = function deepValue(obj, path, list) {
	  if (!path) {
	    // If there's no path left, we've gotten to the object we care about.
	    list.push(obj);
	  } else {
	    var dotIndex = path.indexOf('.');
	    var firstSegment = path;
	    var remaining = null;

	    if (dotIndex !== -1) {
	      firstSegment = path.slice(0, dotIndex);
	      remaining = path.slice(dotIndex + 1);
	    }

	    var value = obj[firstSegment];

	    if (value !== null && value !== undefined) {
	      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {
	        list.push(value.toString());
	      } else if (isArray(value)) {
	        // Search each item in the array.
	        for (var i = 0, len = value.length; i < len; i += 1) {
	          deepValue(value[i], remaining, list);
	        }
	      } else if (remaining) {
	        // An object. Recurse further.
	        deepValue(value, remaining, list);
	      }
	    }
	  }

	  return list;
	};

	module.exports = function (obj, path) {
	  return deepValue(obj, path, []);
	};

	/***/ }),

	/***/ "./src/helpers/is_array.js":
	/*!*********************************!*\
	  !*** ./src/helpers/is_array.js ***!
	  \*********************************/
	/*! no static exports found */
	/***/ (function(module, exports) {

	module.exports = function (obj) {
	  return !Array.isArray ? Object.prototype.toString.call(obj) === '[object Array]' : Array.isArray(obj);
	};

	/***/ }),

	/***/ "./src/index.js":
	/*!**********************!*\
	  !*** ./src/index.js ***!
	  \**********************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) { _defineProperties(Constructor.prototype, protoProps); } if (staticProps) { _defineProperties(Constructor, staticProps); } return Constructor; }

	var Bitap = __webpack_require__(/*! ./bitap */ "./src/bitap/index.js");

	var deepValue = __webpack_require__(/*! ./helpers/deep_value */ "./src/helpers/deep_value.js");

	var isArray = __webpack_require__(/*! ./helpers/is_array */ "./src/helpers/is_array.js");

	var Fuse =
	/*#__PURE__*/
	function () {
	  function Fuse(list, _ref) {
	    var _ref$location = _ref.location,
	        location = _ref$location === void 0 ? 0 : _ref$location,
	        _ref$distance = _ref.distance,
	        distance = _ref$distance === void 0 ? 100 : _ref$distance,
	        _ref$threshold = _ref.threshold,
	        threshold = _ref$threshold === void 0 ? 0.6 : _ref$threshold,
	        _ref$maxPatternLength = _ref.maxPatternLength,
	        maxPatternLength = _ref$maxPatternLength === void 0 ? 32 : _ref$maxPatternLength,
	        _ref$caseSensitive = _ref.caseSensitive,
	        caseSensitive = _ref$caseSensitive === void 0 ? false : _ref$caseSensitive,
	        _ref$tokenSeparator = _ref.tokenSeparator,
	        tokenSeparator = _ref$tokenSeparator === void 0 ? / +/g : _ref$tokenSeparator,
	        _ref$findAllMatches = _ref.findAllMatches,
	        findAllMatches = _ref$findAllMatches === void 0 ? false : _ref$findAllMatches,
	        _ref$minMatchCharLeng = _ref.minMatchCharLength,
	        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? 1 : _ref$minMatchCharLeng,
	        _ref$id = _ref.id,
	        id = _ref$id === void 0 ? null : _ref$id,
	        _ref$keys = _ref.keys,
	        keys = _ref$keys === void 0 ? [] : _ref$keys,
	        _ref$shouldSort = _ref.shouldSort,
	        shouldSort = _ref$shouldSort === void 0 ? true : _ref$shouldSort,
	        _ref$getFn = _ref.getFn,
	        getFn = _ref$getFn === void 0 ? deepValue : _ref$getFn,
	        _ref$sortFn = _ref.sortFn,
	        sortFn = _ref$sortFn === void 0 ? function (a, b) {
	      return a.score - b.score;
	    } : _ref$sortFn,
	        _ref$tokenize = _ref.tokenize,
	        tokenize = _ref$tokenize === void 0 ? false : _ref$tokenize,
	        _ref$matchAllTokens = _ref.matchAllTokens,
	        matchAllTokens = _ref$matchAllTokens === void 0 ? false : _ref$matchAllTokens,
	        _ref$includeMatches = _ref.includeMatches,
	        includeMatches = _ref$includeMatches === void 0 ? false : _ref$includeMatches,
	        _ref$includeScore = _ref.includeScore,
	        includeScore = _ref$includeScore === void 0 ? false : _ref$includeScore,
	        _ref$verbose = _ref.verbose,
	        verbose = _ref$verbose === void 0 ? false : _ref$verbose;

	    _classCallCheck(this, Fuse);

	    this.options = {
	      location: location,
	      distance: distance,
	      threshold: threshold,
	      maxPatternLength: maxPatternLength,
	      isCaseSensitive: caseSensitive,
	      tokenSeparator: tokenSeparator,
	      findAllMatches: findAllMatches,
	      minMatchCharLength: minMatchCharLength,
	      id: id,
	      keys: keys,
	      includeMatches: includeMatches,
	      includeScore: includeScore,
	      shouldSort: shouldSort,
	      getFn: getFn,
	      sortFn: sortFn,
	      verbose: verbose,
	      tokenize: tokenize,
	      matchAllTokens: matchAllTokens
	    };
	    this.setCollection(list);
	  }

	  _createClass(Fuse, [{
	    key: "setCollection",
	    value: function setCollection(list) {
	      this.list = list;
	      return list;
	    }
	  }, {
	    key: "search",
	    value: function search(pattern) {
	      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	        limit: false
	      };

	      this._log("---------\nSearch pattern: \"".concat(pattern, "\""));

	      var _this$_prepareSearche = this._prepareSearchers(pattern),
	          tokenSearchers = _this$_prepareSearche.tokenSearchers,
	          fullSearcher = _this$_prepareSearche.fullSearcher;

	      var _this$_search = this._search(tokenSearchers, fullSearcher),
	          weights = _this$_search.weights,
	          results = _this$_search.results;

	      this._computeScore(weights, results);

	      if (this.options.shouldSort) {
	        this._sort(results);
	      }

	      if (opts.limit && typeof opts.limit === 'number') {
	        results = results.slice(0, opts.limit);
	      }

	      return this._format(results);
	    }
	  }, {
	    key: "_prepareSearchers",
	    value: function _prepareSearchers() {
	      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var tokenSearchers = [];

	      if (this.options.tokenize) {
	        // Tokenize on the separator
	        var tokens = pattern.split(this.options.tokenSeparator);

	        for (var i = 0, len = tokens.length; i < len; i += 1) {
	          tokenSearchers.push(new Bitap(tokens[i], this.options));
	        }
	      }

	      var fullSearcher = new Bitap(pattern, this.options);
	      return {
	        tokenSearchers: tokenSearchers,
	        fullSearcher: fullSearcher
	      };
	    }
	  }, {
	    key: "_search",
	    value: function _search() {
	      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var fullSearcher = arguments.length > 1 ? arguments[1] : undefined;
	      var list = this.list;
	      var resultMap = {};
	      var results = []; // Check the first item in the list, if it's a string, then we assume
	      // that every item in the list is also a string, and thus it's a flattened array.

	      if (typeof list[0] === 'string') {
	        // Iterate over every item
	        for (var i = 0, len = list.length; i < len; i += 1) {
	          this._analyze({
	            key: '',
	            value: list[i],
	            record: i,
	            index: i
	          }, {
	            resultMap: resultMap,
	            results: results,
	            tokenSearchers: tokenSearchers,
	            fullSearcher: fullSearcher
	          });
	        }

	        return {
	          weights: null,
	          results: results
	        };
	      } // Otherwise, the first item is an Object (hopefully), and thus the searching
	      // is done on the values of the keys of each item.


	      var weights = {};

	      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {
	        var item = list[_i]; // Iterate over every key

	        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {
	          var key = this.options.keys[j];

	          if (typeof key !== 'string') {
	            weights[key.name] = {
	              weight: 1 - key.weight || 1
	            };

	            if (key.weight <= 0 || key.weight > 1) {
	              throw new Error('Key weight has to be > 0 and <= 1');
	            }

	            key = key.name;
	          } else {
	            weights[key] = {
	              weight: 1
	            };
	          }

	          this._analyze({
	            key: key,
	            value: this.options.getFn(item, key),
	            record: item,
	            index: _i
	          }, {
	            resultMap: resultMap,
	            results: results,
	            tokenSearchers: tokenSearchers,
	            fullSearcher: fullSearcher
	          });
	        }
	      }

	      return {
	        weights: weights,
	        results: results
	      };
	    }
	  }, {
	    key: "_analyze",
	    value: function _analyze(_ref2, _ref3) {
	      var key = _ref2.key,
	          _ref2$arrayIndex = _ref2.arrayIndex,
	          arrayIndex = _ref2$arrayIndex === void 0 ? -1 : _ref2$arrayIndex,
	          value = _ref2.value,
	          record = _ref2.record,
	          index = _ref2.index;
	      var _ref3$tokenSearchers = _ref3.tokenSearchers,
	          tokenSearchers = _ref3$tokenSearchers === void 0 ? [] : _ref3$tokenSearchers,
	          _ref3$fullSearcher = _ref3.fullSearcher,
	          fullSearcher = _ref3$fullSearcher === void 0 ? [] : _ref3$fullSearcher,
	          _ref3$resultMap = _ref3.resultMap,
	          resultMap = _ref3$resultMap === void 0 ? {} : _ref3$resultMap,
	          _ref3$results = _ref3.results,
	          results = _ref3$results === void 0 ? [] : _ref3$results;

	      // Check if the texvaluet can be searched
	      if (value === undefined || value === null) {
	        return;
	      }

	      var exists = false;
	      var averageScore = -1;
	      var numTextMatches = 0;

	      if (typeof value === 'string') {
	        this._log("\nKey: ".concat(key === '' ? '-' : key));

	        var mainSearchResult = fullSearcher.search(value);

	        this._log("Full text: \"".concat(value, "\", score: ").concat(mainSearchResult.score));

	        if (this.options.tokenize) {
	          var words = value.split(this.options.tokenSeparator);
	          var scores = [];

	          for (var i = 0; i < tokenSearchers.length; i += 1) {
	            var tokenSearcher = tokenSearchers[i];

	            this._log("\nPattern: \"".concat(tokenSearcher.pattern, "\"")); // let tokenScores = []


	            var hasMatchInText = false;

	            for (var j = 0; j < words.length; j += 1) {
	              var word = words[j];
	              var tokenSearchResult = tokenSearcher.search(word);
	              var obj = {};

	              if (tokenSearchResult.isMatch) {
	                obj[word] = tokenSearchResult.score;
	                exists = true;
	                hasMatchInText = true;
	                scores.push(tokenSearchResult.score);
	              } else {
	                obj[word] = 1;

	                if (!this.options.matchAllTokens) {
	                  scores.push(1);
	                }
	              }

	              this._log("Token: \"".concat(word, "\", score: ").concat(obj[word])); // tokenScores.push(obj)

	            }

	            if (hasMatchInText) {
	              numTextMatches += 1;
	            }
	          }

	          averageScore = scores[0];
	          var scoresLen = scores.length;

	          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {
	            averageScore += scores[_i2];
	          }

	          averageScore = averageScore / scoresLen;

	          this._log('Token score average:', averageScore);
	        }

	        var finalScore = mainSearchResult.score;

	        if (averageScore > -1) {
	          finalScore = (finalScore + averageScore) / 2;
	        }

	        this._log('Score average:', finalScore);

	        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;

	        this._log("\nCheck Matches: ".concat(checkTextMatches)); // If a match is found, add the item to <rawResults>, including its score


	        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {
	          // Check if the item already exists in our results
	          var existingResult = resultMap[index];

	          if (existingResult) {
	            // Use the lowest score
	            // existingResult.score, bitapResult.score
	            existingResult.output.push({
	              key: key,
	              arrayIndex: arrayIndex,
	              value: value,
	              score: finalScore,
	              matchedIndices: mainSearchResult.matchedIndices
	            });
	          } else {
	            // Add it to the raw result list
	            resultMap[index] = {
	              item: record,
	              output: [{
	                key: key,
	                arrayIndex: arrayIndex,
	                value: value,
	                score: finalScore,
	                matchedIndices: mainSearchResult.matchedIndices
	              }]
	            };
	            results.push(resultMap[index]);
	          }
	        }
	      } else if (isArray(value)) {
	        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {
	          this._analyze({
	            key: key,
	            arrayIndex: _i3,
	            value: value[_i3],
	            record: record,
	            index: index
	          }, {
	            resultMap: resultMap,
	            results: results,
	            tokenSearchers: tokenSearchers,
	            fullSearcher: fullSearcher
	          });
	        }
	      }
	    }
	  }, {
	    key: "_computeScore",
	    value: function _computeScore(weights, results) {
	      this._log('\n\nComputing score:\n');

	      for (var i = 0, len = results.length; i < len; i += 1) {
	        var output = results[i].output;
	        var scoreLen = output.length;
	        var currScore = 1;
	        var bestScore = 1;

	        for (var j = 0; j < scoreLen; j += 1) {
	          var weight = weights ? weights[output[j].key].weight : 1;
	          var score = weight === 1 ? output[j].score : output[j].score || 0.001;
	          var nScore = score * weight;

	          if (weight !== 1) {
	            bestScore = Math.min(bestScore, nScore);
	          } else {
	            output[j].nScore = nScore;
	            currScore *= nScore;
	          }
	        }

	        results[i].score = bestScore === 1 ? currScore : bestScore;

	        this._log(results[i]);
	      }
	    }
	  }, {
	    key: "_sort",
	    value: function _sort(results) {
	      this._log('\n\nSorting....');

	      results.sort(this.options.sortFn);
	    }
	  }, {
	    key: "_format",
	    value: function _format(results) {
	      var finalOutput = [];

	      if (this.options.verbose) {
	        var cache = [];

	        this._log('\n\nOutput:\n\n', JSON.stringify(results, function (key, value) {
	          if (_typeof(value) === 'object' && value !== null) {
	            if (cache.indexOf(value) !== -1) {
	              // Circular reference found, discard key
	              return;
	            } // Store value in our collection


	            cache.push(value);
	          }

	          return value;
	        }));

	        cache = null;
	      }

	      var transformers = [];

	      if (this.options.includeMatches) {
	        transformers.push(function (result, data) {
	          var output = result.output;
	          data.matches = [];

	          for (var i = 0, len = output.length; i < len; i += 1) {
	            var item = output[i];

	            if (item.matchedIndices.length === 0) {
	              continue;
	            }

	            var obj = {
	              indices: item.matchedIndices,
	              value: item.value
	            };

	            if (item.key) {
	              obj.key = item.key;
	            }

	            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {
	              obj.arrayIndex = item.arrayIndex;
	            }

	            data.matches.push(obj);
	          }
	        });
	      }

	      if (this.options.includeScore) {
	        transformers.push(function (result, data) {
	          data.score = result.score;
	        });
	      }

	      for (var i = 0, len = results.length; i < len; i += 1) {
	        var result = results[i];

	        if (this.options.id) {
	          result.item = this.options.getFn(result.item, this.options.id)[0];
	        }

	        if (!transformers.length) {
	          finalOutput.push(result.item);
	          continue;
	        }

	        var data = {
	          item: result.item
	        };

	        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {
	          transformers[j](result, data);
	        }

	        finalOutput.push(data);
	      }

	      return finalOutput;
	    }
	  }, {
	    key: "_log",
	    value: function _log() {
	      if (this.options.verbose) {
	        var _console;

	        (_console = console).log.apply(_console, arguments);
	      }
	    }
	  }]);

	  return Fuse;
	}();

	module.exports = Fuse;

	/***/ })

	/******/ });
	});
	});

	var Fuse = unwrapExports(fuse);

	var hyper_min = createCommonjsModule(function (module) {
	!function(){function e(){}function t(t,n){
	var arguments$1 = arguments;
	var o,r,i,l,a=W;for(l=arguments.length;l-- >2;){ S.push(arguments$1[l]); }n&&null!=n.children&&(S.length||S.push(n.children),delete n.children);while(S.length){ if((r=S.pop())&&void 0!==r.pop){ for(l=r.length;l--;){ S.push(r[l]); } }else{ "boolean"==typeof r&&(r=null),(i="function"!=typeof t)&&(null==r?r="":"number"==typeof r?r+="":"string"!=typeof r&&(i=!1)),i&&o?a[a.length-1]+=r:a===W?a=[r]:a.push(r),o=i; } }var _=new e;return _.nodeName=t,_.children=a,_.attributes=null==n?void 0:n,_.key=null==n?void 0:n.key,_}function n(e,t){for(var n in t){ e[n]=t[n]; }return e}function o(e){!e.__d&&(e.__d=!0)&&1==A.push(e)&&(V)(r);}function r(){var e,t=A;A=[];while(e=t.pop()){ e.__d&&N(e); }}function i(e,t,n){return "string"==typeof t||"number"==typeof t?void 0!==e.splitText:"string"==typeof t.nodeName?!e._componentConstructor&&l(e,t.nodeName):n||e._componentConstructor===t.nodeName}function l(e,t){return e.__n===t||e.nodeName.toLowerCase()===t.toLowerCase()}function a(e){var t=n({},e.attributes);t.children=e.children;var o=e.nodeName.defaultProps;if(void 0!==o){ for(var r in o){ void 0===t[r]&&(t[r]=o[r]); } }return t}function _(e,t){var n=t?document.createElementNS("http://www.w3.org/2000/svg",e):document.createElement(e);return n.__n=e,n}function u(e){var t=e.parentNode;t&&t.removeChild(e);}function p(e,t,n,o,r){if("className"===t&&(t="class"),"key"===t);else if("ref"===t){ n&&n(null),o&&o(e); }else if("class"!==t||r){ if("style"===t){if(o&&"string"!=typeof o&&"string"!=typeof n||(e.style.cssText=o||""),o&&"object"==typeof o){if("string"!=typeof n){ for(var i in n){ i in o||(e.style[i]=""); } }for(var i in o){ e.style[i]="number"==typeof o[i]&&!1===P.test(i)?o[i]+"px":o[i]; }}}else if("html"===t){ o&&(e.innerHTML=o); }else if("o"==t[0]&&"n"==t[1]){var l=t!==(t=t.replace(/Capture$/,""));t=t.toLowerCase().substring(2),o?n||e.addEventListener(t,s,l):e.removeEventListener(t,s,l),(e.__l||(e.__l={}))[t]=o;}else if("list"!==t&&"type"!==t&&!r&&t in e){ c(e,t,null==o?"":o),null!=o&&!1!==o||e.removeAttribute(t); }else{var a=r&&t!==(t=t.replace(/^xlink\:?/,""));null==o||!1===o?a?e.removeAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase()):e.removeAttribute(t):"function"!=typeof o&&(a?e.setAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase(),o):e.setAttribute(t,o));} }else { e.className=o||""; }}function c(e,t,n){try{e[t]=n;}catch(e){}}function s(e){return this.__l[e.type](e)}function f(){var e;while(e=E.pop()){ e.on_mounted&&e.on_mounted(); }}function d(e,t,n,o,r,i){D++||(H=null!=r&&void 0!==r.ownerSVGElement,R=null!=e&&!("__hyperattr_"in e));var l=h(e,t,n,o,i);return r&&l.parentNode!==r&&r.appendChild(l),--D||(R=!1,i||f()),l}function h(e,t,n,o,r){var i=e,a=H;if(null!=t&&"boolean"!=typeof t||(t=""),"string"==typeof t||"number"==typeof t){ return e&&void 0!==e.splitText&&e.parentNode&&(!e._component||r)?e.nodeValue!=t&&(e.nodeValue=t):(i=document.createTextNode(t),e&&(e.parentNode&&e.parentNode.replaceChild(i,e),m(e,!0))),i.__hyperattr_=!0,i; }var u=t.nodeName;if("function"==typeof u){ return k(e,t,n,o); }if(H="svg"===u||"foreignObject"!==u&&H,u+="",(!e||!l(e,u))&&(i=_(u,H),e)){while(e.firstChild){ i.appendChild(e.firstChild); }e.parentNode&&e.parentNode.replaceChild(i,e),m(e,!0);}var p=i.firstChild,c=i.__hyperattr_,s=t.children;if(null==c){c=i.__hyperattr_={};for(var f=i.attributes,d=f.length;d--;){ c[f[d].name]=f[d].value; }}return !R&&s&&1===s.length&&"string"==typeof s[0]&&null!=p&&void 0!==p.splitText&&null==p.nextSibling?p.nodeValue!=s[0]&&(p.nodeValue=s[0]):(s&&s.length||null!=p)&&v(i,s,n,o,R||null!=c.html),y(i,t.attributes,c),H=a,i}function v(e,t,n,o,r){var l,a,_,p,c,s=e.childNodes,f=[],d={},v=0,b=0,y=s.length,g=0,w=t?t.length:0;if(0!==y){ for(var C=0;C<y;C++){var x=s[C],N=x.__hyperattr_,k=w&&N?x._component?x._component.__k:N.key:null;null!=k?(v++,d[k]=x):(N||(void 0!==x.splitText?!r||x.nodeValue.trim():r))&&(f[g++]=x);} }if(0!==w){ for(var C=0;C<w;C++){p=t[C],c=null;var k=p.key;if(null!=k){ v&&void 0!==d[k]&&(c=d[k],d[k]=void 0,v--); }else if(!c&&b<g){ for(l=b;l<g;l++){ if(void 0!==f[l]&&i(a=f[l],p,r)){c=a,f[l]=void 0,l===g-1&&g--,l===b&&b++;break} } }c=h(c,p,n,o),_=s[C],c&&c!==e&&c!==_&&(null==_?e.appendChild(c):c===_.nextSibling?u(_):e.insertBefore(c,_));} }if(v){ for(var C in d){ void 0!==d[C]&&m(d[C],!1); } }while(b<=g){ void 0!==(c=f[g--])&&m(c,!1); }}function m(e,t){var n=e._component;n?U(n):(null!=e.__hyperattr_&&e.__hyperattr_.ref&&e.__hyperattr_.ref(null),!1!==t&&null!=e.__hyperattr_||u(e),b(e));}function b(e){e=e.lastChild;while(e){var t=e.previousSibling;m(e,!0),e=t;}}function y(e,t,n){var o;for(o in n){ t&&null!=t[o]||null==n[o]||p(e,o,n[o],n[o]=void 0,H); }for(o in t){ "children"===o||"innerHTML"===o||o in n&&t[o]===("value"===o||"checked"===o?e[o]:n[o])||p(e,o,n[o],n[o]=t[o],H); }}function g(e){var t=e.constructor.name;(j[t]||(j[t]=[])).push(e);}function w(e,t,n){var o,r=j[e.name];if(e.prototype&&e.prototype.render?(o=new e(t,n),L.call(o,t,n)):(o=new L(t,n),o.constructor=e,o.render=C),r){ for(var i=r.length;i--;){ if(r[i].constructor===e){o.__b=r[i].__b,r.splice(i,1);break} } }return o}function C(e,t,n){return this.constructor(e,n)}function x(e,t,n,r,i){e.__x||(e.__x=!0,(e.__r=t.ref)&&delete t.ref,(e.__k=t.key)&&delete t.key,!e.base||i?e.on_mount&&e.on_mount():e.componentWillReceiveProps&&e.componentWillReceiveProps(t,r),r&&r!==e.context&&(e.__c||(e.__c=e.context),e.context=r),e.__p||(e.__p=e.props),e.props=t,e.__x=!1,0!==n&&(1!==n&&!1===M.syncComponentUpdates&&e.base?o(e):N(e,1,i)),e.__r&&e.__r(e));}function N(e,t,o,r){if(!e.__x){var i,l,_,u=e.props,p=e.state,c=e.context,s=e.__p||u,h=e.__s||p,v=e.__c||c,b=e.base,y=e.__b,g=b||y,C=e._component,k=!1;if(b&&(e.props=s,e.state=h,e.context=v,2!==t&&e.shouldComponentUpdate&&!1===e.shouldComponentUpdate(u,p,c)?k=!0:e.componentWillUpdate&&e.componentWillUpdate(u,p,c),e.props=u,e.state=p,e.context=c),e.__p=e.__s=e.__c=e.__b=null,e.__d=!1,!k){i=e.render(u,p,c),e.getChildContext&&(c=n(n({},c),e.getChildContext()));var L,T,S=i&&i.nodeName;if("function"==typeof S){var W=a(i);l=C,l&&l.constructor===S&&W.key==l.__k?x(l,W,1,c,!1):(L=l,e._component=l=w(S,W,c),l.__b=l.__b||y,l.__u=e,x(l,W,0,c,!1),N(l,1,o,!0)),T=l.base;}else { _=g,L=C,L&&(_=e._component=null),(g||1===t)&&(_&&(_._component=null),T=d(_,i,c,o||!b,g&&g.parentNode,!0)); }if(g&&T!==g&&l!==C){var P=g.parentNode;P&&T!==P&&(P.replaceChild(T,g),L||(g._component=null,m(g,!1)));}if(L&&U(L),e.base=T,T&&!r){var V=e,A=e;while(A=A.__u){ (V=A).base=T; }T._component=V,T._componentConstructor=V.constructor;}}if(!b||o?E.unshift(e):k||(e.on_updated&&e.on_updated(s,h,v),M.afterUpdate&&M.afterUpdate(e)),null!=e.__h){ while(e.__h.length){ e.__h.pop().call(e); } }D||r||f();}}function k(e,t,n,o){var r=e&&e._component,i=r,l=e,_=r&&e._componentConstructor===t.nodeName,u=_,p=a(t);while(r&&!u&&(r=r.__u)){ u=r.constructor===t.nodeName; }return r&&u&&(!o||r._component)?(x(r,p,3,n,o),e=r.base):(i&&!_&&(U(i),e=l=null),r=w(t.nodeName,p,n),e&&!r.__b&&(r.__b=e,l=null),x(r,p,1,n,o),e=r.base,l&&e!==l&&(l._component=null,m(l,!1))),e}function U(e){var t=e.base;e.__x=!0,e.componentWillUnmount&&e.componentWillUnmount(),e.base=null;var n=e._component;n?U(n):t&&(t.__hyperattr_&&t.__hyperattr_.ref&&t.__hyperattr_.ref(null),e.__b=t,u(t),g(e),b(t)),e.__r&&e.__r(null);}function L(e,t){this.__d=!0,this.context=t,this.props=e,this.state=this.state||{};}function T(e,t,n){return d(n,e,{},!1,t,!1)}var M={},S=[],W=[],P=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,V="function"==typeof Promise?Promise.resolve().then.bind(Promise.resolve()):setTimeout,A=[],E=[],D=0,H=!1,R=!1,j={};n(L.prototype,{set_state:function(e,t){var r=this.state;this.__s||(this.__s=n({},r)),n(r,"function"==typeof e?e(r,this.props):e),t&&(this.__h=this.__h||[]).push(t),o(this);},forceUpdate:function(e){e&&(this.__h=this.__h||[]).push(e),N(this,2);},render:function(){}});var I={h:t,Component:L,render:T};module.exports=I;}();
	});

	// Frappe Chat

	/* eslint semi: "never" */
	// Fuck semicolons - https://mislav.net/2010/05/semicolons

	// frappe extensions

	/**
	 * @description The base class for all Frappe Errors.
	 *
	 * @example
	 * try
	 *      throw new frappe.Error("foobar")
	 * catch (e)
	 *      console.log(e.name)
	 * // returns "FrappeError"
	 *
	 * @see  https://stackoverflow.com/a/32749533
	 * @todo Requires "transform-builtin-extend" for Babel 6
	 */
	frappe.Error = Error;
	// class extends Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name = 'FrappeError'

	// 		if ( typeof Error.captureStackTrace === 'function' )
	// 			Error.captureStackTrace(this, this.constructor)
	// 		else
	// 			this.stack = (new Error(message)).stack
	// 	}
	// }

	/**
	 * @description TypeError
	 */
	frappe.TypeError  = TypeError;
	// class extends frappe.Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name = this.constructor.name
	// 	}
	// }

	/**
	 * @description ValueError
	 */
	frappe.ValueError = Error;
	// class extends frappe.Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name = this.constructor.name
	// 	}
	// }

	/**
	 * @description ImportError
	 */
	frappe.ImportError = Error;
	// class extends frappe.Error {
	// 	constructor (message) {
	// 		super (message)

	// 		this.name  = this.constructor.name
	// 	}
	// }

	// frappe.datetime
	frappe.provide('frappe.datetime');

	/**
	 * @description Frappe's datetime object. (Inspired by Python's datetime object).
	 *
	 * @example
	 * const datetime = new frappe.datetime.datetime()
	 */
	frappe.datetime.datetime = class {
		/**
		 * @description Frappe's datetime Class's constructor.
		 */
		constructor (instance, format) {
		if ( format === void 0 ) format = null;

			if ( typeof moment === 'undefined' )
				{ throw new frappe.ImportError("Moment.js not installed.") }

			this.moment = instance ? moment(instance, format) : moment();
		}

		/**
		 * @description Returns a formatted string of the datetime object.
		 */
		format (format) {
			if ( format === void 0 ) format = null;

			var  formatted = this.moment.format(format);
			return formatted
		}
	};

	/**
	 * @description Frappe's daterange object.
	 *
	 * @example
	 * const range = new frappe.datetime.range(frappe.datetime.now(), frappe.datetime.now())
	 * range.contains(frappe.datetime.now())
	 */
	frappe.datetime.range   = class {
		constructor (start, end) {
			if ( typeof moment === undefined )
				{ throw new frappe.ImportError("Moment.js not installed.") }

			this.start = start;
			this.end   = end;
		}

		contains (datetime) {
			var  contains = datetime.moment.isBetween(this.start.moment, this.end.moment);
			return contains
		}
	};

	/**
	 * @description Returns the current datetime.
	 *
	 * @example
	 * const datetime = new frappe.datetime.now()
	 */
	frappe.datetime.now   = function () { return new frappe.datetime.datetime(); };

	frappe.datetime.equal = function (a, b, type) {
		a = a.moment;
		b = b.moment;

		var equal = a.isSame(b, type);

		return equal
	};

	/**
	 * @description Compares two frappe.datetime.datetime objects.
	 *
	 * @param   {frappe.datetime.datetime} a - A frappe.datetime.datetime/moment object.
	 * @param   {frappe.datetime.datetime} b - A frappe.datetime.datetime/moment object.
	 *
	 * @returns {number} 0 (if a and b are equal), 1 (if a is before b), -1 (if a is after b).
	 *
	 * @example
	 * frappe.datetime.compare(frappe.datetime.now(), frappe.datetime.now())
	 * // returns 0
	 * const then = frappe.datetime.now()
	 *
	 * frappe.datetime.compare(then, frappe.datetime.now())
	 * // returns 1
	 */
	frappe.datetime.compare = function (a, b) {
		a = a.moment;
		b = b.moment;

		if ( a.isBefore(b) )
			{ return  1 }
		else
		if ( b.isBefore(a) )
			{ return -1 }
		else
			{ return  0 }
	};

	// frappe.quick_edit
	frappe.quick_edit      = function (doctype, docname, fn) {
		return new Promise(function (resolve) {
			frappe.model.with_doctype(doctype, function () {
				frappe.db.get_doc(doctype, docname).then(function (doc)  {
					var meta     = frappe.get_meta(doctype);
					var fields   = meta.fields;
					var required = fields.filter(function (f) { return f.reqd || f.bold && !f.read_only; });

					required.map(function (f) {
						if(f.fieldname == 'content' && doc.type == 'File') {
							f['read_only'] = 1;
						}
					});

					var dialog   = new frappe.ui.Dialog({
						 title: __(("Edit " + doctype + " (" + docname + ")")),
						fields: required,
						action: {
							primary: {
								   label: __("Save"),
								onsubmit: function (values) {
									frappe.call('frappe.client.save',
										{ doc: Object.assign({}, {doctype: doctype, docname: docname}, doc, values) })
										  .then(function (r) {
											if ( fn )
												{ fn(r.message); }

											resolve(r.message);
										  });

									dialog.hide();
								}
							},
							secondary: {
								label: __("Discard")
							}
						}
					});
					dialog.set_values(doc);

					var $element = $(dialog.body);
					$element.append(("\n\t\t\t\t\t<div class=\"qe-fp\" style=\"padding-top: '15px'; padding-bottom: '15px'; padding-left: '7px'\">\n\t\t\t\t\t\t<button class=\"btn btn-default btn-sm\">\n\t\t\t\t\t\t\t" + (__("Edit in Full Page")) + "\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t"));
					$element.find('.qe-fp').click(function () {
						dialog.hide();
						frappe.set_route(("Form/" + doctype + "/" + docname));
					});

					dialog.show();
				});
			});
		})
	};

	// frappe._
	// frappe's utility namespace.
	frappe.provide('frappe._');

	// String Utilities

	/**
	 * @description Python-inspired format extension for string objects.
	 *
	 * @param  {string} string - A string with placeholders.
	 * @param  {object} object - An object with placeholder, value pairs.
	 *
	 * @return {string}        - The formatted string.
	 *
	 * @example
	 * frappe._.format('{foo} {bar}', { bar: 'foo', foo: 'bar' })
	 * // returns "bar foo"
	 */
	frappe._.format = function (string, object) {
		for (var key in object)
			{ string  = string.replace(("{" + key + "}"), object[key]); }

		return string
	};

	/**
	 * @description Fuzzy Search a given query within a dataset.
	 *
	 * @param  {string} query   - A query string.
	 * @param  {array}  dataset - A dataset to search within, can contain singletons or objects.
	 * @param  {object} options - Options as per fuze.js
	 *
	 * @return {array}          - The fuzzy matched index/object within the dataset.
	 *
	 * @example
	 * frappe._.fuzzy_search("foobar", ["foobar", "bartender"])
	 * // returns [0, 1]
	 *
	 * @see http://fusejs.io
	 */
	frappe._.fuzzy_search = function (query, dataset, options) {
		var DEFAULT     = {
					shouldSort: true,
					 threshold: 0.6,
					  location: 0,
					  distance: 100,
			minMatchCharLength: 1,
			  maxPatternLength: 32
		};
		options       = Object.assign({}, DEFAULT, options);

		var fuse    = new Fuse(dataset, options);
		var result  = fuse.search(query);

		return result
	};

	/**
	 * @description Pluralizes a given word.
	 *
	 * @param  {string} word  - The word to be pluralized.
	 * @param  {number} count - The count.
	 *
	 * @return {string}       - The pluralized string.
	 *
	 * @example
	 * frappe._.pluralize('member',  1)
	 * // returns "member"
	 * frappe._.pluralize('members', 0)
	 * // returns "members"
	 *
	 * @todo Handle more edge cases.
	 */
	frappe._.pluralize = function (word, count, suffix) {
		if ( count === void 0 ) count = 0;
		if ( suffix === void 0 ) suffix = 's';

		return ("" + word + (count === 1 ? '' : suffix));
	};

	/**
	 * @description Captializes a given string.
	 *
	 * @param   {word}  - The word to be capitalized.
	 *
	 * @return {string} - The capitalized word.
	 *
	 * @example
	 * frappe._.capitalize('foobar')
	 * // returns "Foobar"
	 */
	frappe._.capitalize = function (word) { return ("" + (word.charAt(0).toUpperCase()) + (word.slice(1))); };

	// Array Utilities

	/**
	 * @description Returns the first element of an array.
	 *
	 * @param   {array} array - The array.
	 *
	 * @returns - The first element of an array, undefined elsewise.
	 *
	 * @example
	 * frappe._.head([1, 2, 3])
	 * // returns 1
	 * frappe._.head([])
	 * // returns undefined
	 */
	frappe._.head = function (arr) { return frappe._.is_empty(arr) ? undefined : arr[0]; };

	/**
	 * @description Returns a copy of the given array (shallow).
	 *
	 * @param   {array} array - The array to be copied.
	 *
	 * @returns {array}       - The copied array.
	 *
	 * @example
	 * frappe._.copy_array(["foobar", "barfoo"])
	 * // returns ["foobar", "barfoo"]
	 *
	 * @todo Add optional deep copy.
	 */
	frappe._.copy_array = function (array) {
		if ( Array.isArray(array) )
			{ return array.slice() }
		else
			{ throw frappe.TypeError(("Expected Array, recieved " + (typeof array) + " instead.")) }
	};

	/**
	 * @description Check whether an array|string|object|jQuery is empty.
	 *
	 * @param   {any}     value - The value to be checked on.
	 *
	 * @returns {boolean}       - Returns if the object is empty.
	 *
	 * @example
	 * frappe._.is_empty([])      // returns true
	 * frappe._.is_empty(["foo"]) // returns false
	 *
	 * frappe._.is_empty("")      // returns true
	 * frappe._.is_empty("foo")   // returns false
	 *
	 * frappe._.is_empty({ })            // returns true
	 * frappe._.is_empty({ foo: "bar" }) // returns false
	 *
	 * frappe._.is_empty($('.papito'))   // returns false
	 *
	 * @todo Handle other cases.
	 */
	frappe._.is_empty = function (value) {
		var empty = false;

		if ( value === undefined || value === null )
			{ empty = true; }
		else
		if ( Array.isArray(value) || typeof value === 'string' || value instanceof $ )
			{ empty = value.length === 0; }
		else
		if ( typeof value === 'object' )
			{ empty = Object.keys(value).length === 0; }

		return empty
	};

	/**
	 * @description Converts a singleton to an array, if required.
	 *
	 * @param {object} item - An object
	 *
	 * @example
	 * frappe._.as_array("foo")
	 * // returns ["foo"]
	 *
	 * frappe._.as_array(["foo"])
	 * // returns ["foo"]
	 *
	 * @see https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-
	 */
	frappe._.as_array = function (item) { return Array.isArray(item) ? item : [item]; };

	/**
	 * @description Return a singleton if array contains a single element.
	 *
	 * @param   {array}        list - An array to squash.
	 *
	 * @returns {array|object}      - Returns an array if there's more than 1 object else the first object itself.
	 *
	 * @example
	 * frappe._.squash(["foo"])
	 * // returns "foo"
	 *
	 * frappe._.squash(["foo", "bar"])
	 * // returns ["foo", "bar"]
	 */
	frappe._.squash = function (list) { return Array.isArray(list) && list.length === 1 ? list[0] : list; };

	/**
	 * @description Returns true, if the current device is a mobile device.
	 *
	 * @example
	 * frappe._.is_mobile()
	 * // returns true|false
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
	 */
	frappe._.is_mobile = function () {
		var regex    = new RegExp("Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini", "i");
		var agent    = navigator.userAgent;
		var mobile   = regex.test(agent);

		return mobile
	};

	/**
	 * @description Removes falsey values from an array.
	 *
	 * @example
	 * frappe._.compact([1, 2, false, NaN, ''])
	 * // returns [1, 2]
	 */
	frappe._.compact   = function (array) { return array.filter(Boolean); };

	// extend utils to base.
	frappe.utils       = Object.assign({}, frappe.utils, frappe._);

	// frappe extensions

	// frappe.user extensions
	/**
	 * @description Returns the first name of a User.
	 *
	 * @param {string} user - User
	 *
	 * @returns The first name of the user.
	 *
	 * @example
	 * frappe.user.first_name("Rahul Malhotra")
	 * // returns "Rahul"
	 */
	frappe.provide('frappe.user');
	frappe.user.first_name = function (user) { return frappe._.head(frappe.user.full_name(user).split(" ")); };

	frappe.provide('frappe.ui.keycode');
	frappe.ui.keycode = { RETURN: 13 };

	/**
	 * @description Frappe's Store Class
	 */
	 // frappe.stores  - A registry for frappe stores.
	frappe.provide('frappe.stores');
	frappe.stores = [ ];
	frappe.Store  = class
	{
		/**
		 * @description Frappe's Store Class's constructor.
		 *
		 * @param {string} name - Name of the logger.
		 */
		constructor (name) {
			if ( typeof name !== 'string' )
				{ throw new frappe.TypeError(("Expected string for name, got " + (typeof name) + " instead.")) }
			this.name = name;
		}

		/**
		 * @description Get instance of frappe.Store (return registered one if declared).
		 *
		 * @param {string} name - Name of the store.
		 */
		static get (name) {
			if ( !(name in frappe.stores) )
				{ frappe.stores[name] = new frappe.Store(name); }
			return frappe.stores[name]
		}

		set (key, value) { localStorage.setItem(((this.name) + ":" + key), value); }
		get (key, value) { return localStorage.getItem(((this.name) + ":" + key)) }
	};

	// frappe.loggers - A registry for frappe loggers.
	frappe.provide('frappe.loggers');
	/**
	 * @description Frappe's Logger Class
	 *
	 * @example
	 * frappe.log       = frappe.Logger.get('foobar')
	 * frappe.log.level = frappe.Logger.DEBUG
	 *
	 * frappe.log.info('foobar')
	 * // prints '[timestamp] foobar: foobar'
	 */
	frappe.Logger = class {
		/**
		 * @description Frappe's Logger Class's constructor.
		 *
		 * @param {string} name - Name of the logger.
		 */
		constructor (name, level) {
			if ( typeof name !== 'string' )
				{ throw new frappe.TypeError(("Expected string for name, got " + (typeof name) + " instead.")) }

			this.name   = name;
			this.level  = level;

			if ( !this.level ) {
				if ( frappe.boot.developer_mode )
					{ this.level = frappe.Logger.ERROR; }
				else
					{ this.level = frappe.Logger.NOTSET; }
			}
			this.format = frappe.Logger.FORMAT;
		}

		/**
		 * @description Get instance of frappe.Logger (return registered one if declared).
		 *
		 * @param {string} name - Name of the logger.
		 */
		static get (name, level) {
			if ( !(name in frappe.loggers) )
				{ frappe.loggers[name] = new frappe.Logger(name, level); }
			return frappe.loggers[name]
		}

		debug (message) { this.log(message, frappe.Logger.DEBUG); }
		info  (message) { this.log(message, frappe.Logger.INFO);  }
		warn  (message) { this.log(message, frappe.Logger.WARN);  }
		error (message) { this.log(message, frappe.Logger.ERROR); }

		log (message, level) {
			var timestamp   = frappe.datetime.now();

			if ( level.value <= this.level.value ) {
				var format  = frappe._.format(this.format, {
					time: timestamp.format('HH:mm:ss'),
					name: this.name
				});
				console.log(("%c " + format + ":"), ("color: " + (level.color)), message);
			}
		}
	};

	frappe.Logger.DEBUG  = { value: 10, color: '#616161', name: 'DEBUG'  };
	frappe.Logger.INFO   = { value: 20, color: '#2196F3', name: 'INFO'   };
	frappe.Logger.WARN   = { value: 30, color: '#FFC107', name: 'WARN'   };
	frappe.Logger.ERROR  = { value: 40, color: '#F44336', name: 'ERROR'  };
	frappe.Logger.NOTSET = { value:  0,                   name: 'NOTSET' };

	frappe.Logger.FORMAT = '{time} {name}';

	// frappe.chat
	frappe.provide('frappe.chat');

	frappe.log = frappe.Logger.get('frappe.chat', frappe.Logger.NOTSET);

	// frappe.chat.profile
	frappe.provide('frappe.chat.profile');

	/**
	 * @description Create a Chat Profile.
	 *
	 * @param   {string|array} fields - (Optional) fields to be retrieved after creating a Chat Profile.
	 * @param   {function}     fn     - (Optional) callback with the returned Chat Profile.
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.profile.create(console.log)
	 *
	 * frappe.chat.profile.create("status").then(console.log) // { status: "Online" }
	 */
	frappe.chat.profile.create = function (fields, fn) {
		if ( typeof fields === "function" ) {
			fn     = fields;
			fields = null;
		} else
		if ( typeof fields === "string" )
			{ fields = frappe._.as_array(fields); }

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_profile.chat_profile.create",
				{ user: frappe.session.user, exists_ok: true, fields: fields },
					function (response) {
						if ( fn )
							{ fn(response.message); }

						resolve(response.message);
					});
		})
	};

	/**
	 * @description Updates a Chat Profile.
	 *
	 * @param   {string} user   - (Optional) Chat Profile User, defaults to session user.
	 * @param   {object} update - (Required) Updates to be dispatched.
	 *
	 * @example
	 * frappe.chat.profile.update(frappe.session.user, { "status": "Offline" })
	 */
	frappe.chat.profile.update = function (user, update, fn) {
		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_profile.chat_profile.update",
				{ user: user || frappe.session.user, data: update },
					function (response) {
						if ( fn )
							{ fn(response.message); }

						resolve(response.message);
					});
		})
	};

	// frappe.chat.profile.on
	frappe.provide('frappe.chat.profile.on');

	/**
	 * @description Triggers on a Chat Profile update of a user (Only if there's a one-on-one conversation).
	 *
	 * @param   {function} fn - (Optional) callback with the User and the Chat Profile update.
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.profile.on.update(function (user, update)
	 * {
	 *      // do stuff
	 * })
	 */
	frappe.chat.profile.on.update = function (fn) {
		frappe.realtime.on("frappe.chat.profile:update", function (r) { return fn(r.user, r.data); });
	};
	frappe.chat.profile.STATUSES
	=
	[
		{
			name: "Online",
		   color: "green"
		},
		{
			 name: "Away",
			color: "yellow"
		},
		{
			 name: "Busy",
			color: "red"
		},
		{
			 name: "Offline",
			color: "darkgrey"
		}
	];

	// frappe.chat.room
	frappe.provide('frappe.chat.room');

	/**
	 * @description Creates a Chat Room.
	 *
	 * @param   {string}       kind  - (Required) "Direct", "Group" or "Visitor".
	 * @param   {string}       owner - (Optional) Chat Room owner (defaults to current user).
	 * @param   {string|array} users - (Required for "Direct" and "Visitor", Optional for "Group") User(s) within Chat Room.
	 * @param   {string}       name  - Chat Room name.
	 * @param   {function}     fn    - callback with created Chat Room.
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.room.create("Direct", frappe.session.user, "foo@bar.com", function (room) {
	 *      // do stuff
	 * })
	 * frappe.chat.room.create("Group",  frappe.session.user, ["santa@gmail.com", "banta@gmail.com"], "Santa and Banta", function (room) {
	 *      // do stuff
	 * })
	 */
	frappe.chat.room.create = function (kind, owner, users, name, fn) {
		if ( typeof name === "function" ) {
			fn   = name;
			name = null;
		}

		users    = frappe._.as_array(users);

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_room.chat_room.create",
				{ kind: kind, owner: owner || frappe.session.user, users: users, name: name },
				function (r) {
					var room = r.message;
					room     = Object.assign({}, room, {creation: new frappe.datetime.datetime(room.creation)});

					if ( fn )
						{ fn(room); }

					resolve(room);
				});
		})
	};

	/**
	 * @description Returns Chat Room(s).
	 *
	 * @param   {string|array} names   - (Optional) Chat Room(s) to retrieve.
	 * @param   {string|array} fields  - (Optional) fields to be retrieved for each Chat Room.
	 * @param   {function}     fn      - (Optional) callback with the returned Chat Room(s).
	 *
	 * @returns {Promise}
	 *
	 * @example
	 * frappe.chat.room.get(function (rooms) {
	 *      // do stuff
	 * })
	 * frappe.chat.room.get().then(function (rooms) {
	 *      // do stuff
	 * })
	 *
	 * frappe.chat.room.get(null, ["room_name", "avatar"], function (rooms) {
	 *      // do stuff
	 * })
	 *
	 * frappe.chat.room.get("CR00001", "room_name", function (room) {
	 *      // do stuff
	 * })
	 *
	 * frappe.chat.room.get(["CR00001", "CR00002"], ["room_name", "last_message"], function (rooms) {
	 *
	 * })
	 */
	frappe.chat.room.get = function (names, fields, fn) {
		if ( typeof names === "function" ) {
			fn     = names;
			names  = null;
			fields = null;
		}
		else
		if ( typeof names === "string" ) {
			names  = frappe._.as_array(names);

			if ( typeof fields === "function" ) {
				fn     = fields;
				fields = null;
			}
			else
			if ( typeof fields === "string" )
				{ fields = frappe._.as_array(fields); }
		}

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_room.chat_room.get",
				{ user: frappe.session.user, rooms: names, fields: fields },
					function (response) {
						var rooms = response.message;
						if ( rooms ) { // frappe.api BOGZ! (emtpy arrays are falsified, not good design).
							rooms = frappe._.as_array(rooms);
							rooms = rooms.map(function (room) {
								return Object.assign({}, room, {creation: new frappe.datetime.datetime(room.creation),
									last_message: room.last_message ? Object.assign({}, room.last_message,
										{creation: new frappe.datetime.datetime(room.last_message.creation)}) : null})
							});
							rooms = frappe._.squash(rooms);
						}
						else
							{ rooms = [ ]; }

						if ( fn )
							{ fn(rooms); }

						resolve(rooms);
					});
		})
	};

	/**
	 * @description Subscribe current user to said Chat Room(s).
	 *
	 * @param {string|array} rooms - Chat Room(s).
	 *
	 * @example
	 * frappe.chat.room.subscribe("CR00001")
	 */
	frappe.chat.room.subscribe = function (rooms) {
		frappe.realtime.publish("frappe.chat.room:subscribe", rooms);
	};

	/**
	 * @description Get Chat Room history.
	 *
	 * @param   {string} name - Chat Room name
	 *
	 * @returns {Promise}     - Chat Message(s)
	 *
	 * @example
	 * frappe.chat.room.history(function (messages)
	 * {
	 *      // do stuff.
	 * })
	 */
	frappe.chat.room.history = function (name, fn) {
		return new Promise(function (resolve) {
			frappe.call("frappe.chat.doctype.chat_room.chat_room.history",
				{ room: name, user: frappe.session.user },
					function (r) {
						var messages = r.message ? frappe._.as_array(r.message) : [ ]; // frappe.api BOGZ! (emtpy arrays are falsified, not good design).
						messages     = messages.map(function (m) {
							return Object.assign({}, m,
								{creation: new frappe.datetime.datetime(m.creation)})
						});

						if ( fn )
							{ fn(messages); }

						resolve(messages);
					});
		})
	};

	/**
	 * @description Searches Rooms based on a query.
	 *
	 * @param   {string} query - The query string.
	 * @param   {array}  rooms - A list of Chat Rooms.
	 *
	 * @returns {array}        - A fuzzy searched list of rooms.
	 */
	frappe.chat.room.search = function (query, rooms) {
		var dataset = rooms.map(function (r) {
			if ( r.room_name )
				{ return r.room_name }
			else
				if ( r.owner === frappe.session.user )
					{ return frappe.user.full_name(frappe._.squash(r.users)) }
				else
					{ return frappe.user.full_name(r.owner) }
		});
		var results = frappe._.fuzzy_search(query, dataset);
		rooms         = results.map(function (i) { return rooms[i]; });

		return rooms
	};

	/**
	 * @description Sort Chat Room(s) based on Last Message Timestamp or Creation Date.
	 *
	 * @param {array}   - A list of Chat Room(s)
	 * @param {compare} - (Optional) a comparision function.
	 */
	frappe.chat.room.sort = function (rooms, compare) {
		if ( compare === void 0 ) compare = null;

		compare = compare || function (a, b) {
			if ( a.last_message && b.last_message )
				{ return frappe.datetime.compare(a.last_message.creation, b.last_message.creation) }
			else
			if ( a.last_message )
				{ return frappe.datetime.compare(a.last_message.creation, b.creation) }
			else
			if ( b.last_message )
				{ return frappe.datetime.compare(a.creation, b.last_message.creation) }
			else
				{ return frappe.datetime.compare(a.creation, b.creation) }
		};
		rooms.sort(compare);

		return rooms
	};

	// frappe.chat.room.on
	frappe.provide('frappe.chat.room.on');

	/**
	 * @description Triggers on Chat Room updated.
	 *
	 * @param {function} fn - callback with the Chat Room and Update.
	 */
	frappe.chat.room.on.update = function (fn) {
		frappe.realtime.on("frappe.chat.room:update", function (r) {
			if ( r.data.last_message )
				// creation to frappe.datetime.datetime (easier to manipulate).
				{ r.data = Object.assign({}, r.data, {last_message: Object.assign({}, r.data.last_message, {creation: new frappe.datetime.datetime(r.data.last_message.creation)})}); }

			fn(r.room, r.data);
		});
	};

	/**
	 * @description Triggers on Chat Room created.
	 *
	 * @param {function} fn - callback with the created Chat Room.
	 */
	frappe.chat.room.on.create = function (fn) {
		frappe.realtime.on("frappe.chat.room:create", function (r) { return fn(Object.assign({}, r, {creation: new frappe.datetime.datetime(r.creation)})); }
		);
	};

	/**
	 * @description Triggers when a User is typing in a Chat Room.
	 *
	 * @param {function} fn - callback with the typing User within the Chat Room.
	 */
	frappe.chat.room.on.typing = function (fn) {
		frappe.realtime.on("frappe.chat.room:typing", function (r) { return fn(r.room, r.user); });
	};

	// frappe.chat.message
	frappe.provide('frappe.chat.message');

	frappe.chat.message.typing = function (room, user) {
		frappe.realtime.publish("frappe.chat.message:typing", { user: user || frappe.session.user, room: room });
	};

	frappe.chat.message.send   = function (room, message, type) {
		if ( type === void 0 ) type = "Content";

		frappe.call("frappe.chat.doctype.chat_message.chat_message.send",
			{ user: frappe.session.user, room: room, content: message, type: type });
	};

	frappe.chat.message.update = function (message, update, fn) {
		return new Promise(function (resolve) {
			frappe.call('frappe.chat.doctype.chat_message.chat_message.update',
				{ user: frappe.session.user, message: message, update: update },
				function (r) {
					if ( fn )
						{ fn(response.message); }

					resolve(response.message);
				});
		})
	};

	frappe.chat.message.sort   = function (messages) {
		if ( !frappe._.is_empty(messages) )
			{ messages.sort(function (a, b) { return frappe.datetime.compare(b.creation, a.creation); }); }

		return messages
	};

	/**
	 * @description Add user to seen (defaults to session.user)
	 */
	frappe.chat.message.seen   = function (mess, user) {
		frappe.call('frappe.chat.doctype.chat_message.chat_message.seen',
			{ message: mess, user: user || frappe.session.user });
	};

	frappe.provide('frappe.chat.message.on');
	frappe.chat.message.on.create = function (fn) {
		frappe.realtime.on("frappe.chat.message:create", function (r) { return fn(Object.assign({}, r, {creation: new frappe.datetime.datetime(r.creation)})); }
		);
	};

	frappe.chat.message.on.update = function (fn) {
		frappe.realtime.on("frappe.chat.message:update", function (r) { return fn(r.message, r.data); });
	};

	frappe.chat.pretty_datetime   = function (date) {
		var today    = moment();
		var instance = date.moment;

		if ( today.isSame(instance, "d") )
			{ return instance.format("hh:mm A") }
		else
		if ( today.isSame(instance, "week") )
			{ return instance.format("dddd") }
		else
			{ return instance.format("DD/MM/YYYY") }
	};

	// frappe.chat.sound
	frappe.provide('frappe.chat.sound');

	/**
	 * @description Plays a given registered sound.
	 *
	 * @param {value} - The name of the registered sound.
	 *
	 * @example
	 * frappe.chat.sound.play("message")
	 */
	frappe.chat.sound.play  = function (name, volume) {
		if ( volume === void 0 ) volume = 0.1;

		// frappe._.play_sound(`chat-${name}`)
		var $audio = $("<audio class=\"chat-audio\"/>");
		$audio.attr('volume', volume);

		if  ( frappe._.is_empty($audio) )
			{ $(document).append($audio); }

		if  ( !$audio.paused ) {
			frappe.log.info('Stopping sound playing.');
			$audio[0].pause();
			$audio.attr('currentTime', 0);
		}

		frappe.log.info('Playing sound.');
		$audio.attr('src', ((frappe.chat.sound.PATH) + "/chat-" + name + ".mp3"));
		$audio[0].play();
	};
	frappe.chat.sound.PATH  = '/assets/frappe/sounds';

	// frappe.chat.emoji
	frappe.chat.emojis = [ ];
	frappe.chat.emoji  = function (fn) {
		return new Promise(function (resolve) {
			if ( !frappe._.is_empty(frappe.chat.emojis) ) {
				if ( fn )
					{ fn(frappe.chat.emojis); }

				resolve(frappe.chat.emojis);
			}
			else
				{ $.get('https://cdn.rawgit.com/frappe/emoji/master/emoji', function (data) {
					frappe.chat.emojis = JSON.parse(data);

					if ( fn )
						{ fn(frappe.chat.emojis); }

					resolve(frappe.chat.emojis);
				}); }
		})
	};

	// Website Settings
	frappe.provide('frappe.chat.website.settings');
	frappe.chat.website.settings = function (fields, fn) {
		if ( typeof fields === "function" ) {
			fn     = fields;
			fields = null;
		} else
		if ( typeof fields === "string" )
			{ fields = frappe._.as_array(fields); }

		return new Promise(function (resolve) {
			frappe.call("frappe.chat.website.settings",
				{ fields: fields })
				.then(function (response) {
					var message = response.message;

					if ( message.enable_from )
						{ message   = Object.assign({}, message, {enable_from: new frappe.datetime.datetime(message.enable_from, 'HH:mm:ss')}); }
					if ( message.enable_to )
						{ message   = Object.assign({}, message, {enable_to:   new frappe.datetime.datetime(message.enable_to,   'HH:mm:ss')}); }

					if ( fn )
						{ fn(message); }

					resolve(message);
				});
		})
	};

	frappe.chat.website.token    = function (fn) {
		return new Promise(function (resolve) {
			frappe.call("frappe.chat.website.token")
				.then(function (response) {
					if ( fn )
						{ fn(response.message); }

					resolve(response.message);
				});
		})
	};

	var h = hyper_min.h;
	var Component = hyper_min.Component;

	// frappe.components
	// frappe's component namespace.
	frappe.provide('frappe.components');

	frappe.provide('frappe.chat.component');

	/**
	 * @description Button Component
	 *
	 * @prop {string}  type  - (Optional) "default", "primary", "info", "success", "warning", "danger" (defaults to "default")
	 * @prop {boolean} block - (Optional) Render a button block (defaults to false).
	 */
	frappe.components.Button
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var size      = frappe.components.Button.SIZE[props.size];

			return (
				h("button", Object.assign({}, props, {class: ("btn " + (size && size.class) + " btn-" + (props.type) + " " + (props.block ? "btn-block" : "") + " " + (props.class ? props.class : ""))}),
					props.children
				)
			)
		}
	};
	frappe.components.Button.SIZE
	=
	{
		small: {
			class: "btn-sm"
		},
		large: {
			class: "btn-lg"
		}
	};
	frappe.components.Button.defaultProps
	=
	{
		 type: "default",
		block: false
	};

	/**
	 * @description FAB Component
	 *
	 * @extends frappe.components.Button
	 */
	frappe.components.FAB
	=
	class extends frappe.components.Button {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var size      = frappe.components.FAB.SIZE[props.size];

			return (
				h(frappe.components.Button, Object.assign({}, props, {class: ((props.class) + " " + (size && size.class))}),
					h("i", { class: props.icon })
				)
			)
		}
	};
	frappe.components.FAB.defaultProps
	=
	{
		icon: "octicon octicon-plus"
	};
	frappe.components.FAB.SIZE
	=
	{
		small:
		{
			class: "frappe-fab-sm"
		},
		large:
		{
			class: "frappe-fab-lg"
		}
	};

	/**
	 * @description Octicon Component
	 *
	 * @prop color - (Required) color for the indicator
	 */
	frappe.components.Indicator
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return props.color ? h("span", Object.assign({}, props, {class: ("indicator " + (props.color))})) : null
		}
	};

	/**
	 * @description FontAwesome Component
	 */
	frappe.components.FontAwesome
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return props.type ? h("i", Object.assign({}, props, {class: ("fa " + (props.fixed ? "fa-fw" : "") + " fa-" + (props.type) + " " + (props.class))})) : null
		}
	};
	frappe.components.FontAwesome.defaultProps
	=
	{
		fixed: false
	};

	/**
	 * @description Octicon Component
	 *
	 * @extends frappe.Component
	 */
	frappe.components.Octicon
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return props.type ? h("i", Object.assign({}, props, {class: ("octicon octicon-" + (props.type))})) : null
		}
	};

	/**
	 * @description Avatar Component
	 *
	 * @prop {string} title - (Optional) title for the avatar.
	 * @prop {string} abbr  - (Optional) abbreviation for the avatar, defaults to the first letter of the title.
	 * @prop {string} size  - (Optional) size of the avatar to be displayed.
	 * @prop {image}  image - (Optional) image for the avatar, defaults to the first letter of the title.
	 */
	frappe.components.Avatar
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var abbr      = props.abbr || props.title.substr(0, 1);
			var size      = frappe.components.Avatar.SIZE[props.size] || frappe.components.Avatar.SIZE.medium;

			return (
				h("span", { class: ("avatar " + (size.class) + " " + (props.class ? props.class : "")) },
					props.image ?
						h("img", { class: "media-object", src: props.image })
						:
						h("div", { class: "standard-image" }, abbr)
				)
			)
		}
	};
	frappe.components.Avatar.SIZE
	=
	{
		small:
		{
			class: "avatar-small"
		},
		large:
		{
			class: "avatar-large"
		},
		medium:
		{
			class: "avatar-medium"
		}
	};

	/**
	 * @description Frappe Chat Object.
	 *
	 * @example
	 * const chat = new frappe.Chat(options) // appends to "body"
	 * chat.render()
	 * const chat = new frappe.Chat(".selector", options)
	 * chat.render()
	 *
	 * const chat = new frappe.Chat()
	 * chat.set_wrapper('.selector')
	 *     .set_options(options)
	 *     .render()
	 */
	frappe.Chat
	=
	class {
		/**
		 * @description Frappe Chat Object.
		 *
		 * @param {string} selector - A query selector, HTML Element or jQuery object.
		 * @param {object} options  - Optional configurations.
		 */
		constructor (selector, options) {
			if ( !(typeof selector === "string" || selector instanceof $ || selector instanceof HTMLElement) ) {
				options  = selector;
				selector = null;
			}

			this.options = frappe.Chat.OPTIONS;

			this.set_wrapper(selector ? selector : "body");
			this.set_options(options);

			// Load Emojis.
			frappe.chat.emoji();
		}

		/**
		 * Set the container on which the chat widget is mounted on.
		 * @param   {string|HTMLElement} selector - A query selector, HTML Element or jQuery object.
		 *
		 * @returns {frappe.Chat}                 - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.set_wrapper(".selector")
		 */
		set_wrapper (selector) {
			this.$wrapper = $(selector);

			return this
		}

		/**
		 * Set the configurations for the chat interface.
		 * @param   {object}      options - Optional Configurations.
		 *
		 * @returns {frappe.Chat}         - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.set_options({ layout: frappe.Chat.Layout.PAGE })
		 */
		set_options (options) {
			this.options = Object.assign({}, this.options, options);

			return this
		}

		/**
		 * @description Destory the chat widget.
		 *
		 * @returns {frappe.Chat} - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.render()
		 *     .destroy()
		 */
		destroy ( ) {
			var $wrapper = this.$wrapper;
			$wrapper.remove(".frappe-chat");

			return this
		}

		/**
		 * @description Render the chat widget component onto destined wrapper.
		 *
		 * @returns {frappe.Chat} - The instance.
		 *
		 * @example
		 * const chat = new frappe.Chat()
		 * chat.render()
		 */
		render (props) {
			if ( props === void 0 ) props = { };

			this.destroy();

			var $wrapper   = this.$wrapper;
			var options    = this.options;

			var component  = h(frappe.Chat.Widget, Object.assign({}, {layout: options.layout,
				target: options.target},
				props));

			hyper_min.render(component, $wrapper[0]);

			return this
		}
	};
	frappe.Chat.Layout
	=
	{
		PAGE: "page", POPPER: "popper"
	};
	frappe.Chat.OPTIONS
	=
	{
		layout: frappe.Chat.Layout.POPPER
	};

	/**
	 * @description The base Component for Frappe Chat
	 */
	frappe.Chat.Widget
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.setup(props);
			this.make();
		}

		setup (props) {
			var this$1 = this;

			// room actions
			this.room           = { };
			this.room.add       = function (rooms) {
				rooms           = frappe._.as_array(rooms);
				var names     = rooms.map(function (r) { return r.name; });

				frappe.log.info(("Subscribing " + (frappe.session.user) + " to Chat Rooms " + (names.join(", ")) + "."));
				frappe.chat.room.subscribe(names);

				var state     = [ ];

				for (var i = 0, list = rooms; i < list.length; i += 1)
					{
					var room = list[i];

					if ( ["Group", "Visitor"].includes(room.type) || room.owner === frappe.session.user || room.last_message ) {
						frappe.log.info(("Adding " + (room.name) + " to component."));
						state.push(room);
					}
				}

				this$1.set_state({ rooms: this$1.state.rooms.concat( state ) });
			};
			this.room.update    = function (room, update) {
				var ref = this$1;
				var state = ref.state;
				var   exists    = false;
				var rooms     = state.rooms.map(function (r) {
					if ( r.name === room ) {
						exists  = true;
						if ( update.typing ) {
							if ( !frappe._.is_empty(r.typing) ) {
								var usr = update.typing;
								if ( !r.typing.includes(usr) ) {
									update.typing = frappe._.copy_array(r.typing);
									update.typing.push(usr);
								}
							}
							else
								{ update.typing = frappe._.as_array(update.typing); }
						}

						return Object.assign({}, r, update)
					}

					return r
				});

				if ( frappe.session.user !== 'Guest' ) {
					if ( !exists )
						{ frappe.chat.room.get(room, function (room) { return this$1.room.add(room); }); }
					else
						{ this$1.set_state({ rooms: rooms }); }
				}

				if ( state.room.name === room ) {
					if ( update.typing ) {
						if ( !frappe._.is_empty(state.room.typing) ) {
							var usr = update.typing;
							if ( !state.room.typing.includes(usr) ) {
								update.typing = frappe._.copy_array(state.room.typing);
								update.typing.push(usr);
							}
						} else
							{ update.typing = frappe._.as_array(update.typing); }
					}

					var room$1  = Object.assign({}, state.room, update);

					this$1.set_state({ room: room$1 });
				}
			};
			this.room.select    = function (name) {
				frappe.chat.room.history(name, function (messages) {
					var ref = this$1;
					var state = ref.state;
					var room       = state.rooms.find(function (r) { return r.name === name; });

					this$1.set_state({
						room: Object.assign({}, state.room, room, {messages: messages})
					});
				});
			};

			this.state = Object.assign({}, frappe.Chat.Widget.defaultState, props);
		}

		make ( ) {
			var this$1 = this;

			if ( frappe.session.user !== 'Guest' ) {
				frappe.chat.profile.create([
					"status", "message_preview", "notification_tones", "conversation_tones"
				]).then(function (profile) {
					this$1.set_state({ profile: profile });

					frappe.chat.room.get(function (rooms) {
						rooms = frappe._.as_array(rooms);
						frappe.log.info(("User " + (frappe.session.user) + " is subscribed to " + (rooms.length) + " " + (frappe._.pluralize('room', rooms.length)) + "."));

						if ( !frappe._.is_empty(rooms) )
							{ this$1.room.add(rooms); }
					});

					this$1.bind();
				});
			} else {
				this.bind();
			}
		}

		bind ( ) {
			var this$1 = this;

			frappe.chat.profile.on.update(function (user, update) {
				frappe.log.warn(("TRIGGER: Chat Profile update " + (JSON.stringify(update)) + " of User " + user + "."));

				if ( 'status' in update ) {
					if ( user === frappe.session.user ) {
						this$1.set_state({
							profile: Object.assign({}, this$1.state.profile, {status: update.status})
						});
					} else {
						var status = frappe.chat.profile.STATUSES.find(function (s) { return s.name === update.status; });
						var color  = status.color;

						var alert  = "<span class=\"indicator " + color + "\"/> " + (frappe.user.full_name(user)) + " is currently <b>" + (update.status) + "</b>";
						frappe.show_alert(alert, 3);
					}
				}
			});

			frappe.chat.room.on.create(function (room) {
				frappe.log.warn(("TRIGGER: Chat Room " + (room.name) + " created."));
				this$1.room.add(room);
			});

			frappe.chat.room.on.update(function (room, update) {
				frappe.log.warn(("TRIGGER: Chat Room " + room + " update " + (JSON.stringify(update)) + " recieved."));
				this$1.room.update(room, update);
			});

			frappe.chat.room.on.typing(function (room, user) {
				if ( user !== frappe.session.user ) {
					frappe.log.warn(("User " + user + " typing in Chat Room " + room + "."));
					this$1.room.update(room, { typing: user });

					setTimeout(function () { return this$1.room.update(room, { typing: null }); }, 5000);
				}
			});

			frappe.chat.message.on.create(function (r) {
				var ref = this$1;
				var state = ref.state;

				// play sound.
				if ( state.room.name )
					{ state.profile.conversation_tones && frappe.chat.sound.play('message'); }
				else
					{ state.profile.notification_tones && frappe.chat.sound.play('notification'); }

				if ( r.user !== frappe.session.user && state.profile.message_preview && !state.toggle ) {
					var $element = $('body').find('.frappe-chat-alert');
					$element.remove();

					var  alert   = // TODO: ellipses content
					"\n\t\t\t\t<span data-action=\"show-message\" class=\"cursor-pointer\">\n\t\t\t\t\t<span class=\"indicator yellow\"/> <b>" + (frappe.user.first_name(r.user)) + "</b>: " + (r.content) + "\n\t\t\t\t</span>\n\t\t\t\t";
					frappe.show_alert(alert, 3, {
						"show-message": function (r) {
							this.room.select(r.room);
							this.base.firstChild._component.toggle();
						}.bind(this$1, r)
					});
				}

				if ( r.room === state.room.name ) {
					var mess  = frappe._.copy_array(state.room.messages);
					mess.push(r);

					this$1.set_state({ room: Object.assign({}, state.room, {messages: mess}) });
				}
			});

			frappe.chat.message.on.update(function (message, update) {
				frappe.log.warn(("TRIGGER: Chat Message " + message + " update " + (JSON.stringify(update)) + " recieved."));
			});
		}

		render ( ) {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var me               = this;

			var ActionBar        = h(frappe.Chat.Widget.ActionBar, {
				placeholder: __("Search or Create a New Chat"),
					  class: "level",
					 layout: props.layout,
					actions:
				frappe._.compact([
					{
						  label: __("New"),
						onclick: function ( ) {
							var dialog = new frappe.ui.Dialog({
								  title: __("New Chat"),
								 fields: [
									 {
											 label: __("Chat Type"),
										 fieldname: "type",
										 fieldtype: "Select",
										   options: ["Group", "Direct Chat"],
										   default: "Group",
										  onchange: function () {
												var type     = dialog.get_value("type");
												var is_group = type === "Group";

												dialog.set_df_property("group_name", "reqd",  is_group);
												dialog.set_df_property("user",       "reqd", !is_group);
										  }
									 },
									 {
											 label: __("Group Name"),
										 fieldname: "group_name",
										 fieldtype: "Data",
											  reqd: true,
										depends_on: "eval:doc.type == 'Group'"
									 },
									 {
											 label: __("Users"),
										 fieldname: "users",
										 fieldtype: "MultiSelect",
										   options: frappe.user.get_emails(),
										depends_on: "eval:doc.type == 'Group'"
									 },
									 {
											 label: __("User"),
										 fieldname: "user",
										 fieldtype: "Link",
										   options: "User",
										depends_on: "eval:doc.type == 'Direct Chat'"
									 }
								 ],
								action: {
									primary: {
										   label: __('Create'),
										onsubmit: function (values) {
											if ( values.type === "Group" ) {
												if ( !frappe._.is_empty(values.users) ) {
													var name  = values.group_name;
													var users = dialog.fields_dict.users.get_values();

													frappe.chat.room.create("Group",  null, users, name);
												}
											} else {
												var user      = values.user;

												frappe.chat.room.create("Direct", null, user);
											}
											dialog.hide();
										}
									}
								}
							});
							dialog.show();
						}
					},
					frappe._.is_mobile() && {
						   icon: "octicon octicon-x",
						   class: "frappe-chat-close",
						onclick: function () { return this$1.set_state({ toggle: false }); }
					}
				], Boolean),
				change: function (query) { me.set_state({ query: query }); },
				  span: function (span)  { me.set_state({ span: span  }); },
			});

			var   contacts   = [ ];
			if ( 'user_info' in frappe.boot ) {
				var emails = frappe.user.get_emails();
				for (var i$1 = 0, list$1 = emails; i$1 < list$1.length; i$1 += 1) {
					var email = list$1[i$1];

					var exists = false;

					for (var i = 0, list = state.rooms; i < list.length; i += 1) {
						var room = list[i];

						if ( room.type === 'Direct' ) {
							if ( room.owner === email || frappe._.squash(room.users) === email )
								{ exists = true; }
						}
					}

					if ( !exists )
						{ contacts.push({ owner: frappe.session.user, users: [email] }); }
				}
			}
			var rooms      = state.query ? frappe.chat.room.search(state.query, state.rooms.concat(contacts)) : frappe.chat.room.sort(state.rooms);

			var layout     = state.span  ? frappe.Chat.Layout.PAGE : frappe.Chat.Layout.POPPER;

			var RoomList   = frappe._.is_empty(rooms) && !state.query ?
				h("div", { class: "vcenter" },
					h("div", { class: "text-center text-extra-muted" },
						h("p","",__("You don't have any messages yet."))
					)
				)
				:
				h(frappe.Chat.Widget.RoomList, { rooms: rooms, click: function (room) {
					if ( room.name )
						{ this$1.room.select(room.name); }
					else
						{ frappe.chat.room.create("Direct", room.owner, frappe._.squash(room.users), function (ref) {
							var name = ref.name;

							return this$1.room.select(name);
					}); }
				}});
			var Room       = h(frappe.Chat.Widget.Room, Object.assign({}, state.room, {layout: layout, destroy: function () {
				this$1.set_state({
					room: { name: null, messages: [ ] }
				});
			}}));

			var component  = layout === frappe.Chat.Layout.POPPER ?
				h(frappe.Chat.Widget.Popper, { heading: ActionBar, page: state.room.name && Room, target: props.target,
					toggle: function (t) { return this$1.set_state({ toggle: t }); } },
					RoomList
				)
				:
				h("div", { class: "frappe-chat-popper" },
					h("div", { class: "frappe-chat-popper-collapse" },
						h("div", { class: "panel panel-default panel-span", style: { width: "25%" } },
							h("div", { class: "panel-heading" },
								ActionBar
							),
							RoomList
						),
						Room
					)
				);

			return (
				h("div", { class: "frappe-chat" },
					component
				)
			)
		}
	};
	frappe.Chat.Widget.defaultState =  {
		  query: "",
		profile: { },
		  rooms: [ ],
		   room: { name: null, messages: [ ], typing: [ ] },
		 toggle: false,
		   span: false
	};
	frappe.Chat.Widget.defaultProps = {
		layout: frappe.Chat.Layout.POPPER
	};

	/**
	 * @description Chat Widget Popper HOC.
	 */
	frappe.Chat.Widget.Popper
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.setup(props);
		}

		setup (props) {
			var this$1 = this;

			this.toggle = this.toggle.bind(this);

			this.state  = frappe.Chat.Widget.Popper.defaultState;

			if ( props.target )
				{ $(props.target).click(function () { return this$1.toggle(); }); }

			frappe.chat.widget = this;
		}

		toggle  (active) {
			var toggle;
			if ( arguments.length === 1 )
				{ toggle = active; }
			else
				{ toggle = this.state.active ? false : true; }

			this.set_state({ active: toggle });

			this.props.toggle(toggle);
		}

		on_mounted ( ) {
			var this$1 = this;

			$(document.body).on('click', '.page-container, .frappe-chat-close', function (ref) {
				var currentTarget = ref.currentTarget;

				this$1.toggle(false);
			});
		}

		render  ( )  {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			return !state.destroy ?
			(
				h("div", { class: "frappe-chat-popper", style: !props.target ? { "margin-bottom": "80px" } : null },
					!props.target ?
						h(frappe.components.FAB, {
							  class: "frappe-fab",
							   icon: state.active ? "fa fa-fw fa-times" : "font-heavy octicon octicon-comment",
							   size: frappe._.is_mobile() ? null : "large",
							   type: "primary",
							onclick: function () { return this$1.toggle(); },
						}) : null,
					state.active ?
						h("div", { class: "frappe-chat-popper-collapse" },
							props.page ? props.page : (
								h("div", { class: ("panel panel-default " + (frappe._.is_mobile() ? "panel-span" : "")) },
									h("div", { class: "panel-heading" },
										props.heading
									),
									props.children
								)
							)
					) : null
				)
			) : null
		}
	};
	frappe.Chat.Widget.Popper.defaultState
	=
	{
		 active: false,
		destroy: false
	};

	/**
	 * @description frappe.Chat.Widget ActionBar Component
	 */
	frappe.Chat.Widget.ActionBar
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.change = this.change.bind(this);
			this.submit = this.submit.bind(this);

			this.state  = frappe.Chat.Widget.ActionBar.defaultState;
		}

		change (e) {
			var obj;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			this.set_state(( obj = {}, obj[e.target.name] = e.target.value, obj ));

			props.change(state.query);
		}

		submit (e) {
			var ref = this;
			var props = ref.props;
			var state = ref.state;

			e.preventDefault();

			props.submit(state.query);
		}

		render ( ) {
			var me               = this;
			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var actions = props.actions;

			return (
				h("div", { class: ("frappe-chat-action-bar " + (props.class ? props.class : "")) },
					h("form", { oninput: this.change, onsubmit: this.submit },
						h("input", { autocomplete: "off", class: "form-control input-sm", name: "query", value: state.query, placeholder: props.placeholder || "Search" })
					),
					!frappe._.is_empty(actions) ?
						actions.map(function (action) { return h(frappe.Chat.Widget.ActionBar.Action, Object.assign({}, action)); }) : null,
					!frappe._.is_mobile() ?
						h(frappe.Chat.Widget.ActionBar.Action, {
							icon: ("octicon octicon-screen-" + (state.span ? "normal" : "full")),
							onclick: function () {
								var span = !state.span;
								me.set_state({ span: span });
								props.span(span);
							}
						})
						:
						null
				)
			)
		}
	};
	frappe.Chat.Widget.ActionBar.defaultState
	=
	{
		query: null,
		 span: false
	};

	/**
	 * @description frappe.Chat.Widget ActionBar's Action Component.
	 */
	frappe.Chat.Widget.ActionBar.Action
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return (
				h(frappe.components.Button, Object.assign({}, {size: "small", class: "btn-action"}, props),
					props.icon ? h("i", { class: props.icon }) : null,
					("" + (props.icon ? " " : "") + (props.label ? props.label : ""))
				)
			)
		}
	};

	/**
	 * @description frappe.Chat.Widget RoomList Component
	 */
	frappe.Chat.Widget.RoomList
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var rooms     = props.rooms;

			return !frappe._.is_empty(rooms) ? (
				h("ul", { class: "frappe-chat-room-list nav nav-pills nav-stacked" },
					rooms.map(function (room) { return h(frappe.Chat.Widget.RoomList.Item, Object.assign({}, room, {click: props.click})); })
				)
			) : null
		}
	};

	/**
	 * @description frappe.Chat.Widget RoomList's Item Component
	 */
	frappe.Chat.Widget.RoomList.Item
	=
	class extends Component {
		render ( ) {
			var ref    = this;
			var props = ref.props;
			var item         = { };

			if ( props.type === "Group" ) {
				item.title     = props.room_name;
				item.image     = props.avatar;

				if ( !frappe._.is_empty(props.typing) ) {
					props.typing  = frappe._.as_array(props.typing); // HACK: (BUG) why does typing return a string?
					var names   = props.typing.map(function (user) { return frappe.user.first_name(user); });
					item.subtitle = (names.join(", ")) + " typing...";
				} else
				if ( props.last_message ) {
					var message = props.last_message;
					var content = message.content;

					if ( message.type === "File" ) {
						item.subtitle = " " + (content.name);
					} else {
						item.subtitle = props.last_message.content;
					}
				}
			} else {
				var user     = props.owner === frappe.session.user ? frappe._.squash(props.users) : props.owner;

				item.title     = frappe.user.full_name(user);
				item.image     = frappe.user.image(user);
				item.abbr      = frappe.user.abbr(user);

				if ( !frappe._.is_empty(props.typing) )
					{ item.subtitle = 'typing...'; }
				else
				if ( props.last_message ) {
					var message$1 = props.last_message;
					var content$1 = message$1.content;

					if ( message$1.type === "File" ) {
						item.subtitle = " " + (content$1.name);
					} else {
						item.subtitle = props.last_message.content;
					}
				}
			}

			var is_unread = false;
			if ( props.last_message ) {
				item.timestamp = frappe.chat.pretty_datetime(props.last_message.creation);
				is_unread = !props.last_message.seen.includes(frappe.session.user);
			}

			return (
				h("li", null,
					h("a", { class: props.active ? "active": "", onclick: function () {
						if (props.last_message) {
							frappe.chat.message.seen(props.last_message.name);
						}
						props.click(props);
					} },
						h("div", { class: "row" },
							h("div", { class: "col-xs-9" },
								h(frappe.Chat.Widget.MediaProfile, Object.assign({}, item))
							),
							h("div", { class: "col-xs-3 text-right" },
								[
									h("div", { class: "text-muted", style: { "font-size": "9px" } }, item.timestamp),
									is_unread ? h("span", { class: "indicator red" }) : null
								]
							)
						)
					)
				)
			)
		}
	};

	/**
	 * @description frappe.Chat.Widget's MediProfile Component.
	 */
	frappe.Chat.Widget.MediaProfile
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var position  = frappe.Chat.Widget.MediaProfile.POSITION[props.position || "left"];
			var avatar    = (
				h("div", { class: ((position.class) + " media-middle") },
					h(frappe.components.Avatar, Object.assign({}, props,
						{title: props.title,
						image: props.image,
						 size: props.size,
						 abbr: props.abbr}))
				)
			);

			return (
				h("div", { class: "media", style: position.class === "media-right" ? { "text-align": "right" } : null },
					position.class === "media-left"  ? avatar : null,
					h("div", { class: "media-body" },
						h("div", { class: "media-heading ellipsis small", style: ("max-width: " + (props.width_title || "100%") + " display: inline-block") }, props.title),
						props.content  ? h("div","",h("small","",props.content))  : null,
						props.subtitle ? h("div",{ class: "media-subtitle small" },h("small", { class: "text-muted" }, props.subtitle)) : null
					),
					position.class === "media-right" ? avatar : null
				)
			)
		}
	};
	frappe.Chat.Widget.MediaProfile.POSITION
	=
	{
		left: { class: "media-left" }, right: { class: "media-right" }
	};

	/**
	 * @description frappe.Chat.Widget Room Component
	 */
	frappe.Chat.Widget.Room
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var hints            =
			[
				{
					 match: /@(\w*)$/,
					search: function (keyword, callback) {
						if ( props.type === 'Group' ) {
							var query = keyword.slice(1);
							var users = [].concat(frappe._.as_array(props.owner), props.users);
							var grep  = users.filter(function (user) { return user !== frappe.session.user && user.indexOf(query) === 0; });

							callback(grep);
						}
					},
					component: function (item) {
						return (
							h(frappe.Chat.Widget.MediaProfile, {
								title: frappe.user.full_name(item),
								image: frappe.user.image(item),
								 size: "small"
							})
						)
					}
				},
				{
					match: /:([a-z]*)$/,
				   search: function (keyword, callback) {
						frappe.chat.emoji(function (emojis) {
							var query = keyword.slice(1);
							var items = [ ];
							for (var i$1 = 0, list$1 = emojis; i$1 < list$1.length; i$1 += 1)
								{
								var emoji = list$1[i$1];

								for (var i = 0, list = emoji.aliases; i < list.length; i += 1)
									{
										var alias = list[i];

										if ( alias.indexOf(query) === 0 )
										{ items.push({ name: alias, value: emoji.emoji });
									}
							} }

							callback(items);
						});
				   },
					 content: function (item) { return item.value; },
				   component: function (item) {
						return (
							h(frappe.Chat.Widget.MediaProfile, {
								title: item.name,
								 abbr: item.value,
								 size: "small"
							})
						)
				   }
			   }
			];

			var actions = frappe._.compact([
				!frappe._.is_mobile() && {
					 icon: "camera",
					label: "Camera",
					onclick: function ( ) {
						var capture = new frappe.ui.Capture({
							animate: false,
							  error: true
						});
						capture.show();

						capture.submit(function (data_url) {
							// data_url
						});
					}
				},
				{
					 icon: "file",
					label: "File",
					onclick: function ( ) {
						new frappe.ui.FileUploader({
							doctype: "Chat Room",
							docname: props.name,
							on_success: function on_success(file_doc) {
								var file_url = file_doc.file_url;
								var filename = file_doc.filename;
								frappe.chat.message.send(props.name, { path: file_url, name: filename }, "File");
							}
						});
					}
				}
			]);

			if ( frappe.session.user !== 'Guest' ) {
				if (props.messages) {
					props.messages = frappe._.as_array(props.messages);
					for (var i = 0, list = props.messages; i < list.length; i += 1)
						{
						var message = list[i];

						if ( !message.seen.includes(frappe.session.user) )
							{ frappe.chat.message.seen(message.name); }
						else
							{ break
					} }
				}
			}

			return (
				h("div", { class: ("panel panel-default\n\t\t\t\t" + (props.name ? "panel-bg" : "") + "\n\t\t\t\t" + (props.layout === frappe.Chat.Layout.PAGE || frappe._.is_mobile() ? "panel-span" : "")),
					style: props.layout === frappe.Chat.Layout.PAGE && { width: "75%", left: "25%", "box-shadow": "none" } },
					props.name && h(frappe.Chat.Widget.Room.Header, Object.assign({}, props, {on_back: props.destroy})),
					props.name ?
						!frappe._.is_empty(props.messages) ?
							h(frappe.chat.component.ChatList, {
								messages: props.messages
							})
							:
							h("div", { class: "panel-body", style: { "height": "100%" } },
								h("div", { class: "vcenter" },
									h("div", { class: "text-center text-extra-muted" },
										h(frappe.components.Octicon, { type: "comment-discussion", style: "font-size: 48px" }),
										h("p","",__("Start a conversation."))
									)
								)
							)
						:
						h("div", { class: "panel-body", style: { "height": "100%" } },
							h("div", { class: "vcenter" },
								h("div", { class: "text-center text-extra-muted" },
									h(frappe.components.Octicon, { type: "comment-discussion", style: "font-size: 125px" }),
									h("p","",__("Select a chat to start messaging."))
								)
							)
						),
					props.name ?
						h("div", { class: "chat-room-footer" },
							h(frappe.chat.component.ChatForm, { actions: actions,
								onchange: function () {
									frappe.chat.message.typing(props.name);
								},
								onsubmit: function (message) {
									frappe.chat.message.send(props.name, message);
								},
								hint: hints
							})
						)
						:
						null
				)
			)
		}
	};

	frappe.Chat.Widget.Room.Header
	=
	class extends Component {
		render ( ) {
			var ref     = this;
			var props = ref.props;

			var item          = { };

			if ( ["Group", "Visitor"].includes(props.type) ) {
				item.route      = "Form/Chat Room/" + (props.name);

				item.title      = props.room_name;
				item.image      = props.avatar;

				if ( !frappe._.is_empty(props.typing) ) {
					props.typing  = frappe._.as_array(props.typing); // HACK: (BUG) why does typing return as a string?
					var users   = props.typing.map(function (user) { return frappe.user.first_name(user); });
					item.subtitle = (users.join(", ")) + " typing...";
				} else
					{ item.subtitle = props.type === "Group" ?
						__(((props.users.length) + " " + (frappe._.pluralize('member', props.users.length))))
						:
						""; }
			}
			else {
				var user      = props.owner === frappe.session.user ? frappe._.squash(props.users) : props.owner;

				item.route      = "Form/User/" + user;

				item.title      = frappe.user.full_name(user);
				item.image      = frappe.user.image(user);

				if ( !frappe._.is_empty(props.typing) )
					{ item.subtitle = 'typing...'; }
			}

			var popper        = props.layout === frappe.Chat.Layout.POPPER || frappe._.is_mobile();

			return (
				h("div", { class: "panel-heading", style: { "height": "50px" } }, // sorry. :(
					h("div", { class: "level" },
						popper && frappe.session.user !== "Guest" ?
							h(frappe.components.Button,{class:"btn-back",onclick:props.on_back},
								h(frappe.components.Octicon, { type: "chevron-left" })
							) : null,
						h("div","",
							h("div", { class: "panel-title" },
								h("div", { class: "cursor-pointer", onclick: function () { frappe.set_route(item.route); }},
									h(frappe.Chat.Widget.MediaProfile, Object.assign({}, item))
								)
							)
						),
						h("div", { class: popper ? "col-xs-1"  : "col-xs-3" },
							h("div", { class: "text-right" }

							)
						)
					)
				)
			)
		}
	};

	/**
	 * @description ChatList Component
	 *
	 * @prop {array} messages - ChatMessage(s)
	 */
	frappe.chat.component.ChatList
	=
	class extends Component {
		on_mounted ( ) {
			this.$element  = $('.frappe-chat').find('.chat-list');
			this.$element.scrollTop(this.$element[0].scrollHeight);
		}

		on_updated ( ) {
			this.$element.scrollTop(this.$element[0].scrollHeight);
		}

		render ( ) {
			var messages = [ ];
			for (var i   = 0 ; i < this.props.messages.length ; ++i) {
				var   message   = this.props.messages[i];
				var me        = message.user === frappe.session.user;

				if ( i === 0 || !frappe.datetime.equal(message.creation, this.props.messages[i - 1].creation, 'day') )
					{ messages.push({ type: "Notification", content: message.creation.format('MMMM DD') }); }

				messages.push(message);
			}

			return (
				h("div",{class:"chat-list list-group"},
					!frappe._.is_empty(messages) ?
						messages.map(function (m) { return h(frappe.chat.component.ChatList.Item, Object.assign({}, m)); }) : null
				)
			)
		}
	};

	/**
	 * @description ChatList.Item Component
	 *
	 * @prop {string} name       - ChatMessage name
	 * @prop {string} user       - ChatMessage user
	 * @prop {string} room       - ChatMessage room
	 * @prop {string} room_type  - ChatMessage room_type ("Direct", "Group" or "Visitor")
	 * @prop {string} content    - ChatMessage content
	 * @prop {frappe.datetime.datetime} creation - ChatMessage creation
	 *
	 * @prop {boolean} groupable - Whether the ChatMessage is groupable.
	 */
	frappe.chat.component.ChatList.Item
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			var me        = props.user === frappe.session.user;
			var content   = props.content;

			return (
				h("div",{class: "chat-list-item list-group-item"},
					props.type === "Notification" ?
						h("div",{class:"chat-list-notification"},
							h("div",{class:"chat-list-notification-content"},
								content
							)
						)
						:
						h("div",{class:("" + (me ? "text-right" : ""))},
							props.room_type === "Group" && !me ?
								h(frappe.components.Avatar, {
									title: frappe.user.full_name(props.user),
									image: frappe.user.image(props.user)
								}) : null,
							h(frappe.chat.component.ChatBubble, props)
						)
				)
			)
		}
	};

	/**
	 * @description ChatBubble Component
	 *
	 * @prop {string} name       - ChatMessage name
	 * @prop {string} user       - ChatMessage user
	 * @prop {string} room       - ChatMessage room
	 * @prop {string} room_type  - ChatMessage room_type ("Direct", "Group" or "Visitor")
	 * @prop {string} content    - ChatMessage content
	 * @prop {frappe.datetime.datetime} creation - ChatMessage creation
	 *
	 * @prop {boolean} groupable - Whether the ChatMessage is groupable.
	 */
	frappe.chat.component.ChatBubble
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.onclick = this.onclick.bind(this);
		}

		onclick ( ) {
			var ref = this;
			var props = ref.props;
			if ( props.user === frappe.session.user ) {
				frappe.quick_edit("Chat Message", props.name, function (values) {

				});
			}
		}

		render  ( ) {
			var ref = this;
			var props = ref.props;
			var creation 	= props.creation.format('hh:mm A');

			var me        = props.user === frappe.session.user;
			var read      = !frappe._.is_empty(props.seen) && !props.seen.includes(frappe.session.user);

			var content   = props.content;

			return (
				h("div",{class:("chat-bubble " + (props.groupable ? "chat-groupable" : "") + " chat-bubble-" + (me ? "r" : "l")),
					onclick: this.onclick},
					props.room_type === "Group" && !me?
						h("div",{class:"chat-bubble-author"},
							h("a", { onclick: function () { frappe.set_route(("Form/User/" + (props.user))); } },
								frappe.user.full_name(props.user)
							)
						) : null,
					h("div",{class:"chat-bubble-content"},
							h("small","",
								props.type === "File" ?
									h("a", { class: "no-decoration", href: content.path, target: "_blank" },
										h(frappe.components.FontAwesome, { type: "file", fixed: true }), (" " + (content.name))
									)
									:
									content
							)
					),
					h("div",{class:"chat-bubble-meta"},
						h("span",{class:"chat-bubble-creation"},creation),
						me && read ?
							h("span",{class:"chat-bubble-check"},
								h(frappe.components.Octicon,{type:"check"})
							) : null
					)
				)
			)
		}
	};

	/**
	 * @description ChatForm Component
	 */
	frappe.chat.component.ChatForm
	=
	class extends Component {
		constructor (props) {
			super (props);

			this.onchange   = this.onchange.bind(this);
			this.onsubmit   = this.onsubmit.bind(this);

			this.hint        = this.hint.bind(this);

			this.state       = frappe.chat.component.ChatForm.defaultState;
		}

		onchange (e) {
			var obj;

			var ref = this;
			var props = ref.props;
			var state = ref.state;
			var value            = e.target.value;

			this.set_state(( obj = {}, obj[e.target.name] = value, obj ));

			props.onchange(state);

			this.hint(value);
		}

		hint (value) {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			if ( props.hint ) {
				var tokens =  value.split(" ");
				var sliced = tokens.slice(0, tokens.length - 1);

				var token  = tokens[tokens.length - 1];

				if ( token ) {
					props.hint   = frappe._.as_array(props.hint);
					var hint   = props.hint.find(function (hint) { return hint.match.test(token); });

					if ( hint ) {
						hint.search(token, function (items) {
							var hints = items.map(function (item) {
								// You should stop writing one-liners! >_>
								var replace = token.replace(hint.match, hint.content ? hint.content(item) : item);
								var content = ((sliced.join(" ")) + " " + replace).trim();
								item          = { component: hint.component(item), content: content };

								return item
							}).slice(0, hint.max || 5);

							this$1.set_state({ hints: hints });
						});
					}
					else
						{ this.set_state({ hints: [ ] }); }
				} else
					{ this.set_state({ hints: [ ] }); }
			}
		}

		onsubmit (e) {
			e.preventDefault();

			if ( this.state.content ) {
				this.props.onsubmit(this.state.content);

				this.set_state({ content: null });
			}
		}

		render ( ) {
			var this$1 = this;

			var ref = this;
			var props = ref.props;
			var state = ref.state;

			return (
				h("div",{class:"chat-form"},
					state.hints.length ?
						h("ul", { class: "hint-list list-group" },
							state.hints.map(function (item) {
								return (
									h("li", { class: "hint-list-item list-group-item" },
										h("a", { href: "javascript:void(0)", onclick: function () {
											this$1.set_state({ content: item.content, hints: [ ] });
										}},
											item.component
										)
									)
								)
							})
						) : null,
					h("form", { oninput: this.onchange, onsubmit: this.onsubmit },
						h("div",{class:"input-group input-group-lg"},
							!frappe._.is_empty(props.actions) ?
								h("div",{class:"input-group-btn dropup"},
									h(frappe.components.Button,{ class: "dropdown-toggle", "data-toggle": "dropdown"},
										h(frappe.components.FontAwesome, { class: "text-muted", type: "paperclip", fixed: true })
									),
									h("div",{ class:"dropdown-menu dropdown-menu-left", onclick: function (e) { return e.stopPropagation(); } },
										!frappe._.is_empty(props.actions) && props.actions.map(function (action) {
											return (
												h("li", null,
													h("a",{onclick:action.onclick},
														h(frappe.components.FontAwesome,{type:action.icon,fixed:true}), (" " + (action.label))
													)
												)
											)
										})
									)
								) : null,
							h("textarea", {
										class: "form-control",
										 name: "content",
										value: state.content,
								  placeholder: "Type a message",
									autofocus: true,
								   onkeypress: function (e) {
										if ( e.which === frappe.ui.keycode.RETURN && !e.shiftKey )
											{ this$1.onsubmit(e); }
								   }
							}),
							h("div",{class:"input-group-btn"},
								h(frappe.components.Button, { onclick: this.onsubmit },
									h(frappe.components.FontAwesome, { class: !frappe._.is_empty(state.content) ? "text-primary" : "text-muted", type: "send", fixed: true })
								)
							)
						)
					)
				)
			)
		}
	};
	frappe.chat.component.ChatForm.defaultState
	=
	{
		content: null,
		  hints: [ ],
	};

	/**
	 * @description EmojiPicker Component
	 *
	 * @todo Under Development
	 */
	frappe.chat.component.EmojiPicker
	=
	class extends Component  {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return (
				h("div", { class: ("frappe-chat-emoji dropup " + (props.class)) },
					h(frappe.components.Button, { type: "primary", class: "dropdown-toggle", "data-toggle": "dropdown" },
						h(frappe.components.FontAwesome, { type: "smile-o", fixed: true })
					),
					h("div", { class: "dropdown-menu dropdown-menu-right", onclick: function (e) { return e.stopPropagation(); } },
						h("div", { class: "panel panel-default" },
							h(frappe.chat.component.EmojiPicker.List)
						)
					)
				)
			)
		}
	};
	frappe.chat.component.EmojiPicker.List
	=
	class extends Component {
		render ( ) {
			var ref = this;
			var props = ref.props;

			return (
				h("div", { class: "list-group" }

				)
			)
		}
	};

	/**
	 * @description Python equivalent to sys.platform
	 */
	frappe.provide('frappe._');
	frappe._.platform   = function () {
		var string    = navigator.appVersion;

		if ( string.includes("Win") ) 	{ return "Windows" }
		if ( string.includes("Mac") ) 	{ return "Darwin" }
		if ( string.includes("X11") ) 	{ return "UNIX" }
		if ( string.includes("Linux") ) { return "Linux" }

		return undefined
	};

	/**
	 * @description Frappe's Asset Helper
	 */
	frappe.provide('frappe.assets');
	frappe.assets.image = function (image, app) {
		if ( app === void 0 ) app = 'frappe';

		var  path     = "/assets/" + app + "/images/" + image;
		return path
	};

	/**
	 * @description Notify using Web Push Notifications
	 */
	frappe.provide('frappe.boot');
	frappe.provide('frappe.browser');
	frappe.browser.Notification = 'Notification' in window;

	frappe.notify     = function (string, options) {
		frappe.log    = frappe.Logger.get('frappe.notify');

		var OPTIONS = {
			icon: frappe.assets.image('favicon.png', 'frappe'),
			lang: frappe.boot.lang || "en"
		};
		options       = Object.assign({ }, OPTIONS, options);

		if ( !frappe.browser.Notification )
			{ frappe.log.error('ERROR: This browser does not support desktop notifications.'); }

		Notification.requestPermission(function (status) {
			if ( status === "granted" ) {
				var notification = new Notification(string, options);
			}
		});
	};

	frappe.chat.render = function (render, force) {
		if ( render === void 0 ) render = true;
		if ( force === void 0 ) force = false;

		frappe.log.info(((render ? "Enable" : "Disable") + " Chat for User."));

		var desk = 'desk' in frappe;
		if ( desk ) {
			// With the assumption, that there's only one navbar.
			var $placeholder = $('.navbar .frappe-chat-dropdown');

			// Render if frappe-chat-toggle doesn't exist.
			if ( frappe.utils.is_empty($placeholder.has('.frappe-chat-toggle')) ) {
				var $template = $("\n\t\t\t\t<a class=\"dropdown-toggle frappe-chat-toggle\" data-toggle=\"dropdown\">\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<i class=\"octicon octicon-comment-discussion\"/>\n\t\t\t\t\t</div>\n\t\t\t\t</a>\n\t\t\t");

				$placeholder.addClass('dropdown hidden');
				$placeholder.html($template);
			}

			if ( render ) {
				$placeholder.removeClass('hidden');
			} else {
				$placeholder.addClass('hidden');
			}
		}

		// Avoid re-renders. Once is enough.
		if ( !frappe.chatter || force ) {
			frappe.chatter = new frappe.Chat({
				target: desk ? '.frappe-chat-toggle' : null
			});

			if ( render ) {
				if ( frappe.session.user === 'Guest' && !desk ) {
					frappe.store = frappe.Store.get('frappe.chat');
					var token	 = frappe.store.get('guest_token');

					frappe.log.info(("Local Guest Token - " + token));

					var setup_room = function (token) {
						return new Promise(function (resolve) {
							frappe.chat.room.create("Visitor", token).then(function (room) {
								frappe.log.info(("Visitor Room Created: " + (room.name)));
								frappe.chat.room.subscribe(room.name);

								var reference = room;

								frappe.chat.room.history(room.name).then(function (messages) {
									var  room = Object.assign({}, reference, {messages: messages});
									return room
								}).then(function (room) {
									resolve(room);
								});
							});
						})
					};

					if ( !token ) {
						frappe.chat.website.token().then(function (token) {
							frappe.log.info(("Generated Guest Token - " + token));
							frappe.store.set('guest_token', token);

							setup_room(token).then(function (room) {
								frappe.chatter.render({ room: room });
							});
						});
					} else {
						setup_room(token).then(function (room) {
							frappe.chatter.render({ room: room });
						});
					}
				} else {
					frappe.chatter.render();
				}
			}
		}
	};

	frappe.chat.setup  = function () {
		frappe.log     = frappe.Logger.get('frappe.chat');

		frappe.log.info('Setting up frappe.chat');
		frappe.log.warn('TODO: frappe.chat.<object> requires a storage.');

		if ( frappe.session.user !== 'Guest' ) {
			// Create/Get Chat Profile for session User, retrieve enable_chat
			frappe.log.info('Creating a Chat Profile.');

			frappe.chat.profile.create('enable_chat').then(function (ref) {
				var enable_chat = ref.enable_chat;

				frappe.log.info(("Chat Profile created for User " + (frappe.session.user) + "."));

				if ( 'desk' in frappe ) { // same as desk?
					var should_render = Boolean(parseInt(frappe.sys_defaults.enable_chat)) && enable_chat;
					frappe.chat.render(should_render);
				}
			});

			// Triggered when a User updates his/her Chat Profile.
			// Don't worry, enable_chat is broadcasted to this user only. No overhead. :)
			frappe.chat.profile.on.update(function (user, profile) {
				if ( user === frappe.session.user && 'enable_chat' in profile ) {
					frappe.log.warn(("Chat Profile update (Enable Chat - " + (Boolean(profile.enable_chat)) + ")"));
					var should_render = Boolean(parseInt(frappe.sys_defaults.enable_chat)) && profile.enable_chat;
					frappe.chat.render(should_render);
				}
			});
		} else {
			// Website Settings
			frappe.log.info('Retrieving Chat Website Settings.');
			frappe.chat.website.settings(["socketio", "enable", "enable_from", "enable_to"])
				.then(function (settings) {
					frappe.log.info(("Chat Website Setting - " + (JSON.stringify(settings))));
					frappe.log.info(("Chat Website Setting - " + (settings.enable ? "Enable" : "Disable")));

					var should_render = settings.enable;
					if ( settings.enable_from && settings.enable_to ) {
						frappe.log.info(("Enabling Chat Schedule - " + (settings.enable_from.format()) + " : " + (settings.enable_to.format())));

						var range   = new frappe.datetime.range(settings.enable_from, settings.enable_to);
						should_render = range.contains(frappe.datetime.now());
					}

					if ( should_render ) {
						frappe.log.info("Initializing Socket.IO");
						frappe.socketio.init(settings.socketio.port);
					}

					frappe.chat.render(should_render);
			});
		}
	};

	$(document).on('ready toolbar_setup', function () {
		frappe.chat.setup();
	});

	frappe.views.SocialFactory = class SocialFactory extends frappe.views.Factory {
		show() {
			if (frappe.pages.social) {
				frappe.container.change_to('social');
			} else {
				this.make('social');
			}
		}

		make(page_name) {
			var this$1 = this;

			var assets = [
				'/assets/js/social.min.js'
			];

			frappe.require(assets, function () {
				frappe.social.home = new frappe.social.Home({
					parent: this$1.make_page(true, page_name)
				});
			});
		}
	};

	// Copyright (c) 2019, Frappe Technologies Pvt. Ltd. and Contributors
	// MIT License. See license.txt

	frappe.provide('frappe.energy_points');

	Object.assign(frappe.energy_points, {
		get_points: function get_points(points) {
			return ("<span class='bold' style=\"color: " + (points >= 0 ? '#45A163': '#e42121') + "\">\n\t\t\t" + (points > 0 ? '+': '') + points + "\n\t\t</span>");
		},
		format_form_log: function format_form_log(log) {
			var separator = "<span>&nbsp;-&nbsp;</span>";
			var formatted_log = "<span>\n\t\t\t" + (this.get_points(log.points)) + "&nbsp;\n\t\t\t<a href=\"#Form/Energy Point Log/" + (log.name) + "\">" + (this.get_form_log_message(log)) + "</a>\n\t\t\t" + (log.reason ? separator + log.reason: '') + "\n\t\t</span>";
			return formatted_log;
		},
		format_history_log: function format_history_log(log) {
			// redundant code to honor readability and to avoid confusion
			var separator = "<span>&nbsp;-&nbsp;</span>";
			var route = frappe.utils.get_form_link(log.reference_doctype, log.reference_name);
			var formatted_log = "<span>\n\t\t\t" + (this.get_points(log.points)) + "&nbsp;\n\t\t\t<a href=\"" + route + "\">" + (this.get_history_log_message(log)) + "</a>\n\t\t\t" + (log.reason ? separator + log.reason: '') + "\n\t\t\t" + (separator + frappe.datetime.comment_when(log.creation)) + "\n\t\t</span>";
			return formatted_log;
		},
		get_history_log_message: function get_history_log_message(log) {
			var owner_name = frappe.user.full_name(log.owner).bold();
			var ref_doc = log.reference_name;

			if (log.type === 'Appreciation') {
				return __('{0} appreciated on {1}', [owner_name, ref_doc]);
			}
			if (log.type === 'Criticism') {
				return __('{0} criticized on {1}', [owner_name, ref_doc]);
			}
			if (log.type === 'Revert') {
				return __('{0} reverted {1}', [owner_name, log.revert_of]);
			}
			return __('via automatic rule {0} on {1}', [log.rule.bold(), ref_doc]);
		},
		get_form_log_message: function get_form_log_message(log) {
			// redundant code to honor readability and to avoid confusion
			var owner_name = frappe.user.full_name(log.owner).bold();
			var user = frappe.user.full_name(log.user).bold();
			if (log.type === 'Appreciation') {
				return __('{0} appreciated {1}', [owner_name, user]);
			}
			if (log.type === 'Criticism') {
				return __('{0} criticized {1}', [owner_name, user]);
			}
			if (log.type === 'Revert') {
				return __('{0} reverted {1}', [owner_name, log.revert_of]);
			}
			return __('gained by {0} via automatic rule {1}', [user, log.rule.bold()]);
		},
	});

	function __$styleInject(t,e){void 0===e&&(e={});var n=e.insertAt;if(t&&"undefined"!=typeof document){var i=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===n&&i.firstChild?i.insertBefore(a,i.firstChild):i.appendChild(a),a.styleSheet?a.styleSheet.cssText=t:a.appendChild(document.createTextNode(t));}}function $$1(t,e){return "string"==typeof t?(e||document).querySelector(t):t||null}function getOffset(t){var e=t.getBoundingClientRect();return {top:e.top+(document.documentElement.scrollTop||document.body.scrollTop),left:e.left+(document.documentElement.scrollLeft||document.body.scrollLeft)}}function isElementInViewport(t){var e=t.getBoundingClientRect();return e.top>=0&&e.left>=0&&e.bottom<=(window.innerHeight||document.documentElement.clientHeight)&&e.right<=(window.innerWidth||document.documentElement.clientWidth)}function getElementContentWidth(t){var e=window.getComputedStyle(t),n=parseFloat(e.paddingLeft)+parseFloat(e.paddingRight);return t.clientWidth-n}function fire(t,e,n){var i=document.createEvent("HTMLEvents");i.initEvent(e,!0,!0);for(var a in n){ i[a]=n[a]; }return t.dispatchEvent(i)}function getTopOffset(t){return t.titleHeight+t.margins.top+t.paddings.top}function getLeftOffset(t){return t.margins.left+t.paddings.left}function getExtraHeight(t){return t.margins.top+t.margins.bottom+t.paddings.top+t.paddings.bottom+t.titleHeight+t.legendHeight}function getExtraWidth(t){return t.margins.left+t.margins.right+t.paddings.left+t.paddings.right}function _classCallCheck$4(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function floatTwo(t){return parseFloat(t.toFixed(2))}function fillArray(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];n||(n=i?t[0]:t[t.length-1]);var a=new Array(Math.abs(e)).fill(n);return t=i?a.concat(t):t.concat(a)}function getStringWidth(t,e){return (t+"").length*e}function getPositionByAngle(t,e){return {x:Math.sin(t*ANGLE_RATIO)*e,y:Math.cos(t*ANGLE_RATIO)*e}}function getBarHeightAndYAttr(t,e){var n=void 0,i=void 0;return t<=e?(n=e-t,i=t):(n=t-e,i=e),[n,i]}function equilizeNoOfElements(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.length-t.length;return n>0?t=fillArray(t,n):e=fillArray(e,n),[t,e]}function limitColor(t){return t>255?255:t<0?0:t}function lightenDarkenColor(t,e){var n=getColor(t),i=!1;"#"==n[0]&&(n=n.slice(1),i=!0);var a=parseInt(n,16),r=limitColor((a>>16)+e),o=limitColor((a>>8&255)+e),s=limitColor((255&a)+e);return (i?"#":"")+(s|o<<8|r<<16).toString(16)}function isValidColor(t){return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t)}function $$1$1(t,e){return "string"==typeof t?(e||document).querySelector(t):t||null}function createSVG(t,e){var n=document.createElementNS("http://www.w3.org/2000/svg",t);for(var i in e){var a=e[i];if("inside"===i){ $$1$1(a).appendChild(n); }else if("around"===i){var r=$$1$1(a);r.parentNode.insertBefore(n,r),n.appendChild(r);}else{ "styles"===i?"object"===(void 0===a?"undefined":_typeof$2(a))&&Object.keys(a).map(function(t){n.style[t]=a[t];}):("className"===i&&(i="class"),"innerHTML"===i?n.textContent=a:n.setAttribute(i,a)); }}return n}function renderVerticalGradient(t,e){return createSVG("linearGradient",{inside:t,id:e,x1:0,x2:0,y1:0,y2:1})}function setGradientStop(t,e,n,i){return createSVG("stop",{inside:t,style:"stop-color: "+n,offset:e,"stop-opacity":i})}function makeSVGContainer(t,e,n,i){return createSVG("svg",{className:e,inside:t,width:n,height:i})}function makeSVGDefs(t){return createSVG("defs",{inside:t})}function makeSVGGroup(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,i={className:t,transform:e};return n&&(i.inside=n),createSVG("g",i)}function makePath(t){return createSVG("path",{className:arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",d:t,styles:{stroke:arguments.length>2&&void 0!==arguments[2]?arguments[2]:"none",fill:arguments.length>3&&void 0!==arguments[3]?arguments[3]:"none","stroke-width":arguments.length>4&&void 0!==arguments[4]?arguments[4]:0}})}function makeArcPathStr(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=n.x+t.x,s=n.y+t.y,l=n.x+e.x,u=n.y+e.y;return "M"+n.x+" "+n.y+"\n\t\tL"+o+" "+s+"\n\t\tA "+i+" "+i+" 0 "+r+" "+(a?1:0)+"\n\t\t"+l+" "+u+" z"}function makeArcStrokePathStr(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,r=n.x+t.x,o=n.y+t.y,s=n.x+e.x,l=n.y+e.y;return "M"+r+" "+o+"\n\t\tA "+i+" "+i+" 0 0 "+(a?1:0)+"\n\t\t"+s+" "+l}function makeGradient(t,e){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i="path-fill-gradient-"+e+"-"+(n?"lighter":"default"),a=renderVerticalGradient(t,i),r=[1,.6,.2];return n&&(r=[.4,.2,0]),setGradientStop(a,"0%",e,r[0]),setGradientStop(a,"50%",e,r[1]),setGradientStop(a,"100%",e,r[2]),i}function percentageBar(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:PERCENTAGE_BAR_DEFAULT_DEPTH,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"none";return createSVG("rect",{className:"percentage-bar",x:t,y:e,width:n,height:i,fill:r,styles:{stroke:lightenDarkenColor(r,-25),"stroke-dasharray":"0, "+(i+n)+", "+n+", "+i,"stroke-width":a}})}function heatSquare(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"none",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{},o={className:t,x:e,y:n,width:i,height:i,fill:a};return Object.keys(r).map(function(t){o[t]=r[t];}),createSVG("rect",o)}function legendBar(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"none",a=arguments[4],r={className:"legend-bar",x:0,y:0,width:n,height:"2px",fill:i},o=createSVG("text",{className:"legend-dataset-text",x:0,y:0,dy:2*FONT_SIZE+"px","font-size":1.2*FONT_SIZE+"px","text-anchor":"start",fill:FONT_FILL,innerHTML:a}),s=createSVG("g",{transform:"translate("+t+", "+e+")"});return s.appendChild(createSVG("rect",r)),s.appendChild(o),s}function legendDot(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"none",a=arguments[4],r={className:"legend-dot",cx:0,cy:0,r:n,fill:i},o=createSVG("text",{className:"legend-dataset-text",x:0,y:0,dx:FONT_SIZE+"px",dy:FONT_SIZE/3+"px","font-size":1.2*FONT_SIZE+"px","text-anchor":"start",fill:FONT_FILL,innerHTML:a}),s=createSVG("g",{transform:"translate("+t+", "+e+")"});return s.appendChild(createSVG("circle",r)),s.appendChild(o),s}function makeText(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},r=a.fontSize||FONT_SIZE;return createSVG("text",{className:t,x:e,y:n,dy:(void 0!==a.dy?a.dy:r/2)+"px","font-size":r+"px",fill:a.fill||FONT_FILL,"text-anchor":a.textAnchor||"start",innerHTML:i})}function makeVertLine(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};a.stroke||(a.stroke=BASE_LINE_COLOR);var r=createSVG("line",{className:"line-vertical "+a.className,x1:0,x2:0,y1:n,y2:i,styles:{stroke:a.stroke}}),o=createSVG("text",{x:0,y:n>i?n+LABEL_MARGIN:n-LABEL_MARGIN-FONT_SIZE,dy:FONT_SIZE+"px","font-size":FONT_SIZE+"px","text-anchor":"middle",innerHTML:e+""}),s=createSVG("g",{transform:"translate("+t+", 0)"});return s.appendChild(r),s.appendChild(o),s}function makeHoriLine(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};a.stroke||(a.stroke=BASE_LINE_COLOR),a.lineType||(a.lineType="");var r=createSVG("line",{className:"line-horizontal "+a.className+("dashed"===a.lineType?"dashed":""),x1:n,x2:i,y1:0,y2:0,styles:{stroke:a.stroke}}),o=createSVG("text",{x:n<i?n-LABEL_MARGIN:n+LABEL_MARGIN,y:0,dy:FONT_SIZE/2-2+"px","font-size":FONT_SIZE+"px","text-anchor":n<i?"end":"start",innerHTML:e+""}),s=createSVG("g",{transform:"translate(0, "+t+")","stroke-opacity":1});return 0!==o&&"0"!==o||(s.style.stroke="rgba(27, 31, 35, 0.6)"),s.appendChild(r),s.appendChild(o),s}function yLine(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};i.pos||(i.pos="left"),i.offset||(i.offset=0),i.mode||(i.mode="span"),i.stroke||(i.stroke=BASE_LINE_COLOR),i.className||(i.className="");var a=-1*AXIS_TICK_LENGTH,r="span"===i.mode?n+AXIS_TICK_LENGTH:0;return "tick"===i.mode&&"right"===i.pos&&(a=n+AXIS_TICK_LENGTH,r=n),a+=i.offset,r+=i.offset,makeHoriLine(t,e,a,r,{stroke:i.stroke,className:i.className,lineType:i.lineType})}function xLine(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};i.pos||(i.pos="bottom"),i.offset||(i.offset=0),i.mode||(i.mode="span"),i.stroke||(i.stroke=BASE_LINE_COLOR),i.className||(i.className="");var a=n+AXIS_TICK_LENGTH,r="span"===i.mode?-1*AXIS_TICK_LENGTH:n;return "tick"===i.mode&&"top"===i.pos&&(a=-1*AXIS_TICK_LENGTH,r=0),makeVertLine(t,e,a,r,{stroke:i.stroke,className:i.className,lineType:i.lineType})}function yMarker(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};i.labelPos||(i.labelPos="right");var a=createSVG("text",{className:"chart-label",x:"left"===i.labelPos?LABEL_MARGIN:n-getStringWidth(e,5)-LABEL_MARGIN,y:0,dy:FONT_SIZE/-2+"px","font-size":FONT_SIZE+"px","text-anchor":"start",innerHTML:e+""}),r=makeHoriLine(t,"",0,n,{stroke:i.stroke||BASE_LINE_COLOR,className:i.className||"",lineType:i.lineType});return r.appendChild(a),r}function yRegion(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},r=t-e,o=createSVG("rect",{className:"bar mini",styles:{fill:"rgba(228, 234, 239, 0.49)",stroke:BASE_LINE_COLOR,"stroke-dasharray":n+", "+r},x:0,y:0,width:n,height:r});a.labelPos||(a.labelPos="right");var s=createSVG("text",{className:"chart-label",x:"left"===a.labelPos?LABEL_MARGIN:n-getStringWidth(i+"",4.5)-LABEL_MARGIN,y:0,dy:FONT_SIZE/-2+"px","font-size":FONT_SIZE+"px","text-anchor":"start",innerHTML:i+""}),l=createSVG("g",{transform:"translate(0, "+e+")"});return l.appendChild(o),l.appendChild(s),l}function datasetBar(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:{},l=getBarHeightAndYAttr(e,s.zeroLine),u=_slicedToArray(l,2),c=u[0],h=u[1];h-=o,0===c&&(c=s.minHeight,h-=s.minHeight);var d=createSVG("rect",{className:"bar mini",style:"fill: "+i,"data-point-index":r,x:t,y:h,width:n,height:c});if((a+="")||a.length){d.setAttribute("y",0),d.setAttribute("x",0);var f=createSVG("text",{className:"data-point-value",x:n/2,y:0,dy:FONT_SIZE/2*-1+"px","font-size":FONT_SIZE+"px","text-anchor":"middle",innerHTML:a}),p=createSVG("g",{"data-point-index":r,transform:"translate("+t+", "+h+")"});return p.appendChild(d),p.appendChild(f),p}return d}function datasetDot(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=createSVG("circle",{style:"fill: "+i,"data-point-index":r,cx:t,cy:e,r:n});if((a+="")||a.length){o.setAttribute("cy",0),o.setAttribute("cx",0);var s=createSVG("text",{className:"data-point-value",x:0,y:0,dy:FONT_SIZE/2*-1-n+"px","font-size":FONT_SIZE+"px","text-anchor":"middle",innerHTML:a}),l=createSVG("g",{"data-point-index":r,transform:"translate("+t+", "+e+")"});return l.appendChild(o),l.appendChild(s),l}return o}function getPaths(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},r=e.map(function(e,n){return t[n]+","+e}).join("L"),o=makePath("M"+r,"line-graph-path",n);if(i.heatline){var s=makeGradient(a.svgDefs,n);o.style.stroke="url(#"+s+")";}var l={path:o};if(i.regionFill){var u=makeGradient(a.svgDefs,n,!0),c="M"+t[0]+","+a.zeroLine+"L"+r+"L"+t.slice(-1)[0]+","+a.zeroLine;l.region=makePath(c,"region-fill","none","url(#"+u+")");}return l}function translate(t,e,n,i){var a="string"==typeof e?e:e.join(", ");return [t,{transform:n.join(", ")},i,STD_EASING,"translate",{transform:a}]}function translateVertLine(t,e,n){return translate(t,[n,0],[e,0],MARKER_LINE_ANIM_DUR)}function translateHoriLine(t,e,n){return translate(t,[0,n],[0,e],MARKER_LINE_ANIM_DUR)}function animateRegion(t,e,n,i){var a=e-n,r=t.childNodes[0];return [[r,{height:a,"stroke-dasharray":r.getAttribute("width")+", "+a},MARKER_LINE_ANIM_DUR,STD_EASING],translate(t,[0,i],[0,n],MARKER_LINE_ANIM_DUR)]}function animateBar(t,e,n,i){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=getBarHeightAndYAttr(n,(arguments.length>5&&void 0!==arguments[5]?arguments[5]:{}).zeroLine),o=_slicedToArray$2(r,2),s=o[0],l=o[1];return l-=a,"rect"!==t.nodeName?[[t.childNodes[0],{width:i,height:s},UNIT_ANIM_DUR,STD_EASING],translate(t,t.getAttribute("transform").split("(")[1].slice(0,-1),[e,l],MARKER_LINE_ANIM_DUR)]:[[t,{width:i,height:s,x:e,y:l},UNIT_ANIM_DUR,STD_EASING]]}function animateDot(t,e,n){return "circle"!==t.nodeName?[translate(t,t.getAttribute("transform").split("(")[1].slice(0,-1),[e,n],MARKER_LINE_ANIM_DUR)]:[[t,{cx:e,cy:n},UNIT_ANIM_DUR,STD_EASING]]}function animatePath(t,e,n,i){var a=[],r=n.map(function(t,n){return e[n]+","+t}).join("L"),o=[t.path,{d:"M"+r},PATH_ANIM_DUR,STD_EASING];if(a.push(o),t.region){var s=e[0]+","+i+"L",l="L"+e.slice(-1)[0]+", "+i,u=[t.region,{d:"M"+s+r+l},PATH_ANIM_DUR,STD_EASING];a.push(u);}return a}function animatePathStr(t,e){return [t,{d:e},UNIT_ANIM_DUR,STD_EASING]}function _toConsumableArray$1(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function animateSVGElement(t,e,n){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"linear",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{},o=t.cloneNode(!0),s=t.cloneNode(!0);for(var l in e){var u=void 0;u="transform"===l?document.createElementNS("http://www.w3.org/2000/svg","animateTransform"):document.createElementNS("http://www.w3.org/2000/svg","animate");var c=r[l]||t.getAttribute(l),h=e[l],d={attributeName:l,from:c,to:h,begin:"0s",dur:n/1e3+"s",values:c+";"+h,keySplines:EASING[i],keyTimes:"0;1",calcMode:"spline",fill:"freeze"};a&&(d.type=a);for(var f in d){ u.setAttribute(f,d[f]); }o.appendChild(u),a?s.setAttribute(l,"translate("+h+")"):s.setAttribute(l,h);}return [o,s]}function transform(t,e){t.style.transform=e,t.style.webkitTransform=e,t.style.msTransform=e,t.style.mozTransform=e,t.style.oTransform=e;}function animateSVG(t,e){var n=[],i=[];e.map(function(t){var e=t[0],a=e.parentNode,r=void 0,o=void 0;t[0]=e;var s=animateSVGElement.apply(void 0,_toConsumableArray$1(t)),l=_slicedToArray$1(s,2);r=l[0],o=l[1],n.push(o),i.push([r,a]),a.replaceChild(r,e);});var a=t.cloneNode(!0);return i.map(function(t,i){t[1].replaceChild(n[i],t[0]),e[i][0]=n[i];}),a}function runSMILAnimation(t,e,n){if(0!==n.length){var i=animateSVG(e,n);e.parentNode==t&&(t.removeChild(e),t.appendChild(i)),setTimeout(function(){i.parentNode==t&&(t.removeChild(i),t.appendChild(e));},REPLACE_ALL_NEW_DUR);}}function downloadFile(t,e){var n=document.createElement("a");n.style="display: none";var i=new Blob(e,{type:"image/svg+xml; charset=utf-8"}),a=window.URL.createObjectURL(i);n.href=a,n.download=t,document.body.appendChild(n),n.click(),setTimeout(function(){document.body.removeChild(n),window.URL.revokeObjectURL(a);},300);}function prepareForExport(t){var e=t.cloneNode(!0);e.classList.add("chart-container"),e.setAttribute("xmlns","http://www.w3.org/2000/svg"),e.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink");var n=$$1.create("style",{innerHTML:CSSTEXT});e.insertBefore(n,e.firstChild);var i=$$1.create("div");return i.appendChild(e),i.innerHTML}function _classCallCheck$3(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _classCallCheck$2(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$1(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$1(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function treatAsUtc(t){var e=new Date(t);return e.setMinutes(e.getMinutes()-e.getTimezoneOffset()),e}function getYyyyMmDd(t){var e=t.getDate(),n=t.getMonth()+1;return [t.getFullYear(),(n>9?"":"0")+n,(e>9?"":"0")+e].join("-")}function clone(t){return new Date(t.getTime())}function getWeeksBetween(t,e){var n=setDayToSunday(t);return Math.ceil(getDaysBetween(n,e)/NO_OF_DAYS_IN_WEEK)}function getDaysBetween(t,e){var n=SEC_IN_DAY*NO_OF_MILLIS;return (treatAsUtc(e)-treatAsUtc(t))/n}function areInSameMonth(t,e){return t.getMonth()===e.getMonth()&&t.getFullYear()===e.getFullYear()}function getMonthName(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=MONTH_NAMES[t];return e?n.slice(0,3):n}function getLastDateInMonth(t,e){return new Date(e,t+1,0)}function setDayToSunday(t){var e=clone(t),n=e.getDay();return 0!==n&&addDays(e,-1*n),e}function addDays(t,e){t.setDate(t.getDate()+e);}function _classCallCheck$5(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function getComponent(t,e,n){var i=Object.keys(componentConfigs).filter(function(e){return t.includes(e)}),a=componentConfigs[i[0]];return Object.assign(a,{constants:e,getData:n}),new ChartComponent(a)}function _toConsumableArray(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$1(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function _toConsumableArray$2(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$6(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$2(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$2(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function _toConsumableArray$4(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function normalize(t){if(0===t){ return [0,0]; }if(isNaN(t)){ return {mantissa:-6755399441055744,exponent:972}; }var e=t>0?1:-1;if(!isFinite(t)){ return {mantissa:4503599627370496*e,exponent:972}; }t=Math.abs(t);var n=Math.floor(Math.log10(t));return [e*(t/Math.pow(10,n)),n]}function getChartRangeIntervals(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=Math.ceil(t),i=Math.floor(e),a=n-i,r=a,o=1;a>5&&(a%2!=0&&(a=++n-i),r=a/2,o=2),a<=2&&(o=a/(r=4)),0===a&&(r=5,o=1);for(var s=[],l=0;l<=r;l++){ s.push(i+o*l); }return s}function getChartIntervals(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=normalize(t),i=_slicedToArray$4(n,2),a=i[0],r=i[1],o=e?e/Math.pow(10,r):0,s=getChartRangeIntervals(a=a.toFixed(6),o);return s=s.map(function(t){return t*Math.pow(10,r)})}function calcChartIntervals(t){function e(t,e){for(var n=getChartIntervals(t),i=n[1]-n[0],a=0,r=1;a<e;r++){ a+=i,n.unshift(-1*a); }return n}var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=Math.max.apply(Math,_toConsumableArray$4(t)),a=Math.min.apply(Math,_toConsumableArray$4(t)),r=[];if(i>=0&&a>=0){ normalize(i)[1],r=n?getChartIntervals(i,a):getChartIntervals(i); }else if(i>0&&a<0){var o=Math.abs(a);i>=o?(normalize(i)[1],r=e(i,o)):(normalize(o)[1],r=e(o,i).map(function(t){return -1*t}));}else if(i<=0&&a<=0){var s=Math.abs(a),l=Math.abs(i);normalize(s)[1],r=(r=n?getChartIntervals(s,l):getChartIntervals(s)).reverse().map(function(t){return -1*t});}return r}function getZeroIndex(t){var e=getIntervalSize(t);return t.indexOf(0)>=0?t.indexOf(0):t[0]>0?-1*t[0]/e:-1*t[t.length-1]/e+(t.length-1)}function getIntervalSize(t){return t[1]-t[0]}function getValueRange(t){return t[t.length-1]-t[0]}function scale(t,e){return floatTwo(e.zeroLine-t*e.scaleMultiplier)}function getClosestInArray(t,e){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=e.reduce(function(e,n){return Math.abs(n-t)<Math.abs(e-t)?n:e});return n?e.indexOf(i):i}function calcDistribution(t,e){for(var n=Math.max.apply(Math,_toConsumableArray$4(t)),i=1/(e-1),a=[],r=0;r<e;r++){var o=n*(i*r);a.push(o);}return a}function getMaxCheckpoint(t,e){return e.filter(function(e){return e<t}).length}function _toConsumableArray$3(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$7(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$3(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$3(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function dataPrep(t,e){t.labels=t.labels||[];var n=t.labels.length,i=t.datasets,a=new Array(n).fill(0);return i||(i=[{values:a}]),i.map(function(t){if(t.values){var i=t.values;i=(i=i.map(function(t){return isNaN(t)?0:t})).length>n?i.slice(0,n):fillArray(i,n-i.length,0);}else { t.values=a; }t.chartType||(t.chartType=e);}),t.yRegions&&t.yRegions.map(function(t){if(t.end<t.start){var e=[t.end,t.start];t.start=e[0],t.end=e[1];}}),t}function zeroDataPrep(t){var e=t.labels.length,n=new Array(e).fill(0),i={labels:t.labels.slice(0,-1),datasets:t.datasets.map(function(t){return {name:"",values:n.slice(0,-1),chartType:t.chartType}})};return t.yMarkers&&(i.yMarkers=[{value:0,label:""}]),t.yRegions&&(i.yRegions=[{start:0,end:0,label:""}]),i}function getShortenedLabels(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=t/e.length;i<=0&&(i=1);var a=i/DEFAULT_CHAR_WIDTH;return e.map(function(t,e){return (t+="").length>a&&(n?e%Math.ceil(t.length/a)!=0&&(t=""):t=a-3>0?t.slice(0,a-3)+" ...":t.slice(0,a)+".."),t})}function _toConsumableArray$5(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$8(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$4(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$4(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function _toConsumableArray$6(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++){ n[e]=t[e]; }return n}return Array.from(t)}function _classCallCheck$9(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function _possibleConstructorReturn$5(t,e){if(!t){ throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); }return !e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits$5(t,e){if("function"!=typeof e&&null!==e){ throw new TypeError("Super expression must either be null or a function, not "+typeof e); }t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}function _classCallCheck(t,e){if(!(t instanceof e)){ throw new TypeError("Cannot call a class as a function") }}function getChartByType(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"line",e=arguments[1],n=arguments[2];return "axis-mixed"===t?(n.type="line",new AxisChart(e,n)):chartTypes[t]?new chartTypes[t](e,n):void console.error("Undefined chart type: "+t)}__$styleInject('.chart-container{position:relative;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif}.chart-container .axis,.chart-container .chart-label{fill:#555b51}.chart-container .axis line,.chart-container .chart-label line{stroke:#dadada}.chart-container .dataset-units circle{stroke:#fff;stroke-width:2}.chart-container .dataset-units path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container .dataset-path{stroke-width:2px}.chart-container .path-group path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container line.dashed{stroke-dasharray:5,3}.chart-container .axis-line .specific-value{text-anchor:start}.chart-container .axis-line .y-line{text-anchor:end}.chart-container .axis-line .x-line{text-anchor:middle}.chart-container .legend-dataset-text{fill:#6c7680;font-weight:600}.graph-svg-tip{position:absolute;z-index:1;padding:10px;font-size:12px;color:#959da5;text-align:center;background:rgba(0,0,0,.8);border-radius:3px}.graph-svg-tip ol,.graph-svg-tip ul{padding-left:0;display:-webkit-box;display:-ms-flexbox;display:flex}.graph-svg-tip ul.data-point-list li{min-width:90px;-webkit-box-flex:1;-ms-flex:1;flex:1;font-weight:600}.graph-svg-tip strong{color:#dfe2e5;font-weight:600}.graph-svg-tip .svg-pointer{position:absolute;height:5px;margin:0 0 0 -5px;content:" ";border:5px solid transparent;border-top-color:rgba(0,0,0,.8)}.graph-svg-tip.comparison{padding:0;text-align:left;pointer-events:none}.graph-svg-tip.comparison .title{display:block;padding:10px;margin:0;font-weight:600;line-height:1;pointer-events:none}.graph-svg-tip.comparison ul{margin:0;white-space:nowrap;list-style:none}.graph-svg-tip.comparison li{display:inline-block;padding:5px 10px}',{});var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};$$1.create=function(t,e){var n=document.createElement(t);for(var i in e){var a=e[i];if("inside"===i){ $$1(a).appendChild(n); }else if("around"===i){var r=$$1(a);r.parentNode.insertBefore(n,r),n.appendChild(r);}else{ "styles"===i?"object"===(void 0===a?"undefined":_typeof(a))&&Object.keys(a).map(function(t){n.style[t]=a[t];}):i in n?n[i]=a:n.setAttribute(i,a); }}return n};var BASE_MEASURES={margins:{top:10,bottom:10,left:20,right:20},paddings:{top:20,bottom:40,left:30,right:10},baseHeight:240,titleHeight:20,legendHeight:30,titleFontSize:12},INIT_CHART_UPDATE_TIMEOUT=700,CHART_POST_ANIMATE_TIMEOUT=400,AXIS_LEGEND_BAR_SIZE=100,BAR_CHART_SPACE_RATIO=.5,MIN_BAR_PERCENT_HEIGHT=.01,LINE_CHART_DOT_SIZE=4,DOT_OVERLAY_SIZE_INCR=4,PERCENTAGE_BAR_DEFAULT_HEIGHT=20,PERCENTAGE_BAR_DEFAULT_DEPTH=2,HEATMAP_DISTRIBUTION_SIZE=5,HEATMAP_SQUARE_SIZE=10,HEATMAP_GUTTER_SIZE=2,DEFAULT_CHAR_WIDTH=7,TOOLTIP_POINTER_TRIANGLE_HEIGHT=5,DEFAULT_CHART_COLORS=["light-blue","blue","violet","red","orange","yellow","green","light-green","purple","magenta","light-grey","dark-grey"],HEATMAP_COLORS_GREEN=["#ebedf0","#c6e48b","#7bc96f","#239a3b","#196127"],DEFAULT_COLORS={bar:DEFAULT_CHART_COLORS,line:DEFAULT_CHART_COLORS,pie:DEFAULT_CHART_COLORS,percentage:DEFAULT_CHART_COLORS,heatmap:HEATMAP_COLORS_GREEN,donut:DEFAULT_CHART_COLORS},ANGLE_RATIO=Math.PI/180,FULL_ANGLE=360,_createClass$3=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),SvgTip=function(){function t(e){var n=e.parent,i=void 0===n?null:n,a=e.colors,r=void 0===a?[]:a;_classCallCheck$4(this,t),this.parent=i,this.colors=r,this.titleName="",this.titleValue="",this.listValues=[],this.titleValueFirst=0,this.x=0,this.y=0,this.top=0,this.left=0,this.setup();}return _createClass$3(t,[{key:"setup",value:function(){this.makeTooltip();}},{key:"refresh",value:function(){this.fill(),this.calcPosition();}},{key:"makeTooltip",value:function(){var t=this;this.container=$$1.create("div",{inside:this.parent,className:"graph-svg-tip comparison",innerHTML:'<span class="title"></span>\n\t\t\t\t<ul class="data-point-list"></ul>\n\t\t\t\t<div class="svg-pointer"></div>'}),this.hideTip(),this.title=this.container.querySelector(".title"),this.dataPointList=this.container.querySelector(".data-point-list"),this.parent.addEventListener("mouseleave",function(){t.hideTip();});}},{key:"fill",value:function(){var t=this,e=void 0;this.index&&this.container.setAttribute("data-point-index",this.index),e=this.titleValueFirst?"<strong>"+this.titleValue+"</strong>"+this.titleName:this.titleName+"<strong>"+this.titleValue+"</strong>",this.title.innerHTML=e,this.dataPointList.innerHTML="",this.listValues.map(function(e,n){var i=t.colors[n]||"black",a=0===e.formatted||e.formatted?e.formatted:e.value,r=$$1.create("li",{styles:{"border-top":"3px solid "+i},innerHTML:'<strong style="display: block;">'+(0===a||a?a:"")+"</strong>\n\t\t\t\t\t"+(e.title?e.title:"")});t.dataPointList.appendChild(r);});}},{key:"calcPosition",value:function(){var t=this.container.offsetWidth;this.top=this.y-this.container.offsetHeight-TOOLTIP_POINTER_TRIANGLE_HEIGHT,this.left=this.x-t/2;var e=this.parent.offsetWidth-t,n=this.container.querySelector(".svg-pointer");if(this.left<0){ n.style.left="calc(50% - "+-1*this.left+"px)",this.left=0; }else if(this.left>e){var i="calc(50% + "+(this.left-e)+"px)";n.style.left=i,this.left=e;}else { n.style.left="50%"; }}},{key:"setValues",value:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:-1;this.titleName=n.name,this.titleValue=n.value,this.listValues=i,this.x=t,this.y=e,this.titleValueFirst=n.valueFirst||0,this.index=a,this.refresh();}},{key:"hideTip",value:function(){this.container.style.top="0px",this.container.style.left="0px",this.container.style.opacity="0";}},{key:"showTip",value:function(){this.container.style.top=this.top+"px",this.container.style.left=this.left+"px",this.container.style.opacity="1";}}]),t}(),PRESET_COLOR_MAP={"light-blue":"#7cd6fd",blue:"#5e64ff",violet:"#743ee2",red:"#ff5858",orange:"#ffa00a",yellow:"#feef72",green:"#28a745","light-green":"#98d85b",purple:"#b554ff",magenta:"#ffa3ef",black:"#36114C",grey:"#bdd3e6","light-grey":"#f0f4f7","dark-grey":"#b8c2cc"},getColor=function(t){return PRESET_COLOR_MAP[t]||t},_slicedToArray=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var o,s=t[Symbol.iterator]();!(i=(o=s.next()).done)&&(n.push(o.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&s.return&&s.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_typeof$2="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},AXIS_TICK_LENGTH=6,LABEL_MARGIN=4,FONT_SIZE=10,BASE_LINE_COLOR="#dadada",FONT_FILL="#555b51",makeOverlay={bar:function(t){var e=void 0;"rect"!==t.nodeName&&(e=t.getAttribute("transform"),t=t.childNodes[0]);var n=t.cloneNode();return n.style.fill="#000000",n.style.opacity="0.4",e&&n.setAttribute("transform",e),n},dot:function(t){var e=void 0;"circle"!==t.nodeName&&(e=t.getAttribute("transform"),t=t.childNodes[0]);var n=t.cloneNode(),i=t.getAttribute("r"),a=t.getAttribute("fill");return n.setAttribute("r",parseInt(i)+DOT_OVERLAY_SIZE_INCR),n.setAttribute("fill",a),n.style.opacity="0.6",e&&n.setAttribute("transform",e),n},heat_square:function(t){var e=void 0;"circle"!==t.nodeName&&(e=t.getAttribute("transform"),t=t.childNodes[0]);var n=t.cloneNode(),i=t.getAttribute("r"),a=t.getAttribute("fill");return n.setAttribute("r",parseInt(i)+DOT_OVERLAY_SIZE_INCR),n.setAttribute("fill",a),n.style.opacity="0.6",e&&n.setAttribute("transform",e),n}},updateOverlay={bar:function(t,e){var n=void 0;"rect"!==t.nodeName&&(n=t.getAttribute("transform"),t=t.childNodes[0]);var i=["x","y","width","height"];Object.values(t.attributes).filter(function(t){return i.includes(t.name)&&t.specified}).map(function(t){e.setAttribute(t.name,t.nodeValue);}),n&&e.setAttribute("transform",n);},dot:function(t,e){var n=void 0;"circle"!==t.nodeName&&(n=t.getAttribute("transform"),t=t.childNodes[0]);var i=["cx","cy"];Object.values(t.attributes).filter(function(t){return i.includes(t.name)&&t.specified}).map(function(t){e.setAttribute(t.name,t.nodeValue);}),n&&e.setAttribute("transform",n);},heat_square:function(t,e){var n=void 0;"circle"!==t.nodeName&&(n=t.getAttribute("transform"),t=t.childNodes[0]);var i=["cx","cy"];Object.values(t.attributes).filter(function(t){return i.includes(t.name)&&t.specified}).map(function(t){e.setAttribute(t.name,t.nodeValue);}),n&&e.setAttribute("transform",n);}},_slicedToArray$2=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var o,s=t[Symbol.iterator]();!(i=(o=s.next()).done)&&(n.push(o.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&s.return&&s.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),UNIT_ANIM_DUR=350,PATH_ANIM_DUR=350,MARKER_LINE_ANIM_DUR=UNIT_ANIM_DUR,REPLACE_ALL_NEW_DUR=250,STD_EASING="easein",_slicedToArray$1=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var o,s=t[Symbol.iterator]();!(i=(o=s.next()).done)&&(n.push(o.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&s.return&&s.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),EASING={ease:"0.25 0.1 0.25 1",linear:"0 0 1 1",easein:"0.1 0.8 0.2 1",easeout:"0 0 0.58 1",easeinout:"0.42 0 0.58 1"},CSSTEXT=".chart-container{position:relative;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif}.chart-container .axis,.chart-container .chart-label{fill:#555b51}.chart-container .axis line,.chart-container .chart-label line{stroke:#dadada}.chart-container .dataset-units circle{stroke:#fff;stroke-width:2}.chart-container .dataset-units path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container .dataset-path{stroke-width:2px}.chart-container .path-group path{fill:none;stroke-opacity:1;stroke-width:2px}.chart-container line.dashed{stroke-dasharray:5,3}.chart-container .axis-line .specific-value{text-anchor:start}.chart-container .axis-line .y-line{text-anchor:end}.chart-container .axis-line .x-line{text-anchor:middle}.chart-container .legend-dataset-text{fill:#6c7680;font-weight:600}.graph-svg-tip{position:absolute;z-index:99999;padding:10px;font-size:12px;color:#959da5;text-align:center;background:rgba(0,0,0,.8);border-radius:3px}.graph-svg-tip ul{padding-left:0;display:flex}.graph-svg-tip ol{padding-left:0;display:flex}.graph-svg-tip ul.data-point-list li{min-width:90px;flex:1;font-weight:600}.graph-svg-tip strong{color:#dfe2e5;font-weight:600}.graph-svg-tip .svg-pointer{position:absolute;height:5px;margin:0 0 0 -5px;content:' ';border:5px solid transparent;border-top-color:rgba(0,0,0,.8)}.graph-svg-tip.comparison{padding:0;text-align:left;pointer-events:none}.graph-svg-tip.comparison .title{display:block;padding:10px;margin:0;font-weight:600;line-height:1;pointer-events:none}.graph-svg-tip.comparison ul{margin:0;white-space:nowrap;list-style:none}.graph-svg-tip.comparison li{display:inline-block;padding:5px 10px}",_createClass$2=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),BOUND_DRAW_FN=void 0,BaseChart=function(){function t(e,n){if(_classCallCheck$3(this,t),this.parent="string"==typeof e?document.querySelector(e):e,!(this.parent instanceof HTMLElement)){ throw new Error("No `parent` element to render on was provided."); }this.rawChartArgs=n,this.title=n.title||"",this.type=n.type||"",this.realData=this.prepareData(n.data),this.data=this.prepareFirstData(this.realData),this.colors=this.validateColors(n.colors,this.type),this.config={showTooltip:1,showLegend:1,isNavigable:n.isNavigable||0,animate:1},this.measures=JSON.parse(JSON.stringify(BASE_MEASURES));var i=this.measures;this.setMeasures(n),this.title.length||(i.titleHeight=0),this.config.showLegend||(i.legendHeight=0),this.argHeight=n.height||i.baseHeight,this.state={},this.options={},this.initTimeout=INIT_CHART_UPDATE_TIMEOUT,this.config.isNavigable&&(this.overlays=[]),this.configure(n);}return _createClass$2(t,[{key:"prepareData",value:function(t){return t}},{key:"prepareFirstData",value:function(t){return t}},{key:"validateColors",value:function(t,e){var n=[];return (t=(t||[]).concat(DEFAULT_COLORS[e])).forEach(function(t){var e=getColor(t);isValidColor(e)?n.push(e):console.warn('"'+t+'" is not a valid color.');}),n}},{key:"setMeasures",value:function(){}},{key:"configure",value:function(){var t=this.argHeight;this.baseHeight=t,this.height=t-getExtraHeight(this.measures),BOUND_DRAW_FN=this.boundDrawFn.bind(this),window.addEventListener("resize",BOUND_DRAW_FN),window.addEventListener("orientationchange",this.boundDrawFn.bind(this));}},{key:"boundDrawFn",value:function(){this.draw(!0);}},{key:"unbindWindowEvents",value:function(){window.removeEventListener("resize",BOUND_DRAW_FN),window.removeEventListener("orientationchange",this.boundDrawFn.bind(this));}},{key:"setup",value:function(){this.makeContainer(),this.updateWidth(),this.makeTooltip(),this.draw(!1,!0);}},{key:"makeContainer",value:function(){this.parent.innerHTML="";var t={inside:this.parent,className:"chart-container"};this.independentWidth&&(t.styles={width:this.independentWidth+"px"}),this.container=$$1.create("div",t);}},{key:"makeTooltip",value:function(){this.tip=new SvgTip({parent:this.container,colors:this.colors}),this.bindTooltip();}},{key:"bindTooltip",value:function(){}},{key:"draw",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.updateWidth(),this.calc(e),this.makeChartArea(),this.setupComponents(),this.components.forEach(function(e){return e.setup(t.drawArea)}),this.render(this.components,!1),n&&(this.data=this.realData,setTimeout(function(){t.update(t.data);},this.initTimeout)),this.renderLegend(),this.setupNavigation(n);}},{key:"calc",value:function(){}},{key:"updateWidth",value:function(){this.baseWidth=getElementContentWidth(this.parent),this.width=this.baseWidth-getExtraWidth(this.measures);}},{key:"makeChartArea",value:function(){this.svg&&this.container.removeChild(this.svg);var t=this.measures;this.svg=makeSVGContainer(this.container,"frappe-chart chart",this.baseWidth,this.baseHeight),this.svgDefs=makeSVGDefs(this.svg),this.title.length&&(this.titleEL=makeText("title",t.margins.left,t.margins.top,this.title,{fontSize:t.titleFontSize,fill:"#666666",dy:t.titleFontSize}));var e=getTopOffset(t);this.drawArea=makeSVGGroup(this.type+"-chart chart-draw-area","translate("+getLeftOffset(t)+", "+e+")"),this.config.showLegend&&(e+=this.height+t.paddings.bottom,this.legendArea=makeSVGGroup("chart-legend","translate("+getLeftOffset(t)+", "+e+")")),this.title.length&&this.svg.appendChild(this.titleEL),this.svg.appendChild(this.drawArea),this.config.showLegend&&this.svg.appendChild(this.legendArea),this.updateTipOffset(getLeftOffset(t),getTopOffset(t));}},{key:"updateTipOffset",value:function(t,e){this.tip.offset={x:t,y:e};}},{key:"setupComponents",value:function(){this.components=new Map;}},{key:"update",value:function(t){t||console.error("No data to update."),this.data=this.prepareData(t),this.calc(),this.render();}},{key:"render",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.components,n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.config.isNavigable&&this.overlays.map(function(t){return t.parentNode.removeChild(t)});var i=[];e.forEach(function(t){i=i.concat(t.update(n));}),i.length>0?(runSMILAnimation(this.container,this.svg,i),setTimeout(function(){e.forEach(function(t){return t.make()}),t.updateNav();},CHART_POST_ANIMATE_TIMEOUT)):(e.forEach(function(t){return t.make()}),this.updateNav());}},{key:"updateNav",value:function(){this.config.isNavigable&&(this.makeOverlay(),this.bindUnits());}},{key:"renderLegend",value:function(){}},{key:"setupNavigation",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.config.isNavigable&&e&&(this.bindOverlay(),this.keyActions={13:this.onEnterKey.bind(this),37:this.onLeftArrow.bind(this),38:this.onUpArrow.bind(this),39:this.onRightArrow.bind(this),40:this.onDownArrow.bind(this)},document.addEventListener("keydown",function(e){isElementInViewport(t.container)&&(e=e||window.event,t.keyActions[e.keyCode]&&t.keyActions[e.keyCode]());}));}},{key:"makeOverlay",value:function(){}},{key:"updateOverlay",value:function(){}},{key:"bindOverlay",value:function(){}},{key:"bindUnits",value:function(){}},{key:"onLeftArrow",value:function(){}},{key:"onRightArrow",value:function(){}},{key:"onUpArrow",value:function(){}},{key:"onDownArrow",value:function(){}},{key:"onEnterKey",value:function(){}},{key:"addDataPoint",value:function(){}},{key:"removeDataPoint",value:function(){}},{key:"getDataPoint",value:function(){}},{key:"setCurrentDataPoint",value:function(){}},{key:"updateDataset",value:function(){}},{key:"export",value:function(){var t=prepareForExport(this.svg);downloadFile(this.title||"Chart",[t]);}}]),t}(),_createClass$1=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get$1=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var o=a.get;if(void 0!==o){ return o.call(i) }},AggregationChart=function(t){function e(t,n){return _classCallCheck$2(this,e),_possibleConstructorReturn$1(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n))}return _inherits$1(e,t),_createClass$1(e,[{key:"configure",value:function(t){_get$1(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"configure",this).call(this,t),this.config.maxSlices=t.maxSlices||20,this.config.maxLegendPoints=t.maxLegendPoints||20;}},{key:"calc",value:function(){var t=this,e=this.state,n=this.config.maxSlices;e.sliceTotals=[];var i=this.data.labels.map(function(e,n){var i=0;return t.data.datasets.map(function(t){i+=t.values[n];}),[i,e]}).filter(function(t){return t[0]>=0}),a=i;if(i.length>n){i.sort(function(t,e){return e[0]-t[0]}),a=i.slice(0,n-1);var r=0;i.slice(n-1).map(function(t){r+=t[0];}),a.push([r,"Rest"]),this.colors[n-1]="grey";}e.labels=[],a.map(function(t){e.sliceTotals.push(t[0]),e.labels.push(t[1]);}),e.grandTotal=e.sliceTotals.reduce(function(t,e){return t+e},0),this.center={x:this.width/2,y:this.height/2};}},{key:"renderLegend",value:function(){var t=this,e=this.state;this.legendArea.textContent="",this.legendTotals=e.sliceTotals.slice(0,this.config.maxLegendPoints);var n=0,i=0;this.legendTotals.map(function(a,r){var o=Math.floor((t.width-getExtraWidth(t.measures))/110);n>o&&(n=0,i+=20);var s=legendDot(110*n+5,i,5,t.colors[r],e.labels[r]+": "+a);t.legendArea.appendChild(s),n++;});}}]),e}(BaseChart),NO_OF_YEAR_MONTHS=12,NO_OF_DAYS_IN_WEEK=7,NO_OF_MILLIS=1e3,SEC_IN_DAY=86400,MONTH_NAMES=["January","February","March","April","May","June","July","August","September","October","November","December"],DAY_NAMES_SHORT=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],_slicedToArray$3=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var o,s=t[Symbol.iterator]();!(i=(o=s.next()).done)&&(n.push(o.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&s.return&&s.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass$4=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),ChartComponent=function(){function t(e){var n=e.layerClass,i=void 0===n?"":n,a=e.layerTransform,r=void 0===a?"":a,o=e.constants,s=e.getData,l=e.makeElements,u=e.animateElements;_classCallCheck$5(this,t),this.layerTransform=r,this.constants=o,this.makeElements=l,this.getData=s,this.animateElements=u,this.store=[],this.labels=[],this.layerClass=i,this.layerClass="function"==typeof this.layerClass?this.layerClass():this.layerClass,this.refresh();}return _createClass$4(t,[{key:"refresh",value:function(t){this.data=t||this.getData();}},{key:"setup",value:function(t){this.layer=makeSVGGroup(this.layerClass,this.layerTransform,t);}},{key:"make",value:function(){this.render(this.data),this.oldData=this.data;}},{key:"render",value:function(t){var e=this;this.store=this.makeElements(t),this.layer.textContent="",this.store.forEach(function(t){e.layer.appendChild(t);}),this.labels.forEach(function(t){e.layer.appendChild(t);});}},{key:"update",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.refresh();var e=[];return t&&(e=this.animateElements(this.data)||[]),e}}]),t}(),componentConfigs={donutSlices:{layerClass:"donut-slices",makeElements:function(t){return t.sliceStrings.map(function(e,n){var i=makePath(e,"donut-path",t.colors[n],"none",t.strokeWidth);return i.style.transition="transform .3s;",i})},animateElements:function(t){return this.store.map(function(e,n){return animatePathStr(e,t.sliceStrings[n])})}},pieSlices:{layerClass:"pie-slices",makeElements:function(t){return t.sliceStrings.map(function(e,n){var i=makePath(e,"pie-path","none",t.colors[n]);return i.style.transition="transform .3s;",i})},animateElements:function(t){return this.store.map(function(e,n){return animatePathStr(e,t.sliceStrings[n])})}},percentageBars:{layerClass:"percentage-bars",makeElements:function(t){var e=this;return t.xPositions.map(function(n,i){return percentageBar(n,0,t.widths[i],e.constants.barHeight,e.constants.barDepth,t.colors[i])})},animateElements:function(t){if(t){ return [] }}},yAxis:{layerClass:"y axis",makeElements:function(t){var e=this;return t.positions.map(function(n,i){return yLine(n,t.labels[i],e.constants.width,{mode:e.constants.mode,pos:e.constants.pos})})},animateElements:function(t){var e=t.positions,n=t.labels,i=this.oldData.positions,a=this.oldData.labels,r=equilizeNoOfElements(i,e),o=_slicedToArray$3(r,2);i=o[0],e=o[1];var s=equilizeNoOfElements(a,n),l=_slicedToArray$3(s,2);return a=l[0],n=l[1],this.render({positions:i,labels:n}),this.store.map(function(t,n){return translateHoriLine(t,e[n],i[n])})}},xAxis:{layerClass:"x axis",makeElements:function(t){var e=this;return t.positions.map(function(n,i){return xLine(n,t.calcLabels[i],e.constants.height,{mode:e.constants.mode,pos:e.constants.pos})})},animateElements:function(t){var e=t.positions,n=t.calcLabels,i=this.oldData.positions,a=this.oldData.calcLabels,r=equilizeNoOfElements(i,e),o=_slicedToArray$3(r,2);i=o[0],e=o[1];var s=equilizeNoOfElements(a,n),l=_slicedToArray$3(s,2);return a=l[0],n=l[1],this.render({positions:i,calcLabels:n}),this.store.map(function(t,n){return translateVertLine(t,e[n],i[n])})}},yMarkers:{layerClass:"y-markers",makeElements:function(t){var e=this;return t.map(function(t){return yMarker(t.position,t.label,e.constants.width,{labelPos:t.options.labelPos,mode:"span",lineType:"dashed"})})},animateElements:function(t){var e=equilizeNoOfElements(this.oldData,t),n=_slicedToArray$3(e,2);this.oldData=n[0];var i=(t=n[1]).map(function(t){return t.position}),a=t.map(function(t){return t.label}),r=t.map(function(t){return t.options}),o=this.oldData.map(function(t){return t.position});return this.render(o.map(function(t,e){return {position:o[e],label:a[e],options:r[e]}})),this.store.map(function(t,e){return translateHoriLine(t,i[e],o[e])})}},yRegions:{layerClass:"y-regions",makeElements:function(t){var e=this;return t.map(function(t){return yRegion(t.startPos,t.endPos,e.constants.width,t.label,{labelPos:t.options.labelPos})})},animateElements:function(t){var e=equilizeNoOfElements(this.oldData,t),n=_slicedToArray$3(e,2);this.oldData=n[0];var i=(t=n[1]).map(function(t){return t.endPos}),a=t.map(function(t){return t.label}),r=t.map(function(t){return t.startPos}),o=t.map(function(t){return t.options}),s=this.oldData.map(function(t){return t.endPos}),l=this.oldData.map(function(t){return t.startPos});this.render(s.map(function(t,e){return {startPos:l[e],endPos:s[e],label:a[e],options:o[e]}}));var u=[];return this.store.map(function(t,e){u=u.concat(animateRegion(t,r[e],i[e],s[e]));}),u}},heatDomain:{layerClass:function(){return "heat-domain domain-"+this.constants.index},makeElements:function(t){var e=this,n=this.constants,i=n.index,a=n.colWidth,r=n.rowHeight,o=n.squareSize,s=n.xTranslate,l=0;return this.serializedSubDomains=[],t.cols.map(function(t,n){1===n&&e.labels.push(makeText("domain-name",s,-12,getMonthName(i,!0).toUpperCase(),{fontSize:9})),t.map(function(t,n){if(t.fill){var i={"data-date":t.yyyyMmDd,"data-value":t.dataValue,"data-day":n},a=heatSquare("day",s,l,o,t.fill,i);e.serializedSubDomains.push(a);}l+=r;}),l=0,s+=a;}),this.serializedSubDomains},animateElements:function(t){if(t){ return [] }}},barGraph:{layerClass:function(){return "dataset-units dataset-bars dataset-"+this.constants.index},makeElements:function(t){var e=this.constants;return this.unitType="bar",this.units=t.yPositions.map(function(n,i){return datasetBar(t.xPositions[i],n,t.barWidth,e.color,t.labels[i],i,t.offsets[i],{zeroLine:t.zeroLine,barsWidth:t.barsWidth,minHeight:e.minHeight})}),this.units},animateElements:function(t){var e=t.xPositions,n=t.yPositions,i=t.offsets,a=t.labels,r=this.oldData.xPositions,o=this.oldData.yPositions,s=this.oldData.offsets,l=this.oldData.labels,u=equilizeNoOfElements(r,e),c=_slicedToArray$3(u,2);r=c[0],e=c[1];var h=equilizeNoOfElements(o,n),d=_slicedToArray$3(h,2);o=d[0],n=d[1];var f=equilizeNoOfElements(s,i),p=_slicedToArray$3(f,2);s=p[0],i=p[1];var v=equilizeNoOfElements(l,a),y=_slicedToArray$3(v,2);l=y[0],a=y[1],this.render({xPositions:r,yPositions:o,offsets:s,labels:a,zeroLine:this.oldData.zeroLine,barsWidth:this.oldData.barsWidth,barWidth:this.oldData.barWidth});var g=[];return this.store.map(function(a,r){g=g.concat(animateBar(a,e[r],n[r],t.barWidth,i[r],{zeroLine:t.zeroLine}));}),g}},lineGraph:{layerClass:function(){return "dataset-units dataset-line dataset-"+this.constants.index},makeElements:function(t){var e=this.constants;return this.unitType="dot",this.paths={},e.hideLine||(this.paths=getPaths(t.xPositions,t.yPositions,e.color,{heatline:e.heatline,regionFill:e.regionFill},{svgDefs:e.svgDefs,zeroLine:t.zeroLine})),this.units=[],e.hideDots||(this.units=t.yPositions.map(function(n,i){return datasetDot(t.xPositions[i],n,t.radius,e.color,e.valuesOverPoints?t.values[i]:"",i)})),Object.values(this.paths).concat(this.units)},animateElements:function(t){var e=t.xPositions,n=t.yPositions,i=t.values,a=this.oldData.xPositions,r=this.oldData.yPositions,o=this.oldData.values,s=equilizeNoOfElements(a,e),l=_slicedToArray$3(s,2);a=l[0],e=l[1];var u=equilizeNoOfElements(r,n),c=_slicedToArray$3(u,2);r=c[0],n=c[1];var h=equilizeNoOfElements(o,i),d=_slicedToArray$3(h,2);o=d[0],i=d[1],this.render({xPositions:a,yPositions:r,values:i,zeroLine:this.oldData.zeroLine,radius:this.oldData.radius});var f=[];return Object.keys(this.paths).length&&(f=f.concat(animatePath(this.paths,e,n,t.zeroLine))),this.units.length&&this.units.map(function(t,i){f=f.concat(animateDot(t,e[i],n[i]));}),f}}},_createClass=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var o=a.get;if(void 0!==o){ return o.call(i) }},PercentageChart=function(t){function e(t,n){_classCallCheck$1(this,e);var i=_possibleConstructorReturn(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return i.type="percentage",i.setup(),i}return _inherits(e,t),_createClass(e,[{key:"setMeasures",value:function(t){var e=this.measures;this.barOptions=t.barOptions||{};var n=this.barOptions;n.height=n.height||PERCENTAGE_BAR_DEFAULT_HEIGHT,n.depth=n.depth||PERCENTAGE_BAR_DEFAULT_DEPTH,e.paddings.right=30,e.legendHeight=80,e.baseHeight=8*(n.height+.5*n.depth);}},{key:"setupComponents",value:function(){var t=this.state,e=[["percentageBars",{barHeight:this.barOptions.height,barDepth:this.barOptions.depth},function(){return {xPositions:t.xPositions,widths:t.widths,colors:this.colors}}.bind(this)]];this.components=new Map(e.map(function(t){var e=getComponent.apply(void 0,_toConsumableArray(t));return [t[0],e]}));}},{key:"calc",value:function(){var t=this;_get(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"calc",this).call(this);var n=this.state;n.xPositions=[],n.widths=[];var i=0;n.sliceTotals.map(function(e){var a=t.width*e/n.grandTotal;n.widths.push(a),n.xPositions.push(i),i+=a;});}},{key:"makeDataByIndex",value:function(){}},{key:"bindTooltip",value:function(){var t=this,e=this.state;this.container.addEventListener("mousemove",function(n){var i=t.components.get("percentageBars").store,a=n.target;if(i.includes(a)){var r=i.indexOf(a),o=getOffset(t.container),s=getOffset(a),l=s.left-o.left+parseInt(a.getAttribute("width"))/2,u=s.top-o.top,c=(t.formattedLabels&&t.formattedLabels.length>0?t.formattedLabels[r]:t.state.labels[r])+": ",h=e.sliceTotals[r]/e.grandTotal;t.tip.setValues(l,u,{name:c,value:(100*h).toFixed(1)+"%"}),t.tip.showTip();}});}}]),e}(AggregationChart),_createClass$5=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get$2=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var o=a.get;if(void 0!==o){ return o.call(i) }},PieChart=function(t){function e(t,n){_classCallCheck$6(this,e);var i=_possibleConstructorReturn$2(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return i.type="pie",i.initTimeout=0,i.init=1,i.setup(),i}return _inherits$2(e,t),_createClass$5(e,[{key:"configure",value:function(t){_get$2(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"configure",this).call(this,t),this.mouseMove=this.mouseMove.bind(this),this.mouseLeave=this.mouseLeave.bind(this),this.hoverRadio=t.hoverRadio||.1,this.config.startAngle=t.startAngle||0,this.clockWise=t.clockWise||!1;}},{key:"calc",value:function(){var t=this;_get$2(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"calc",this).call(this);var n=this.state;this.radius=this.height>this.width?this.center.x:this.center.y;var i=this.radius,a=this.clockWise,r=n.slicesProperties||[];n.sliceStrings=[],n.slicesProperties=[];var o=180-this.config.startAngle;n.sliceTotals.map(function(e,s){var l=o,u=e/n.grandTotal*FULL_ANGLE,c=0;u>180&&(c=1);var h=a?-u:u,d=o+=h,f=getPositionByAngle(l,i),p=getPositionByAngle(d,i),v=t.init&&r[s],y=void 0,g=void 0;t.init?(y=v?v.startPosition:f,g=v?v.endPosition:f):(y=f,g=p);var m=makeArcPathStr(y,g,t.center,t.radius,a,c);n.sliceStrings.push(m),n.slicesProperties.push({startPosition:f,endPosition:p,value:e,total:n.grandTotal,startAngle:l,endAngle:d,angle:h});}),this.init=0;}},{key:"setupComponents",value:function(){var t=this.state,e=[["pieSlices",{},function(){return {sliceStrings:t.sliceStrings,colors:this.colors}}.bind(this)]];this.components=new Map(e.map(function(t){var e=getComponent.apply(void 0,_toConsumableArray$2(t));return [t[0],e]}));}},{key:"calTranslateByAngle",value:function(t){var e=this.radius,n=this.hoverRadio,i=getPositionByAngle(t.startAngle+t.angle/2,e);return "translate3d("+i.x*n+"px,"+i.y*n+"px,0)"}},{key:"hoverSlice",value:function(t,e,n,i){if(t){var a=this.colors[e];if(n){transform(t,this.calTranslateByAngle(this.state.slicesProperties[e])),t.style.fill=lightenDarkenColor(a,50);var r=getOffset(this.svg),o=i.pageX-r.left+10,s=i.pageY-r.top-10,l=(this.formatted_labels&&this.formatted_labels.length>0?this.formatted_labels[e]:this.state.labels[e])+": ",u=(100*this.state.sliceTotals[e]/this.state.grandTotal).toFixed(1);this.tip.setValues(o,s,{name:l,value:u+"%"}),this.tip.showTip();}else { transform(t,"translate3d(0,0,0)"),this.tip.hideTip(),t.style.fill=a; }}}},{key:"bindTooltip",value:function(){this.container.addEventListener("mousemove",this.mouseMove),this.container.addEventListener("mouseleave",this.mouseLeave);}},{key:"mouseMove",value:function(t){var e=t.target,n=this.components.get("pieSlices").store,i=this.curActiveSliceIndex,a=this.curActiveSlice;if(n.includes(e)){var r=n.indexOf(e);this.hoverSlice(a,i,!1),this.curActiveSlice=e,this.curActiveSliceIndex=r,this.hoverSlice(e,r,!0,t);}else { this.mouseLeave(); }}},{key:"mouseLeave",value:function(){this.hoverSlice(this.curActiveSlice,this.curActiveSliceIndex,!1);}}]),e}(AggregationChart),_slicedToArray$4=function(){function t(t,e){var n=[],i=!0,a=!1,r=void 0;try{for(var o,s=t[Symbol.iterator]();!(i=(o=s.next()).done)&&(n.push(o.value),!e||n.length!==e);i=!0){ }}catch(t){a=!0,r=t;}finally{try{!i&&s.return&&s.return();}finally{if(a){ throw r }}}return n}return function(e,n){if(Array.isArray(e)){ return e; }if(Symbol.iterator in Object(e)){ return t(e,n); }throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass$6=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),COL_WIDTH=HEATMAP_SQUARE_SIZE+HEATMAP_GUTTER_SIZE,ROW_HEIGHT=COL_WIDTH,Heatmap=function(t){function e(t,n){_classCallCheck$7(this,e);var i=_possibleConstructorReturn$3(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));i.type="heatmap",i.countLabel=n.countLabel||"";var a=["Sunday","Monday"],r=a.includes(n.startSubDomain)?n.startSubDomain:"Sunday";return i.startSubDomainIndex=a.indexOf(r),i.setup(),i}return _inherits$3(e,t),_createClass$6(e,[{key:"setMeasures",value:function(t){var e=this.measures;this.discreteDomains=0===t.discreteDomains?0:1,e.paddings.top=3*ROW_HEIGHT,e.paddings.bottom=0,e.legendHeight=2*ROW_HEIGHT,e.baseHeight=ROW_HEIGHT*NO_OF_DAYS_IN_WEEK+getExtraHeight(e);var n=this.data,i=this.discreteDomains?NO_OF_YEAR_MONTHS:0;this.independentWidth=(getWeeksBetween(n.start,n.end)+i)*COL_WIDTH+getExtraWidth(e);}},{key:"updateWidth",value:function(){var t=this.discreteDomains?NO_OF_YEAR_MONTHS:0,e=this.state.noOfWeeks?this.state.noOfWeeks:52;this.baseWidth=(e+t)*COL_WIDTH+getExtraWidth(this.measures);}},{key:"prepareData",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.data;if(t.start&&t.end&&t.start>t.end){ throw new Error("Start date cannot be greater than end date."); }if(t.start||(t.start=new Date,t.start.setFullYear(t.start.getFullYear()-1)),t.end||(t.end=new Date),t.dataPoints=t.dataPoints||{},parseInt(Object.keys(t.dataPoints)[0])>1e5){var e={};Object.keys(t.dataPoints).forEach(function(n){var i=new Date(n*NO_OF_MILLIS);e[getYyyyMmDd(i)]=t.dataPoints[n];}),t.dataPoints=e;}return t}},{key:"calc",value:function(){var t=this.state;t.start=clone(this.data.start),t.end=clone(this.data.end),t.firstWeekStart=clone(t.start),t.noOfWeeks=getWeeksBetween(t.start,t.end),t.distribution=calcDistribution(Object.values(this.data.dataPoints),HEATMAP_DISTRIBUTION_SIZE),t.domainConfigs=this.getDomains();}},{key:"setupComponents",value:function(){var t=this,e=this.state,n=this.discreteDomains?0:1,i=e.domainConfigs.map(function(i,a){return ["heatDomain",{index:i.index,colWidth:COL_WIDTH,rowHeight:ROW_HEIGHT,squareSize:HEATMAP_SQUARE_SIZE,xTranslate:e.domainConfigs.filter(function(t,e){return e<a}).map(function(t){return t.cols.length-n}).reduce(function(t,e){return t+e},0)*COL_WIDTH},function(){return e.domainConfigs[a]}.bind(t)]});this.components=new Map(i.map(function(t,e){var n=getComponent.apply(void 0,_toConsumableArray$3(t));return [t[0]+"-"+e,n]}));var a=0;DAY_NAMES_SHORT.forEach(function(e,n){if([1,3,5].includes(n)){var i=makeText("subdomain-name",-COL_WIDTH/2,a,e,{fontSize:HEATMAP_SQUARE_SIZE,dy:8,textAnchor:"end"});t.drawArea.appendChild(i);}a+=ROW_HEIGHT;});}},{key:"update",value:function(t){t||console.error("No data to update."),this.data=this.prepareData(t),this.draw(),this.bindTooltip();}},{key:"bindTooltip",value:function(){var t=this;this.container.addEventListener("mousemove",function(e){t.components.forEach(function(n){var i=n.store,a=e.target;if(i.includes(a)){var r=a.getAttribute("data-value"),o=a.getAttribute("data-date").split("-"),s=getMonthName(parseInt(o[1])-1,!0),l=t.container.getBoundingClientRect(),u=a.getBoundingClientRect(),c=parseInt(e.target.getAttribute("width")),h=u.left-l.left+c/2,d=u.top-l.top,f=r+" "+t.countLabel,p=" on "+s+" "+o[0]+", "+o[2];t.tip.setValues(h,d,{name:p,value:f,valueFirst:1},[]),t.tip.showTip();}});});}},{key:"renderLegend",value:function(){var t=this;this.legendArea.textContent="";var e=0,n=ROW_HEIGHT,i=makeText("subdomain-name",e,n,"Less",{fontSize:HEATMAP_SQUARE_SIZE+1,dy:9});e=2*COL_WIDTH+COL_WIDTH/2,this.legendArea.appendChild(i),this.colors.slice(0,HEATMAP_DISTRIBUTION_SIZE).map(function(i,a){var r=heatSquare("heatmap-legend-unit",e+(COL_WIDTH+3)*a,n,HEATMAP_SQUARE_SIZE,i);t.legendArea.appendChild(r);});var a=makeText("subdomain-name",e+HEATMAP_DISTRIBUTION_SIZE*(COL_WIDTH+3)+COL_WIDTH/4,n,"More",{fontSize:HEATMAP_SQUARE_SIZE+1,dy:9});this.legendArea.appendChild(a);}},{key:"getDomains",value:function(){for(var t=this.state,e=[t.start.getMonth(),t.start.getFullYear()],n=e[0],i=e[1],a=[t.end.getMonth(),t.end.getFullYear()],r=a[0]-n+1+12*(a[1]-i),o=[],s=clone(t.start),l=0;l<r;l++){var u=t.end;if(!areInSameMonth(s,t.end)){var c=[s.getMonth(),s.getFullYear()];u=getLastDateInMonth(c[0],c[1]);}o.push(this.getDomainConfig(s,u)),addDays(u,1),s=u;}return o}},{key:"getDomainConfig",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=[t.getMonth(),t.getFullYear()],i=n[0],a=n[1],r=setDayToSunday(t),o={index:i,cols:[]};addDays(e=clone(e)||getLastDateInMonth(i,a),1);for(var s=getWeeksBetween(r,e),l=[],u=void 0,c=0;c<s;c++){ u=this.getCol(r,i),l.push(u),addDays(r=new Date(u[NO_OF_DAYS_IN_WEEK-1].yyyyMmDd),1); }return void 0!==u[NO_OF_DAYS_IN_WEEK-1].dataValue&&(addDays(r,1),l.push(this.getCol(r,i,!0))),o.cols=l,o}},{key:"getCol",value:function(t,e){for(var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=this.state,a=clone(t),r=[],o=0;o<NO_OF_DAYS_IN_WEEK;o++,addDays(a,1)){var s={},l=a>=i.start&&a<=i.end;n||a.getMonth()!==e||!l?s.yyyyMmDd=getYyyyMmDd(a):s=this.getSubDomainConfig(a),r.push(s);}return r}},{key:"getSubDomainConfig",value:function(t){var e=getYyyyMmDd(t),n=this.data.dataPoints[e];return {yyyyMmDd:e,dataValue:n||0,fill:this.colors[getMaxCheckpoint(n,this.state.distribution)]}}}]),e}(BaseChart),_createClass$7=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get$3=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var o=a.get;if(void 0!==o){ return o.call(i) }},AxisChart=function(t){function e(t,n){_classCallCheck$8(this,e);var i=_possibleConstructorReturn$4(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return i.barOptions=n.barOptions||{},i.lineOptions=n.lineOptions||{},i.type=n.type||"line",i.init=1,i.setup(),i}return _inherits$4(e,t),_createClass$7(e,[{key:"setMeasures",value:function(){this.data.datasets.length<=1&&(this.config.showLegend=0,this.measures.paddings.bottom=30);}},{key:"configure",value:function(t){_get$3(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"configure",this).call(this,t),t.axisOptions=t.axisOptions||{},t.tooltipOptions=t.tooltipOptions||{},this.config.xAxisMode=t.axisOptions.xAxisMode||"span",this.config.yAxisMode=t.axisOptions.yAxisMode||"span",this.config.xIsSeries=t.axisOptions.xIsSeries||0,this.config.formatTooltipX=t.tooltipOptions.formatTooltipX,this.config.formatTooltipY=t.tooltipOptions.formatTooltipY,this.config.valuesOverPoints=t.valuesOverPoints;}},{key:"prepareData",value:function(){return dataPrep(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.data,this.type)}},{key:"prepareFirstData",value:function(){return zeroDataPrep(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.data)}},{key:"calc",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.calcXPositions(),t||this.calcYAxisParameters(this.getAllYValues(),"line"===this.type),this.makeDataByIndex();}},{key:"calcXPositions",value:function(){var t=this.state,e=this.data.labels;t.datasetLength=e.length,t.unitWidth=this.width/t.datasetLength,t.xOffset=t.unitWidth/2,t.xAxis={labels:e,positions:e.map(function(e,n){return floatTwo(t.xOffset+n*t.unitWidth)})};}},{key:"calcYAxisParameters",value:function(t){var e=calcChartIntervals(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:"false"),n=this.height/getValueRange(e),i=getIntervalSize(e)*n,a=this.height-getZeroIndex(e)*i;this.state.yAxis={labels:e,positions:e.map(function(t){return a-t*n}),scaleMultiplier:n,zeroLine:a},this.calcDatasetPoints(),this.calcYExtremes(),this.calcYRegions();}},{key:"calcDatasetPoints",value:function(){var t=this.state,e=function(e){return e.map(function(e){return scale(e,t.yAxis)})};t.datasets=this.data.datasets.map(function(t,n){var i=t.values,a=t.cumulativeYs||[];return {name:t.name,index:n,chartType:t.chartType,values:i,yPositions:e(i),cumulativeYs:a,cumulativeYPos:e(a)}});}},{key:"calcYExtremes",value:function(){var t=this.state;if(this.barOptions.stacked){ return void(t.yExtremes=t.datasets[t.datasets.length-1].cumulativeYPos); }t.yExtremes=new Array(t.datasetLength).fill(9999),t.datasets.map(function(e){e.yPositions.map(function(e,n){e<t.yExtremes[n]&&(t.yExtremes[n]=e);});});}},{key:"calcYRegions",value:function(){var t=this.state;this.data.yMarkers&&(this.state.yMarkers=this.data.yMarkers.map(function(e){return e.position=scale(e.value,t.yAxis),e.options||(e.options={}),e})),this.data.yRegions&&(this.state.yRegions=this.data.yRegions.map(function(e){return e.startPos=scale(e.start,t.yAxis),e.endPos=scale(e.end,t.yAxis),e.options||(e.options={}),e}));}},{key:"getAllYValues",value:function(){var t,e=this,n="values";if(this.barOptions.stacked){n="cumulativeYs";var i=new Array(this.state.datasetLength).fill(0);this.data.datasets.map(function(t,a){var r=e.data.datasets[a].values;t[n]=i=i.map(function(t,e){return t+r[e]});});}var a=this.data.datasets.map(function(t){return t[n]});return this.data.yMarkers&&a.push(this.data.yMarkers.map(function(t){return t.value})),this.data.yRegions&&this.data.yRegions.map(function(t){a.push([t.end,t.start]);}),(t=[]).concat.apply(t,_toConsumableArray$5(a))}},{key:"setupComponents",value:function(){var t=this,e=[["yAxis",{mode:this.config.yAxisMode,width:this.width},function(){return this.state.yAxis}.bind(this)],["xAxis",{mode:this.config.xAxisMode,height:this.height},function(){var t=this.state;return t.xAxis.calcLabels=getShortenedLabels(this.width,t.xAxis.labels,this.config.xIsSeries),t.xAxis}.bind(this)],["yRegions",{width:this.width,pos:"right"},function(){return this.state.yRegions}.bind(this)]],n=this.state.datasets.filter(function(t){return "bar"===t.chartType}),i=this.state.datasets.filter(function(t){return "line"===t.chartType}),a=n.map(function(e){var i=e.index;return ["barGraph-"+e.index,{index:i,color:t.colors[i],stacked:t.barOptions.stacked,valuesOverPoints:t.config.valuesOverPoints,minHeight:t.height*MIN_BAR_PERCENT_HEIGHT},function(){var t=this.state,e=t.datasets[i],a=this.barOptions.stacked,r=this.barOptions.spaceRatio||BAR_CHART_SPACE_RATIO,o=t.unitWidth*(1-r),s=o/(a?1:n.length),l=t.xAxis.positions.map(function(t){return t-o/2});a||(l=l.map(function(t){return t+s*i}));var u=new Array(t.datasetLength).fill("");this.config.valuesOverPoints&&(u=a&&e.index===t.datasets.length-1?e.cumulativeYs:e.values);var c=new Array(t.datasetLength).fill(0);return a&&(c=e.yPositions.map(function(t,n){return t-e.cumulativeYPos[n]})),{xPositions:l,yPositions:e.yPositions,offsets:c,labels:u,zeroLine:t.yAxis.zeroLine,barsWidth:o,barWidth:s}}.bind(t)]}),r=i.map(function(e){var n=e.index;return ["lineGraph-"+e.index,{index:n,color:t.colors[n],svgDefs:t.svgDefs,heatline:t.lineOptions.heatline,regionFill:t.lineOptions.regionFill,hideDots:t.lineOptions.hideDots,hideLine:t.lineOptions.hideLine,valuesOverPoints:t.config.valuesOverPoints},function(){var t=this.state,e=t.datasets[n],i=t.yAxis.positions[0]<t.yAxis.zeroLine?t.yAxis.positions[0]:t.yAxis.zeroLine;return {xPositions:t.xAxis.positions,yPositions:e.yPositions,values:e.values,zeroLine:i,radius:this.lineOptions.dotSize||LINE_CHART_DOT_SIZE}}.bind(t)]}),o=[["yMarkers",{width:this.width,pos:"right"},function(){return this.state.yMarkers}.bind(this)]];e=e.concat(a,r,o);var s=["yMarkers","yRegions"];this.dataUnitComponents=[],this.components=new Map(e.filter(function(e){return !s.includes(e[0])||t.state[e[0]]}).map(function(e){var n=getComponent.apply(void 0,_toConsumableArray$5(e));return (e[0].includes("lineGraph")||e[0].includes("barGraph"))&&t.dataUnitComponents.push(n),[e[0],n]}));}},{key:"makeDataByIndex",value:function(){var t=this;this.dataByIndex={};var e=this.state,n=this.config.formatTooltipX,i=this.config.formatTooltipY;e.xAxis.labels.map(function(a,r){var o=t.state.datasets.map(function(e,n){var a=e.values[r];return {title:e.name,value:a,yPos:e.yPositions[r],color:t.colors[n],formatted:i?i(a):a}});t.dataByIndex[r]={label:a,formattedLabel:n?n(a):a,xPos:e.xAxis.positions[r],values:o,yExtreme:e.yExtremes[r]};});}},{key:"bindTooltip",value:function(){var t=this;this.container.addEventListener("mousemove",function(e){var n=t.measures,i=getOffset(t.container),a=e.pageX-i.left-getLeftOffset(n),r=e.pageY-i.top;r<t.height+getTopOffset(n)&&r>getTopOffset(n)?t.mapTooltipXPosition(a):t.tip.hideTip();});}},{key:"mapTooltipXPosition",value:function(t){var e=this.state;if(e.yExtremes){var n=getClosestInArray(t,e.xAxis.positions,!0),i=this.dataByIndex[n];this.tip.setValues(i.xPos+this.tip.offset.x,i.yExtreme+this.tip.offset.y,{name:i.formattedLabel,value:""},i.values,n),this.tip.showTip();}}},{key:"renderLegend",value:function(){var t=this,e=this.data;e.datasets.length>1&&(this.legendArea.textContent="",e.datasets.map(function(e,n){var i=AXIS_LEGEND_BAR_SIZE,a=legendBar(i*n,"0",i,t.colors[n],e.name);t.legendArea.appendChild(a);}));}},{key:"makeOverlay",value:function(){var t=this;if(this.init){ return void(this.init=0); }this.overlayGuides&&this.overlayGuides.forEach(function(t){var e=t.overlay;e.parentNode.removeChild(e);}),this.overlayGuides=this.dataUnitComponents.map(function(t){return {type:t.unitType,overlay:void 0,units:t.units}}),void 0===this.state.currentIndex&&(this.state.currentIndex=this.state.datasetLength-1),this.overlayGuides.map(function(e){var n=e.units[t.state.currentIndex];e.overlay=makeOverlay[e.type](n),t.drawArea.appendChild(e.overlay);});}},{key:"updateOverlayGuides",value:function(){this.overlayGuides&&this.overlayGuides.forEach(function(t){var e=t.overlay;e.parentNode.removeChild(e);});}},{key:"bindOverlay",value:function(){var t=this;this.parent.addEventListener("data-select",function(){t.updateOverlay();});}},{key:"bindUnits",value:function(){var t=this;this.dataUnitComponents.map(function(e){e.units.map(function(e){e.addEventListener("click",function(){var n=e.getAttribute("data-point-index");t.setCurrentDataPoint(n);});});}),this.tip.container.addEventListener("click",function(){var e=t.tip.container.getAttribute("data-point-index");t.setCurrentDataPoint(e);});}},{key:"updateOverlay",value:function(){var t=this;this.overlayGuides.map(function(e){var n=e.units[t.state.currentIndex];updateOverlay[e.type](n,e.overlay);});}},{key:"onLeftArrow",value:function(){this.setCurrentDataPoint(this.state.currentIndex-1);}},{key:"onRightArrow",value:function(){this.setCurrentDataPoint(this.state.currentIndex+1);}},{key:"getDataPoint",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.state.currentIndex,e=this.state;return {index:t,label:e.xAxis.labels[t],values:e.datasets.map(function(e){return e.values[t]})}}},{key:"setCurrentDataPoint",value:function(t){var e=this.state;(t=parseInt(t))<0&&(t=0),t>=e.xAxis.labels.length&&(t=e.xAxis.labels.length-1),t!==e.currentIndex&&(e.currentIndex=t,fire(this.parent,"data-select",this.getDataPoint()));}},{key:"addDataPoint",value:function(t,n){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.state.datasetLength;_get$3(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"addDataPoint",this).call(this,t,n,i),this.data.labels.splice(i,0,t),this.data.datasets.map(function(t,e){t.values.splice(i,0,n[e]);}),this.update(this.data);}},{key:"removeDataPoint",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.state.datasetLength-1;this.data.labels.length<=1||(_get$3(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"removeDataPoint",this).call(this,t),this.data.labels.splice(t,1),this.data.datasets.map(function(e){e.values.splice(t,1);}),this.update(this.data));}},{key:"updateDataset",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.data.datasets[e].values=t,this.update(this.data);}},{key:"updateDatasets",value:function(t){this.data.datasets.map(function(e,n){t[n]&&(e.values=t[n]);}),this.update(this.data);}}]),e}(BaseChart),_createClass$8=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i);}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),_get$4=function t(e,n,i){null===e&&(e=Function.prototype);var a=Object.getOwnPropertyDescriptor(e,n);if(void 0===a){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in a){ return a.value; }var o=a.get;if(void 0!==o){ return o.call(i) }},DonutChart=function(t){function e(t,n){_classCallCheck$9(this,e);var i=_possibleConstructorReturn$5(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return i.type="donut",i.initTimeout=0,i.init=1,i.setup(),i}return _inherits$5(e,t),_createClass$8(e,[{key:"configure",value:function(t){_get$4(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"configure",this).call(this,t),this.mouseMove=this.mouseMove.bind(this),this.mouseLeave=this.mouseLeave.bind(this),this.hoverRadio=t.hoverRadio||.1,this.config.startAngle=t.startAngle||0,this.clockWise=t.clockWise||!1,this.strokeWidth=t.strokeWidth||30;}},{key:"calc",value:function(){var t=this;_get$4(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"calc",this).call(this);var n=this.state;this.radius=this.height>this.width?this.center.x-this.strokeWidth/2:this.center.y-this.strokeWidth/2;var i=this.radius,a=this.clockWise,r=n.slicesProperties||[];n.sliceStrings=[],n.slicesProperties=[];var o=180-this.config.startAngle;n.sliceTotals.map(function(e,s){var l=o,u=e/n.grandTotal*FULL_ANGLE,c=a?-u:u,h=o+=c,d=getPositionByAngle(l,i),f=getPositionByAngle(h,i),p=t.init&&r[s],v=void 0,y=void 0;t.init?(v=p?p.startPosition:d,y=p?p.endPosition:d):(v=d,y=f);var g=makeArcStrokePathStr(v,y,t.center,t.radius,t.clockWise);n.sliceStrings.push(g),n.slicesProperties.push({startPosition:d,endPosition:f,value:e,total:n.grandTotal,startAngle:l,endAngle:h,angle:c});}),this.init=0;}},{key:"setupComponents",value:function(){var t=this.state,e=[["donutSlices",{},function(){return {sliceStrings:t.sliceStrings,colors:this.colors,strokeWidth:this.strokeWidth}}.bind(this)]];this.components=new Map(e.map(function(t){var e=getComponent.apply(void 0,_toConsumableArray$6(t));return [t[0],e]}));}},{key:"calTranslateByAngle",value:function(t){var e=this.radius,n=this.hoverRadio,i=getPositionByAngle(t.startAngle+t.angle/2,e);return "translate3d("+i.x*n+"px,"+i.y*n+"px,0)"}},{key:"hoverSlice",value:function(t,e,n,i){if(t){var a=this.colors[e];if(n){transform(t,this.calTranslateByAngle(this.state.slicesProperties[e])),t.style.stroke=lightenDarkenColor(a,50);var r=getOffset(this.svg),o=i.pageX-r.left+10,s=i.pageY-r.top-10,l=(this.formatted_labels&&this.formatted_labels.length>0?this.formatted_labels[e]:this.state.labels[e])+": ",u=(100*this.state.sliceTotals[e]/this.state.grandTotal).toFixed(1);this.tip.setValues(o,s,{name:l,value:u+"%"}),this.tip.showTip();}else { transform(t,"translate3d(0,0,0)"),this.tip.hideTip(),t.style.stroke=a; }}}},{key:"bindTooltip",value:function(){this.container.addEventListener("mousemove",this.mouseMove),this.container.addEventListener("mouseleave",this.mouseLeave);}},{key:"mouseMove",value:function(t){var e=t.target,n=this.components.get("donutSlices").store,i=this.curActiveSliceIndex,a=this.curActiveSlice;if(n.includes(e)){var r=n.indexOf(e);this.hoverSlice(a,i,!1),this.curActiveSlice=e,this.curActiveSliceIndex=r,this.hoverSlice(e,r,!0,t);}else { this.mouseLeave(); }}},{key:"mouseLeave",value:function(){this.hoverSlice(this.curActiveSlice,this.curActiveSliceIndex,!1);}}]),e}(AggregationChart),chartTypes={bar:AxisChart,line:AxisChart,percentage:PercentageChart,heatmap:Heatmap,pie:PieChart,donut:DonutChart},Chart=function t(e,n){return _classCallCheck(this,t),getChartByType(n.type,e,n)};

	frappe.Chart = Chart;

	exports.__moduleExports = _class;

	return exports;

}({}));
//# sourceMappingURL=desk.min.js.map
